[
    {
        "title": "optimize recv_fix_encryption_hierarchy()"
    },
    {
        "author": {
            "login": "PR Description"
        },
        "body": "<!--- Please fill out the following template, which will help other contributors review your Pull Request. -->\r\n\r\n<!--- Provide a general summary of your changes in the Title above -->\r\n\r\n<!---\r\nDocumentation on ZFS Buildbot options can be found at\r\nhttps://openzfs.github.io/openzfs-docs/Developer%20Resources/Buildbot%20Options.html\r\n-->\r\n\r\n### Motivation and Context\r\n<!--- Why is this change required? What problem does it solve? -->\r\n<!--- If it fixes an open issue, please link to the issue here. -->\r\nMotivation: #16317 \r\nCloses: #16317\r\n\r\n### Description\r\n<!--- Describe your changes in detail -->\r\nrecv_fix_encryption_hierarchy() in its present state goes through all\r\nstream filesystems, and for each one traverses the snapshots in order to\r\nfind one that exists locally. This happens by calling guid_to_name() for\r\neach snapshot, which iterates through all children of the filesystem.\r\nThis results in CPU utilization of 100% for several minutes (for ~1000\r\nfilesystems on a Ryzen 4350G) for 1 thread at the end of a raw receive\r\n(-w, regardless whether encrypted or not, dryrun or not).\r\n\r\nFix this by following a different logic: using the top_fs name, call\r\ngather_nvlist() to gather the nvlists for all local filesystems. For\r\neach one filesystem, go through the snapshots to find the corresponding\r\nstream's filesystem (since we know the snapshots guid and can search\r\nwith it in stream_avl for the stream's fs). Then go on to fix the\r\nencryption roots and locations as in its present state.\r\n\r\nAvoiding guid_to_name() iteratively makes\r\nrecv_fix_encryption_hierarchy() significantly faster (from several\r\nminutes to seconds for ~1000 filesystems on a Ryzen 4350G).\r\n\r\nAnother problem is the following: in case we have promoted a clone of\r\nthe filesystem outside the top filesystem specified in zfs send, zfs\r\nreceive does not fail but returns an error:\r\nrecv_incremental_replication() fails to find its origin and errors out\r\nwith needagain=1. This results in recv_fix_hierarchy() not being called\r\nwhich may render some children of the top fs not mountable since their\r\nencryption root was not updated. To circumvent this make\r\nrecv_incremental_replication() silently ignore this error.\r\n\r\n### How Has This Been Tested?\r\n<!--- Please describe in detail how you tested your changes. -->\r\n<!--- Include details of your testing environment, and the tests you ran to -->\r\n<!--- see how your change affects other areas of the code, etc. -->\r\n<!--- If your change is a performance enhancement, please provide benchmarks here. -->\r\n<!--- Please think about using the draft PR feature if appropriate -->\r\nAn existing test was expanded.\r\nPerfomance testing was done locally using the script from #16317 \r\n\r\n### Types of changes\r\n<!--- What types of changes does your code introduce? Put an `x` in all the boxes that apply: -->\r\n- [ ] Bug fix (non-breaking change which fixes an issue)\r\n- [ ] New feature (non-breaking change which adds functionality)\r\n- [x] Performance enhancement (non-breaking change which improves efficiency)\r\n- [ ] Code cleanup (non-breaking change which makes code smaller or more readable)\r\n- [ ] Breaking change (fix or feature that would cause existing functionality to change)\r\n- [ ] Library ABI change (libzfs, libzfs\\_core, libnvpair, libuutil and libzfsbootenv)\r\n- [ ] Documentation (a change to man pages or other documentation)\r\n\r\n### Checklist:\r\n<!--- Go over all the following points, and put an `x` in all the boxes that apply. -->\r\n<!--- If you're unsure about any of these, don't hesitate to ask. We're here to help! -->\r\n- [x] My code follows the OpenZFS [code style requirements](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md#coding-conventions).\r\n- [ ] I have updated the documentation accordingly.\r\n- [x] I have read the [**contributing** document](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md).\r\n- [x] I have added [tests](https://github.com/openzfs/zfs/tree/master/tests) to cover my changes.\r\n- [x] I have run the ZFS Test Suite with this change applied.\r\n- [x] All commit messages are properly formatted and contain [`Signed-off-by`](https://github.com/openzfs/zfs/blob/master/.github/CONTRIBUTING.md#signed-off-by).\r\n"
    },
    {
        "author": {
            "login": "behlendorf"
        },
        "body": "This looks right to me.  Thanks for running this down and implementing some more efficient logic for this."
    },
    {
        "author": {
            "login": "amotin"
        },
        "body": ""
    },
    {
        "author": {
            "login": "gamanakis"
        },
        "body": "[c63079c](https://github.com/openzfs/zfs/commit/c63079c0d58a552dda0097c3efe83dfec68c8531): rebased to master\r\n[a55562a](https://github.com/openzfs/zfs/commit/a55562a4a3800f3b07c1b19aeb8e85e63a50eda1): rebased to master"
    },
    {
        "author": {
            "login": "gamanakis"
        },
        "body": "Just converted this to a draft again. The original test was broken, in the sense that it is not checking the properties on the receiving pool, but rather in the source.\r\n\r\nThe problem is that even in its current form (ie before this PR) the corrected test fails: recv_fix_encryption() fails to change the encryption root of `test/fs/child` after the second recv, resulting in an unmountable fs as we have already changed its key.\r\n\r\nEDIT:\r\nThis happens because `recv_incremental_replication()` detects we have the wrong origin (in case we had promoted earlier a clone) and terminates with softerr=1, which leads to `recv_fix_encryption_hierarchy()` being skipped. \r\n\r\nNow all this happens only when we send a fs but have previously **promoted a top clone outside of the top fs used in zfs send**:\r\n```\r\nzpool export -a\r\nzpool create test /root/A.vdev -f\r\nzpool create testB /root/B.vdev -f\r\n\r\necho asdfgasdfg | zfs create -o encryption=on -o keyformat=passphrase test/fs\r\nzfs snap -r test/fs@snap\r\nzfs clone test/fs@snap test/clone\r\nzfs create test/fs/child\r\n\r\nzfs snap -r test/fs@before\r\nzfs send -Rw test/fs@before | zfs recv -dF testB\r\n\r\necho \"****** 1st SEND Completed ******\"\r\necho qwertqwert | zfs change-key -o keyformat=passphrase test/fs/child\r\necho \"****** Changed Key on Child ******\"\r\nzfs promote test/clone ########### Here we are promoting outside of the top fs ##########\r\nzfs snap -r test/fs@after\r\nzfs send -Rwi test/fs@before test/fs@after | zfs recv -vdF testB\r\n\r\nzfs get encryptionroot test/fs/child\r\nzfs get encryptionroot testB/fs/child\r\n```\r\n\r\nAddress this by ignoring the error, allowing `recv_fix_encryption_hierarchy()` to run."
    },
    {
        "data": {
            "repository": {
                "issue": {
                    "title": "recv_fix_encryption_hierarchy does horrifically inefficient lookups that could be either cached or refactored, and it bottlenecks super badly",
                    "body": "### System information\r\n<!--  add version after \"|\" character -->\r\nType | Version/Name\r\n --- | ---\r\nDistribution Name\t| Debian\r\nDistribution Version\t| Debian 12 Bookworm\r\nKernel Version\t| `6.7.12+bpo-cloud-amd64` (also `6.7.12+bpo-amd64`)\r\nArchitecture\t| amd64\r\nOpenZFS Version\t| `2.2.4-1~bpo12+1` (also `2.2.3-2~bpo12+1`)\r\n\r\n### Describe the problem you're observing\r\nWhen doing a zfs send/recv with encryption and replication, zfs send completes after about 15 minutes, but zfs send then spends another 825 minutes using 100% of 1 CPU core.\r\n\r\nIn my test recipe, \"zfs send\" takes 20 seconds and generates an 18MB blob, and \"zfs receive\" takes 2580 seconds.\r\n\r\nThe issue appears to be proportional to the number of datasets.\r\nOn a system with ~100 datasets, it is not noticeable.\r\nI asked `#openzfs` (IRC) for help with this, and someone there worked out which function was causing the problem (the issue title is what they suggested).\r\n\r\n### Describe how to reproduce the problem\r\n\r\nHere is a minimal recipe that demonstrates the time difference.\r\n\r\n```sh\r\n#!/bin/sh -vex                                                                                                                                                                                                       \r\n\r\n# PROBLEM: when I do \"zfs send | ssh backup-server zfs recv\",                                                                                                                                                        \r\n#          I see that \"zfs send\" finishes after about 15 minutes, but                                                                                                                                                \r\n#          \"zfs recv\" on the remote host consumes 100% of one CPU core for 10 HOURS.                                                                                                                                 \r\n#          It does eventually exit.                                                                                                                                                                                  \r\n#                                                                                                                                                                                                                    \r\n#          The delay appears to be proportional to the number of datasets in the pool, so                                                                                                                            \r\n#          on a system with 10 users, I didn't notice the problem, but                                                                                                                                               \r\n#          on a system with 1000 users, I noticed right away!                                                                                                                                                        \r\n#          (On both systems, there are separate datasets for each user's $HOME and $MAIL.)                                                                                                                           \r\n#                                                                                                                                                                                                                    \r\n# 05:01 <PMT> it's pretty simple, just, \"recv_fix_encryption_hierarchy does horrifically inefficient lookups that could be either cached or refactored, and it bottlenecks super badly\"                              \r\n\r\n# Report what we're running.                                                                                                                                                                                         \r\nzfs --version\r\nuname -a\r\n\r\n# First clean up anything from a previous attempt.                                                                                                                                                                   \r\nzpool export A || :\r\nrm -f /A.vdev\r\n\r\n# Make a new pool with 1000 datasets in it.                                                                                                                                                                          \r\ntruncate -s1T /A.vdev\r\nzpool create -O canmount=off -O mountpoint=none A /A.vdev\r\npython3 -c 'print(open(\"/dev/urandom\", \"rb\").read(32).hex(),file=open(\"/A.passphrase\", \"w\"))'\r\nzfs create -v -o encryption=on -o keyformat=hex -o keylocation=file:///A.passphrase A/A\r\nseq 100 999 >/A.txt\r\ntime xargs --arg-file=/A.txt -I N zfs create -v A/A/N\r\n\r\n# Make a snapshot and then send it to ourselves.                                                                                                                                                                     \r\n# Normally this would be a pipeline \"zfs send \u22ef A/A@1 | ssh B zfs recv \u22ef B/A\", but                                                                                                                                   \r\n# use a temporary file so we can clearly see how long each step takes.                                                                                                                                               \r\nzfs snapshot -r A/A@1\r\n>/A-A@1.zfs-send time zfs send --large-block --embed --compressed --raw --replicate A/A@1\r\n</A-A@1.zfs-send time zfs receive -v -o readonly=on -o canmount=noauto A/B\r\n\r\n# This happens with incrementals also.                                                                                                                                                                               \r\nzfs snapshot -r A/A@2\r\n>/A-A@1..2.zfs-send time zfs send --large-block --embed --compressed --raw --replicate -I 1 A/A@2\r\n</A-A@1..2.zfs-send time zfs receive -v -o readonly=on -o canmount=noauto -F A/B\r\n```\r\n\r\nThe output is: \r\n[zfs.recv_fix_encryption_hierarchy.txt](https://github.com/user-attachments/files/16048754/zfs.recv_fix_encryption_hierarchy.txt)\r\n\r\n\r\n### Include any warning/errors/backtraces from the system logs\r\n<!--\r\n*IMPORTANT* - Please mark logs and text output from terminal commands\r\nor else Github will not display them correctly.\r\nAn example is provided below.\r\n\r\nExample:\r\n```\r\nthis is an example how log text should be marked (wrap it with ```)\r\n```\r\n-->\r\n\r\nNo errors --- the `zfs receive` process *does* eventually terminate, it's just very very slow.",
                    "state": "CLOSED",
                    "comments": {
                        "nodes": [
                            {
                                "author": {
                                    "login": "rincebrain"
                                },
                                "body": "tl;dr I'm pretty sure just adding a caching layer for lookups in `recv_fix_encryption_hierarchy` would make this take O(free), since it basically spends forever ioctling on zfs list/get iteration, when the equivalent of just doing an enormous \"get\" or \"list\" once and using that data should suffice. (You'd have racing issues, in some sense, perhaps, but since you're not preventing people changing anything in the receive hierarchy or around it under you anyway, that's still true either way, I think...)\r\n\r\n(In slightly more words - if I follow the code correctly, that function basically does \"for dataset in datasets, if encrypted, go walk up and down each direction trying to find the 'closest' 'parent' for the encryptionroot\", and since each of those checks is an ioctl, if you start nesting nontrivial numbers of datasets at each layer, you get sad.)"
                            },
                            {
                                "author": {
                                    "login": "gamanakis"
                                },
                                "body": "I was hitting this lately and decided to give it a go. Thank you @rincebrain and @trentbuck for reporting and digging into it. I just marked #16929 as ready for review. Would you mind taking a look at it?\r\n"
                            }
                        ]
                    }
                }
            }
        }
    }
]