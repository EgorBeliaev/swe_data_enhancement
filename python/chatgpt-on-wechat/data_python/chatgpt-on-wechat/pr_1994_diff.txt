diff --git a/channel/chat_channel.py b/channel/chat_channel.py
index b3f8d1aea..6e2a45cc3 100644
--- a/channel/chat_channel.py
+++ b/channel/chat_channel.py
@@ -86,14 +86,14 @@ def _compose_context(self, ctype: ContextType, content, **kwargs):
             if e_context.is_pass() or context is None:
                 return context
             if cmsg.from_user_id == self.user_id and not config.get("trigger_by_self", True):
-                logger.debug("[WX]self message skipped")
+                logger.debug("[chat_channel]self message skipped")
                 return None
 
         # æ¶ˆæ¯å†…å®¹åŒ¹é…è¿‡ç¨‹ï¼Œå¹¶å¤„ç†content
         if ctype == ContextType.TEXT:
             if first_in and "ã€\n- - - - - - -" in content:  # åˆæ¬¡åŒ¹é… è¿‡æ»¤å¼•ç”¨æ¶ˆæ¯
                 logger.debug(content)
-                logger.debug("[WX]reference query skipped")
+                logger.debug("[chat_channel]reference query skipped")
                 return None
 
             nick_name_black_list = conf().get("nick_name_black_list", [])
@@ -111,10 +111,10 @@ def _compose_context(self, ctype: ContextType, content, **kwargs):
                         nick_name = context["msg"].actual_user_nickname
                         if nick_name and nick_name in nick_name_black_list:
                             # é»‘åå•è¿‡æ»¤
-                            logger.warning(f"[WX] Nickname {nick_name} in In BlackList, ignore")
+                            logger.warning(f"[chat_channel] Nickname {nick_name} in In BlackList, ignore")
                             return None
 
-                        logger.info("[WX]receive group at")
+                        logger.info("[chat_channel]receive group at")
                         if not conf().get("group_at_off", False):
                             flag = True
                         pattern = f"@{re.escape(self.name)}(\u2005|\u0020)"
@@ -130,13 +130,13 @@ def _compose_context(self, ctype: ContextType, content, **kwargs):
                         content = subtract_res
                 if not flag:
                     if context["origin_ctype"] == ContextType.VOICE:
-                        logger.info("[WX]receive group voice, but checkprefix didn't match")
+                        logger.info("[chat_channel]receive group voice, but checkprefix didn't match")
                     return None
             else:  # å•èŠ
                 nick_name = context["msg"].from_user_nickname
                 if nick_name and nick_name in nick_name_black_list:
                     # é»‘åå•è¿‡æ»¤
-                    logger.warning(f"[WX] Nickname '{nick_name}' in In BlackList, ignore")
+                    logger.warning(f"[chat_channel] Nickname '{nick_name}' in In BlackList, ignore")
                     return None
 
                 match_prefix = check_prefix(content, conf().get("single_chat_prefix", [""]))
@@ -147,7 +147,7 @@ def _compose_context(self, ctype: ContextType, content, **kwargs):
                 else:
                     return None
             content = content.strip()
-            img_match_prefix = check_prefix(content, conf().get("image_create_prefix"))
+            img_match_prefix = check_prefix(content, conf().get("image_create_prefix",[""]))
             if img_match_prefix:
                 content = content.replace(img_match_prefix, "", 1)
                 context.type = ContextType.IMAGE_CREATE
@@ -159,17 +159,16 @@ def _compose_context(self, ctype: ContextType, content, **kwargs):
         elif context.type == ContextType.VOICE:
             if "desire_rtype" not in context and conf().get("voice_reply_voice") and ReplyType.VOICE not in self.NOT_SUPPORT_REPLYTYPE:
                 context["desire_rtype"] = ReplyType.VOICE
-
         return context
 
     def _handle(self, context: Context):
         if context is None or not context.content:
             return
-        logger.debug("[WX] ready to handle context: {}".format(context))
+        logger.debug("[chat_channel] ready to handle context: {}".format(context))
         # replyçš„æ„å»ºæ­¥éª¤
         reply = self._generate_reply(context)
 
-        logger.debug("[WX] ready to decorate reply: {}".format(reply))
+        logger.debug("[chat_channel] ready to decorate reply: {}".format(reply))
 
         # replyçš„åŒ…è£…æ­¥éª¤
         if reply and reply.content:
@@ -187,7 +186,7 @@ def _generate_reply(self, context: Context, reply: Reply = Reply()) -> Reply:
         )
         reply = e_context["reply"]
         if not e_context.is_pass():
-            logger.debug("[WX] ready to handle context: type={}, content={}".format(context.type, context.content))
+            logger.debug("[chat_channel] ready to handle context: type={}, content={}".format(context.type, context.content))
             if context.type == ContextType.TEXT or context.type == ContextType.IMAGE_CREATE:  # æ–‡å­—å’Œå›¾ç‰‡æ¶ˆæ¯
                 context["channel"] = e_context["channel"]
                 reply = super().build_reply_content(context.content, context)
@@ -199,7 +198,7 @@ def _generate_reply(self, context: Context, reply: Reply = Reply()) -> Reply:
                 try:
                     any_to_wav(file_path, wav_path)
                 except Exception as e:  # è½¬æ¢å¤±è´¥ï¼Œç›´æ¥ä½¿ç”¨mp3ï¼Œå¯¹äºæŸäº›apiï¼Œmp3ä¹Ÿå¯ä»¥è¯†åˆ«
-                    logger.warning("[WX]any to wav error, use raw path. " + str(e))
+                    logger.warning("[chat_channel]any to wav error, use raw path. " + str(e))
                     wav_path = file_path
                 # è¯­éŸ³è¯†åˆ«
                 reply = super().build_voice_to_text(wav_path)
@@ -210,7 +209,7 @@ def _generate_reply(self, context: Context, reply: Reply = Reply()) -> Reply:
                         os.remove(wav_path)
                 except Exception as e:
                     pass
-                    # logger.warning("[WX]delete temp file error: " + str(e))
+                    # logger.warning("[chat_channel]delete temp file error: " + str(e))
 
                 if reply.type == ReplyType.TEXT:
                     new_context = self._compose_context(ContextType.TEXT, reply.content, **context.kwargs)
@@ -228,7 +227,7 @@ def _generate_reply(self, context: Context, reply: Reply = Reply()) -> Reply:
             elif context.type == ContextType.FUNCTION or context.type == ContextType.FILE:  # æ–‡ä»¶æ¶ˆæ¯åŠå‡½æ•°è°ƒç”¨ç­‰ï¼Œå½“å‰æ— é»˜è®¤é€»è¾‘
                 pass
             else:
-                logger.warning("[WX] unknown context type: {}".format(context.type))
+                logger.warning("[chat_channel] unknown context type: {}".format(context.type))
                 return
         return reply
 
@@ -244,7 +243,7 @@ def _decorate_reply(self, context: Context, reply: Reply) -> Reply:
             desire_rtype = context.get("desire_rtype")
             if not e_context.is_pass() and reply and reply.type:
                 if reply.type in self.NOT_SUPPORT_REPLYTYPE:
-                    logger.error("[WX]reply type not support: " + str(reply.type))
+                    logger.error("[chat_channel]reply type not support: " + str(reply.type))
                     reply.type = ReplyType.ERROR
                     reply.content = "ä¸æ”¯æŒå‘é€çš„æ¶ˆæ¯ç±»å‹: " + str(reply.type)
 
@@ -265,10 +264,10 @@ def _decorate_reply(self, context: Context, reply: Reply) -> Reply:
                 elif reply.type == ReplyType.IMAGE_URL or reply.type == ReplyType.VOICE or reply.type == ReplyType.IMAGE or reply.type == ReplyType.FILE or reply.type == ReplyType.VIDEO or reply.type == ReplyType.VIDEO_URL:
                     pass
                 else:
-                    logger.error("[WX] unknown reply type: {}".format(reply.type))
+                    logger.error("[chat_channel] unknown reply type: {}".format(reply.type))
                     return
             if desire_rtype and desire_rtype != reply.type and reply.type not in [ReplyType.ERROR, ReplyType.INFO]:
-                logger.warning("[WX] desire_rtype: {}, but reply type: {}".format(context.get("desire_rtype"), reply.type))
+                logger.warning("[chat_channel] desire_rtype: {}, but reply type: {}".format(context.get("desire_rtype"), reply.type))
             return reply
 
     def _send_reply(self, context: Context, reply: Reply):
@@ -281,14 +280,14 @@ def _send_reply(self, context: Context, reply: Reply):
             )
             reply = e_context["reply"]
             if not e_context.is_pass() and reply and reply.type:
-                logger.debug("[WX] ready to send reply: {}, context: {}".format(reply, context))
+                logger.debug("[chat_channel] ready to send reply: {}, context: {}".format(reply, context))
                 self._send(reply, context)
 
     def _send(self, reply: Reply, context: Context, retry_cnt=0):
         try:
             self.send(reply, context)
         except Exception as e:
-            logger.error("[WX] sendMsg error: {}".format(str(e)))
+            logger.error("[chat_channel] sendMsg error: {}".format(str(e)))
             if isinstance(e, NotImplementedError):
                 return
             logger.exception(e)
@@ -342,7 +341,7 @@ def consume(self):
                     if semaphore.acquire(blocking=False):  # ç­‰çº¿ç¨‹å¤„ç†å®Œæ¯•æ‰èƒ½åˆ é™¤
                         if not context_queue.empty():
                             context = context_queue.get()
-                            logger.debug("[WX] consume context: {}".format(context))
+                            logger.debug("[chat_channel] consume context: {}".format(context))
                             future: Future = handler_pool.submit(self._handle, context)
                             future.add_done_callback(self._thread_pool_callback(session_id, context=context))
                             if session_id not in self.futures:
diff --git a/channel/dingtalk/dingtalk_channel.py b/channel/dingtalk/dingtalk_channel.py
index 22ef889bb..33e73d8ad 100644
--- a/channel/dingtalk/dingtalk_channel.py
+++ b/channel/dingtalk/dingtalk_channel.py
@@ -4,20 +4,81 @@
 @author huiwen
 @Date 2023/11/28
 """
-
+import copy
+import json
 # -*- coding=utf-8 -*-
+import logging
+import time
+
+import dingtalk_stream
+from dingtalk_stream import AckMessage
+from dingtalk_stream.card_replier import AICardReplier
+from dingtalk_stream.card_replier import AICardStatus
+from dingtalk_stream.card_replier import CardReplier
+
+from bridge.context import Context, ContextType
+from bridge.reply import Reply, ReplyType
+from channel.chat_channel import ChatChannel
 from channel.dingtalk.dingtalk_message import DingTalkMessage
-from bridge.context import Context
-from bridge.reply import Reply
+from common.expired_dict import ExpiredDict
 from common.log import logger
 from common.singleton import singleton
+from common.time_check import time_checker
 from config import conf
-from common.expired_dict import ExpiredDict
-from bridge.context import ContextType
-from channel.chat_channel import ChatChannel
-import logging
-from dingtalk_stream import AckMessage
-import dingtalk_stream
+
+
+class CustomAICardReplier(CardReplier):
+    def __init__(self, dingtalk_client, incoming_message):
+        super(AICardReplier, self).__init__(dingtalk_client, incoming_message)
+
+    def start(
+            self,
+            card_template_id: str,
+            card_data: dict,
+            recipients: list = None,
+            support_forward: bool = True,
+    ) -> str:
+        """
+        AIå¡ç‰‡çš„åˆ›å»ºæ¥å£
+        :param support_forward:
+        :param recipients:
+        :param card_template_id:
+        :param card_data:
+        :return:
+        """
+        card_data_with_status = copy.deepcopy(card_data)
+        card_data_with_status["flowStatus"] = AICardStatus.PROCESSING
+        return self.create_and_send_card(
+            card_template_id,
+            card_data_with_status,
+            at_sender=True,
+            at_all=False,
+            recipients=recipients,
+            support_forward=support_forward,
+        )
+
+
+# å¯¹ AICardReplier è¿›è¡ŒçŒ´å­è¡¥ä¸
+AICardReplier.start = CustomAICardReplier.start
+
+
+def _check(func):
+    def wrapper(self, cmsg: DingTalkMessage):
+        msgId = cmsg.msg_id
+        if msgId in self.receivedMsgs:
+            logger.info("DingTalk message {} already received, ignore".format(msgId))
+            return
+        self.receivedMsgs[msgId] = True
+        create_time = cmsg.create_time  # æ¶ˆæ¯æ—¶é—´æˆ³
+        if conf().get("hot_reload") == True and int(create_time) < int(time.time()) - 60:  # è·³è¿‡1åˆ†é’Ÿå‰çš„å†å²æ¶ˆæ¯
+            logger.debug("[DingTalk] History message {} skipped".format(msgId))
+            return
+        if cmsg.my_msg and not cmsg.is_group:
+            logger.debug("[DingTalk] My message {} skipped".format(msgId))
+            return
+        return func(self, cmsg)
+
+    return wrapper
 
 
 @singleton
@@ -39,11 +100,13 @@ def __init__(self):
         super(dingtalk_stream.ChatbotHandler, self).__init__()
         self.logger = self.setup_logger()
         # å†å²æ¶ˆæ¯idæš‚å­˜ï¼Œç”¨äºå¹‚ç­‰æ§åˆ¶
-        self.receivedMsgs = ExpiredDict(60 * 60 * 7.1)
-        logger.info("[dingtalk] client_id={}, client_secret={} ".format(
+        self.receivedMsgs = ExpiredDict(conf().get("expires_in_seconds"))
+        logger.info("[DingTalk] client_id={}, client_secret={} ".format(
             self.dingtalk_client_id, self.dingtalk_client_secret))
         # æ— éœ€ç¾¤æ ¡éªŒå’Œå‰ç¼€
         conf()["group_name_white_list"] = ["ALL_GROUP"]
+        # å•èŠæ— éœ€å‰ç¼€
+        conf()["single_chat_prefix"] = [""]
 
     def startup(self):
         credential = dingtalk_stream.Credential(self.dingtalk_client_id, self.dingtalk_client_secret)
@@ -51,50 +114,107 @@ def startup(self):
         client.register_callback_handler(dingtalk_stream.chatbot.ChatbotMessage.TOPIC, self)
         client.start_forever()
 
+    async def process(self, callback: dingtalk_stream.CallbackMessage):
+        try:
+            incoming_message = dingtalk_stream.ChatbotMessage.from_dict(callback.data)
+            image_download_handler = self  # ä¼ å…¥æ–¹æ³•æ‰€åœ¨çš„ç±»å®ä¾‹
+            dingtalk_msg = DingTalkMessage(incoming_message, image_download_handler)
+
+            if dingtalk_msg.is_group:
+                self.handle_group(dingtalk_msg)
+            else:
+                self.handle_single(dingtalk_msg)
+            return AckMessage.STATUS_OK, 'OK'
+        except Exception as e:
+            logger.error(f"dingtalk process error={e}")
+            return AckMessage.STATUS_SYSTEM_EXCEPTION, 'ERROR'
+
+    @time_checker
+    @_check
     def handle_single(self, cmsg: DingTalkMessage):
         # å¤„ç†å•èŠæ¶ˆæ¯
         if cmsg.ctype == ContextType.VOICE:
-            logger.debug("[dingtalk]receive voice msg: {}".format(cmsg.content))
+            logger.debug("[DingTalk]receive voice msg: {}".format(cmsg.content))
         elif cmsg.ctype == ContextType.IMAGE:
-            logger.debug("[dingtalk]receive image msg: {}".format(cmsg.content))
+            logger.debug("[DingTalk]receive image msg: {}".format(cmsg.content))
+        elif cmsg.ctype == ContextType.IMAGE_CREATE:
+            logger.debug("[DingTalk]receive image create msg: {}".format(cmsg.content))
         elif cmsg.ctype == ContextType.PATPAT:
-            logger.debug("[dingtalk]receive patpat msg: {}".format(cmsg.content))
+            logger.debug("[DingTalk]receive patpat msg: {}".format(cmsg.content))
         elif cmsg.ctype == ContextType.TEXT:
-            expression = cmsg.my_msg
-        cmsg.content = conf()["single_chat_prefix"][0] + cmsg.content
+            logger.debug("[DingTalk]receive text msg: {}".format(cmsg.content))
+        else:
+            logger.debug("[DingTalk]receive other msg: {}".format(cmsg.content))
         context = self._compose_context(cmsg.ctype, cmsg.content, isgroup=False, msg=cmsg)
         if context:
             self.produce(context)
 
+
+    @time_checker
+    @_check
     def handle_group(self, cmsg: DingTalkMessage):
         # å¤„ç†ç¾¤èŠæ¶ˆæ¯
         if cmsg.ctype == ContextType.VOICE:
-            logger.debug("[dingtalk]receive voice msg: {}".format(cmsg.content))
+            logger.debug("[DingTalk]receive voice msg: {}".format(cmsg.content))
         elif cmsg.ctype == ContextType.IMAGE:
-            logger.debug("[dingtalk]receive image msg: {}".format(cmsg.content))
+            logger.debug("[DingTalk]receive image msg: {}".format(cmsg.content))
+        elif cmsg.ctype == ContextType.IMAGE_CREATE:
+            logger.debug("[DingTalk]receive image create msg: {}".format(cmsg.content))
         elif cmsg.ctype == ContextType.PATPAT:
-            logger.debug("[dingtalk]receive patpat msg: {}".format(cmsg.content))
+            logger.debug("[DingTalk]receive patpat msg: {}".format(cmsg.content))
         elif cmsg.ctype == ContextType.TEXT:
-            expression = cmsg.my_msg
-        cmsg.content = conf()["group_chat_prefix"][0] + cmsg.content
+            logger.debug("[DingTalk]receive patpat msg: {}".format(cmsg.content))
+        else:
+            logger.debug("[DingTalk]receive other msg: {}".format(cmsg.content))
         context = self._compose_context(cmsg.ctype, cmsg.content, isgroup=True, msg=cmsg)
         context['no_need_at'] = True
         if context:
             self.produce(context)
 
-    async def process(self, callback: dingtalk_stream.CallbackMessage):
-        try:
-            incoming_message = dingtalk_stream.ChatbotMessage.from_dict(callback.data)
-            dingtalk_msg = DingTalkMessage(incoming_message)
-            if incoming_message.conversation_type == '1':
-                self.handle_single(dingtalk_msg)
-            else:
-                self.handle_group(dingtalk_msg)
-            return AckMessage.STATUS_OK, 'OK'
-        except Exception as e:
-            logger.error(e)
-            return self.FAILED_MSG
 
     def send(self, reply: Reply, context: Context):
+        receiver = context["receiver"]
+        isgroup = context.kwargs['msg'].is_group
         incoming_message = context.kwargs['msg'].incoming_message
-        self.reply_text(reply.content, incoming_message)
+        logger.info("[Dingtalk] sendMsg={}, receiver={}".format(reply, receiver))
+        def reply_with_text():
+            self.reply_text(reply.content, incoming_message)
+        def reply_with_at_text():
+            self.reply_text("ğŸ“¢ æ‚¨æœ‰ä¸€æ¡æ–°çš„æ¶ˆæ¯ï¼Œè¯·æŸ¥çœ‹ã€‚", incoming_message)
+        def reply_with_ai_markdown():
+            button_list, markdown_content = self.generate_button_markdown_content(context, reply)
+            self.reply_ai_markdown_button(incoming_message, markdown_content, button_list, "", "ğŸ“Œ å†…å®¹ç”±AI-Botç”Ÿæˆ", "",[incoming_message.sender_staff_id])
+
+        if reply.type in [ReplyType.IMAGE_URL, ReplyType.IMAGE, ReplyType.TEXT]:
+            if isgroup:
+                reply_with_ai_markdown()
+                reply_with_at_text()
+            else:
+                reply_with_ai_markdown()
+        else:
+            # æš‚ä¸æ”¯æŒå…¶å®ƒç±»å‹æ¶ˆæ¯å›å¤
+            reply_with_text()
+
+    def generate_button_markdown_content(self, context, reply):
+        image_url = context.kwargs.get("image_url")
+        promptEn = context.kwargs.get("promptEn")
+        reply_text = reply.content
+        button_list = []
+        markdown_content = f"""
+{reply.content}
+                                """
+        if image_url is not None and promptEn is not None:
+            button_list = [
+                {"text": "æŸ¥çœ‹åŸå›¾", "url": image_url, "iosUrl": image_url, "color": "blue"}
+            ]
+            markdown_content = f"""
+{promptEn}
+
+!["å›¾ç‰‡"]({image_url})
+
+{reply_text}
+
+                                """
+        logger.debug(f"[Dingtalk] generate_button_markdown_content, button_list={button_list} , markdown_content={markdown_content}")
+
+        return button_list, markdown_content
diff --git a/channel/dingtalk/dingtalk_message.py b/channel/dingtalk/dingtalk_message.py
index 8a19cdca5..1bba85de0 100644
--- a/channel/dingtalk/dingtalk_message.py
+++ b/channel/dingtalk/dingtalk_message.py
@@ -1,44 +1,83 @@
+import os
+
+import requests
+from dingtalk_stream import ChatbotMessage
+
 from bridge.context import ContextType
 from channel.chat_message import ChatMessage
-import json
-import requests
+# -*- coding=utf-8 -*-
 from common.log import logger
 from common.tmp_dir import TmpDir
-from common import utils
-from dingtalk_stream import ChatbotMessage
+
 
 class DingTalkMessage(ChatMessage):
-    def __init__(self, event: ChatbotMessage):
+    def __init__(self, event: ChatbotMessage, image_download_handler):
         super().__init__(event)
-        
+        self.image_download_handler = image_download_handler
         self.msg_id = event.message_id
-        msg_type = event.message_type
-        self.incoming_message =event
+        self.message_type = event.message_type
+        self.incoming_message = event
         self.sender_staff_id = event.sender_staff_id
         self.other_user_id = event.conversation_id
         self.create_time = event.create_at
-        if event.conversation_type=="1":
+        self.image_content = event.image_content
+        self.rich_text_content = event.rich_text_content
+        if event.conversation_type == "1":
             self.is_group = False
         else:
             self.is_group = True
-        
 
-        if msg_type == "text":
+        if self.message_type == "text":
             self.ctype = ContextType.TEXT
-            
+
             self.content = event.text.content.strip()
-        elif msg_type == "audio":
-            
+        elif self.message_type == "audio":
             # é’‰é’‰æ”¯æŒç›´æ¥è¯†åˆ«è¯­éŸ³ï¼Œæ‰€ä»¥æ­¤å¤„å°†ç›´æ¥æå–æ–‡å­—ï¼Œå½“æ–‡å­—å¤„ç†
             self.content = event.extensions['content']['recognition'].strip()
             self.ctype = ContextType.TEXT
+        elif (self.message_type == 'picture') or (self.message_type == 'richText'):
+            self.ctype = ContextType.IMAGE
+            # é’‰é’‰å›¾ç‰‡ç±»å‹æˆ–å¯Œæ–‡æœ¬ç±»å‹æ¶ˆæ¯å¤„ç†
+            image_list = event.get_image_list()
+            if len(image_list) > 0:
+                download_code = image_list[0]
+                download_url = image_download_handler.get_image_download_url(download_code)
+                self.content = download_image_file(download_url, TmpDir().path())
+            else:
+                logger.debug(f"[Dingtalk] messageType :{self.message_type} , imageList isEmpty")
+
         if self.is_group:
             self.from_user_id = event.conversation_id
             self.actual_user_id = event.sender_id
         else:
             self.from_user_id = event.sender_id
+            self.actual_user_id = event.sender_id
         self.to_user_id = event.chatbot_user_id
         self.other_user_nickname = event.conversation_title
-        
-        user_id = event.sender_id
-        nickname =event.sender_nick
+
+
+def download_image_file(image_url, temp_dir):
+    headers = {
+        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/112.0.0.0 Safari/537.36'
+    }
+    # è®¾ç½®ä»£ç†
+    # self.proxies
+    # , proxies=self.proxies
+    response = requests.get(image_url, headers=headers, stream=True, timeout=60 * 5)
+    if response.status_code == 200:
+
+        # ç”Ÿæˆæ–‡ä»¶å
+        file_name = image_url.split("/")[-1].split("?")[0]
+
+        # æ£€æŸ¥ä¸´æ—¶ç›®å½•æ˜¯å¦å­˜åœ¨ï¼Œå¦‚æœä¸å­˜åœ¨åˆ™åˆ›å»º
+        if not os.path.exists(temp_dir):
+            os.makedirs(temp_dir)
+
+        # å°†æ–‡ä»¶ä¿å­˜åˆ°ä¸´æ—¶ç›®å½•
+        file_path = os.path.join(temp_dir, file_name)
+        with open(file_path, 'wb') as file:
+            file.write(response.content)
+        return file_path
+    else:
+        logger.info(f"[Dingtalk] Failed to download image file, {response.content}")
+        return None
diff --git a/channel/feishu/feishu_channel.py b/channel/feishu/feishu_channel.py
index 76fbbf1b6..37837d4e7 100644
--- a/channel/feishu/feishu_channel.py
+++ b/channel/feishu/feishu_channel.py
@@ -40,7 +40,7 @@ def __init__(self):
             self.feishu_app_id, self.feishu_app_secret, self.feishu_token))
         # æ— éœ€ç¾¤æ ¡éªŒå’Œå‰ç¼€
         conf()["group_name_white_list"] = ["ALL_GROUP"]
-        conf()["single_chat_prefix"] = []
+        conf()["single_chat_prefix"] = [""]
 
     def startup(self):
         urls = (
diff --git a/channel/wechat/wechat_channel.py b/channel/wechat/wechat_channel.py
index b681e1243..870b48784 100644
--- a/channel/wechat/wechat_channel.py
+++ b/channel/wechat/wechat_channel.py
@@ -109,7 +109,7 @@ class WechatChannel(ChatChannel):
 
     def __init__(self):
         super().__init__()
-        self.receivedMsgs = ExpiredDict(60 * 60)
+        self.receivedMsgs = ExpiredDict(conf().get("expires_in_seconds"))
         self.auto_login_times = 0
 
     def startup(self):
diff --git a/config.py b/config.py
index 7d07379b3..303ac5e63 100644
--- a/config.py
+++ b/config.py
@@ -144,7 +144,7 @@
     # chatgptæŒ‡ä»¤è‡ªå®šä¹‰è§¦å‘è¯
     "clear_memory_commands": ["#æ¸…é™¤è®°å¿†"],  # é‡ç½®ä¼šè¯æŒ‡ä»¤ï¼Œå¿…é¡»ä»¥#å¼€å¤´
     # channelé…ç½®
-    "channel_type": "wx",  # é€šé“ç±»å‹ï¼Œæ”¯æŒï¼š{wx,wxy,terminal,wechatmp,wechatmp_service,wechatcom_app}
+    "channel_type": "",  # é€šé“ç±»å‹ï¼Œæ”¯æŒï¼š{wx,wxy,terminal,wechatmp,wechatmp_service,wechatcom_app,dingtalk}
     "subscribe_msg": "",  # è®¢é˜…æ¶ˆæ¯, æ”¯æŒ: wechatmp, wechatmp_service, wechatcom_app
     "debug": False,  # æ˜¯å¦å¼€å¯debugæ¨¡å¼ï¼Œå¼€å¯åä¼šæ‰“å°æ›´å¤šæ—¥å¿—
     "appdata_dir": "",  # æ•°æ®ç›®å½•
diff --git a/plugins/source.json b/plugins/source.json
index b0a781110..44b402317 100644
--- a/plugins/source.json
+++ b/plugins/source.json
@@ -1,5 +1,9 @@
 {
   "repo": {
+    "midjourney": {
+      "url": "https://github.com/baojingyu/midjourney.git",
+      "desc": "åˆ©ç”¨midjourneyå®ç°aiç»˜å›¾çš„çš„æ’ä»¶"
+    },
     "sdwebui": {
       "url": "https://github.com/lanvent/plugin_sdwebui.git",
       "desc": "åˆ©ç”¨stable-diffusionç”»å›¾çš„æ’ä»¶"
