diff --git a/docs/docs/integrations/embedding-stores/coherence.md b/docs/docs/integrations/embedding-stores/coherence.md
new file mode 100644
index 00000000000..c9927ae5699
--- /dev/null
+++ b/docs/docs/integrations/embedding-stores/coherence.md
@@ -0,0 +1,58 @@
+---
+sidebar_position: 7
+---
+
+# Oracle Coherence
+
+<https://coherence.community/>
+
+## Maven Dependency
+
+```xml
+<dependency>
+    <groupId>dev.langchain4j</groupId>
+    <artifactId>langchain4j-coherence</artifactId>
+    <version>0.36.0</version>
+</dependency>
+```
+
+The `langchain4j-coherence` module has Coherence as a provided dependency as it works with various Coherence versions.
+Developers should include the relevant Coherence dependency, either Community Edition or Commercial version.
+Coherence CE has a groupId of `com.oracle.coherence.ce` and commercial versions have a groupId of `com.oracle.coherence`.
+
+For example, to use Community Edition (CE), add the Coherence BOM to the dependency management section then add Coherence as a dependency. Other Coherence modules can then be added to the project as required.
+
+```xml
+<dependencyManagement>
+    <dependencies>
+        <dependency>
+            <groupId>com.oracle.coherence.ce</groupId>
+            <artifactId>coherence-bom</artifactId>
+            <version>24.09</version>
+            <type>pom</type>
+            <scope>import</scope>
+        </dependency>
+    </dependencies>
+</dependencyManagement>
+
+<dependencies>
+    <dependency>
+        <groupId>dev.langchain4j</groupId>
+        <artifactId>langchain4j-coherence</artifactId>
+        <version>0.36.0</version>
+    </dependency>
+    <dependency>
+        <groupId>com.oracle.coherence.ce</groupId>
+        <artifactId>coherence</artifactId>
+    </dependency>
+</dependencies>
+```
+
+## APIs
+
+- `CoherenceEmbeddingStore`
+- `CoherenceChatMemoryStore`
+
+## Examples
+
+- [CoherenceEmbeddingStoreExample](https://github.com/langchain4j/langchain4j-examples/blob/main/oracle-coherence-example/src/main/java/CoherenceEmbeddingStoreExample.java)
diff --git a/docs/docs/integrations/embedding-stores/index.md b/docs/docs/integrations/embedding-stores/index.md
index d28d09260ee..8adbbbacda9 100644
--- a/docs/docs/integrations/embedding-stores/index.md
+++ b/docs/docs/integrations/embedding-stores/index.md
@@ -13,6 +13,7 @@ sidebar_position: 0
 | [Azure CosmosDB NoSQL](/integrations/embedding-stores/azure-cosmos-nosql)             | ✅                |                            |                     |
 | [Cassandra](/integrations/embedding-stores/cassandra)                                 | ✅                |                            |                     |
 | [Chroma](/integrations/embedding-stores/chroma)                                       | ✅                | ✅                          | ✅                   |
+| [Coherence](/integrations/embedding-stores/coherence)                          | ✅                | ✅                     | ✅                   |
 | [Couchbase](/integrations/embedding-stores/couchbase)                                 | ✅                |                            | ✅                   |
 | [Elasticsearch](/integrations/embedding-stores/elasticsearch)                         | ✅                | ✅                          | ✅                   |
 | [Infinispan](/integrations/embedding-stores/infinispan)                               | ✅                |                            |                     |
diff --git a/langchain4j-bom/pom.xml b/langchain4j-bom/pom.xml
index 36ff8580bf9..a49b693090e 100644
--- a/langchain4j-bom/pom.xml
+++ b/langchain4j-bom/pom.xml
@@ -215,6 +215,12 @@
                 <version>${project.version}</version>
             </dependency>
 
+            <dependency>
+                <groupId>dev.langchain4j</groupId>
+                <artifactId>langchain4j-coherence</artifactId>
+                <version>${project.version}</version>
+            </dependency>
+
             <dependency>
                 <groupId>dev.langchain4j</groupId>
                 <artifactId>langchain4j-couchbase</artifactId>
diff --git a/langchain4j-coherence/pom.xml b/langchain4j-coherence/pom.xml
new file mode 100644
index 00000000000..c6ee1d2a4a3
--- /dev/null
+++ b/langchain4j-coherence/pom.xml
@@ -0,0 +1,123 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>dev.langchain4j</groupId>
+        <artifactId>langchain4j-parent</artifactId>
+        <version>0.36.0-SNAPSHOT</version>
+        <relativePath>../langchain4j-parent/pom.xml</relativePath>
+    </parent>
+
+    <artifactId>langchain4j-coherence</artifactId>
+    <name>LangChain4j :: Integration :: Oracle Coherence</name>
+
+    <properties>
+        <coherence.version>24.09</coherence.version>
+        <coherence.groupId>com.oracle.coherence.ce</coherence.groupId>
+    </properties>
+
+    <dependencyManagement>
+        <dependencies>
+            <dependency>
+                <groupId>${coherence.groupId}</groupId>
+                <artifactId>coherence-bom</artifactId>
+                <version>${coherence.version}</version>
+                <type>pom</type>
+                <scope>import</scope>
+            </dependency>
+        </dependencies>
+    </dependencyManagement>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>dev.langchain4j</groupId>
+            <artifactId>langchain4j-core</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>${coherence.groupId}</groupId>
+            <artifactId>coherence</artifactId>
+            <scope>provided</scope>
+        </dependency>
+        <dependency>
+            <groupId>${coherence.groupId}</groupId>
+            <artifactId>coherence-hnsw</artifactId>
+            <scope>provided</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>dev.langchain4j</groupId>
+            <artifactId>langchain4j-core</artifactId>
+            <classifier>tests</classifier>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.awaitility</groupId>
+            <artifactId>awaitility</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-engine</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- junit-jupiter-params should be declared explicitly
+        to run parameterized tests inherited from EmbeddingStore*IT-->
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-params</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>dev.langchain4j</groupId>
+            <artifactId>langchain4j-embeddings-all-minilm-l6-v2-q</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>${coherence.groupId}</groupId>
+            <artifactId>coherence-bedrock-testing-support</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.tinylog</groupId>
+            <artifactId>tinylog-impl</artifactId>
+            <scope>test</scope>
+        </dependency>
+        <dependency>
+            <groupId>org.tinylog</groupId>
+            <artifactId>slf4j-tinylog</artifactId>
+            <scope>test</scope>
+        </dependency>
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.apache.maven.plugins</groupId>
+                <artifactId>maven-failsafe-plugin</artifactId>
+                <configuration>
+                    <systemProperties>
+                        <java.net.preferIPv4Stack>true</java.net.preferIPv4Stack>
+                    </systemProperties>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
diff --git a/langchain4j-coherence/src/main/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStore.java b/langchain4j-coherence/src/main/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStore.java
new file mode 100644
index 00000000000..21730102f78
--- /dev/null
+++ b/langchain4j-coherence/src/main/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStore.java
@@ -0,0 +1,465 @@
+package dev.langchain4j.store.embedding.coherence;
+
+import com.oracle.coherence.ai.DocumentChunk;
+import com.oracle.coherence.ai.Float32Vector;
+import com.oracle.coherence.ai.QueryResult;
+import com.oracle.coherence.ai.Vector;
+import com.oracle.coherence.ai.VectorIndexExtractor;
+
+import com.oracle.coherence.ai.search.SimilaritySearch;
+import com.oracle.coherence.common.base.Logger;
+
+import com.tangosol.internal.util.processor.CacheProcessors;
+import com.tangosol.net.Coherence;
+import com.tangosol.net.NamedMap;
+import com.tangosol.net.Session;
+
+import com.tangosol.util.Filter;
+import com.tangosol.util.UUID;
+
+import com.tangosol.util.ValueExtractor;
+import dev.langchain4j.data.document.Metadata;
+
+import dev.langchain4j.data.embedding.Embedding;
+
+import dev.langchain4j.data.segment.TextSegment;
+
+import dev.langchain4j.store.embedding.EmbeddingMatch;
+import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
+import dev.langchain4j.store.embedding.EmbeddingSearchResult;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.RelevanceScore;
+
+import java.io.Serializable;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Objects;
+
+import java.util.function.ToDoubleFunction;
+
+import java.util.stream.Collectors;
+
+import static dev.langchain4j.internal.Utils.isNullOrEmpty;
+import static dev.langchain4j.internal.ValidationUtils.ensureTrue;
+
+/**
+ * An {@link EmbeddingStore} backed by an Oracle Coherence {@link NamedMap}.
+ */
+public class CoherenceEmbeddingStore
+        implements EmbeddingStore<TextSegment> {
+    /**
+     * The {@link ValueExtractor} to extract the float vector from a {@link DocumentChunk}.
+     */
+    private static final ValueExtractor<DocumentChunk, Vector<float[]>> EXTRACTOR = ValueExtractor.of(DocumentChunk::vector);
+    
+    /**
+     * The default {@link NamedMap} name.
+     */
+    public static final String DEFAULT_MAP_NAME = "documentChunks";
+
+    /**
+     * The {@link NamedMap} used to store the {@link DocumentChunk document chunks}.
+     */
+    protected final NamedMap<DocumentChunk.Id, DocumentChunk> documentChunks;
+
+    protected final boolean normalizeEmbeddings;
+
+    /**
+     * Create an {@link CoherenceEmbeddingStore}.
+     * <p>
+     * This method is protected, instances of {@link CoherenceEmbeddingStore}
+     * are created using the builder.
+     *
+     * @param namedMap             the {@link NamedMap} to contain the {@link DocumentChunk document chunks}
+     * @param normalizeEmbeddings  {@code true} if this {@link CoherenceEmbeddingStore} should call
+     *                             {@link Embedding#normalize()} on embeddings when adding or searching
+     */
+    protected CoherenceEmbeddingStore(NamedMap<DocumentChunk.Id, DocumentChunk> namedMap, boolean normalizeEmbeddings) {
+        this.documentChunks = namedMap;
+        this.normalizeEmbeddings = normalizeEmbeddings;
+    }
+
+    @Override
+    public String add(Embedding embedding) {
+        DocumentChunk.Id id = DocumentChunk.id(new UUID().toString(), 0);
+        addInternal(id, embedding, null);
+        return id.toString();
+    }
+
+    @Override
+    public void add(String id, Embedding embedding) {
+        addInternal(DocumentChunk.Id.parse(id), embedding, null);
+    }
+
+    @Override
+    public String add(Embedding embedding, TextSegment segment) {
+        DocumentChunk.Id id = DocumentChunk.id(new UUID().toString(), 0);
+        addInternal(id, embedding, segment);
+        return id.toString();
+    }
+
+    @Override
+    public List<String> addAll(List<Embedding> embeddings) {
+        return addAll(embeddings, null);
+    }
+
+    @Override
+    public List<String> addAll(List<Embedding> embeddings, List<TextSegment> embedded) {
+        List<DocumentChunk.Id> keys = generateKeys(embeddings.size());
+        addAllInternal(keys, embeddings, embedded);
+        return keys.stream().map(DocumentChunk.Id::toString).collect(Collectors.toList());
+    }
+
+    @Override
+    public void remove(String id) {
+        if (id == null || id.isBlank()) {
+            throw new IllegalArgumentException("id cannot be null or blank");
+        }
+
+        documentChunks.remove(DocumentChunk.Id.parse(id));
+    }
+
+    @Override
+    public void removeAll(Collection<String> ids) {
+        if (ids == null || ids.isEmpty()) {
+            throw new IllegalArgumentException("ids cannot be null or empty");
+        }
+
+        documentChunks.keySet().removeAll(ids.stream().map(DocumentChunk.Id::parse).collect(Collectors.toSet()));
+    }
+
+    @Override
+    public void removeAll(dev.langchain4j.store.embedding.filter.Filter filter) {
+        if (filter == null) {
+            throw new IllegalArgumentException("filter cannot be null");
+        }
+        
+        Filter<DocumentChunk> chunkFilter = CoherenceMetadataFilterMapper.map(filter);
+        documentChunks.invokeAll(chunkFilter, CacheProcessors.removeBlind());
+    }
+
+    @Override
+    public void removeAll() {
+        documentChunks.truncate();
+    }
+
+    @Override
+    public EmbeddingSearchResult<TextSegment> search(EmbeddingSearchRequest request) {
+        Embedding queryEmbedding = request.queryEmbedding();
+        if (normalizeEmbeddings) {
+            queryEmbedding.normalize();
+        }
+        double minScore = request.minScore();
+        boolean checkMin = minScore != 0.0f;
+        Filter<DocumentChunk> filter = CoherenceMetadataFilterMapper.map(request.filter());
+        Float32Vector vector = new Float32Vector(queryEmbedding.vector());
+
+        SimilaritySearch<DocumentChunk.Id, DocumentChunk, float[]> aggregator = new SimilaritySearch<>(EXTRACTOR, vector, request.maxResults());
+        if (filter != null) {
+            aggregator = aggregator.filter(filter);
+        }
+            
+        List<QueryResult<DocumentChunk.Id, DocumentChunk>> results = documentChunks.aggregate(aggregator);
+        List<EmbeddingMatch<TextSegment>> matches = new ArrayList<>();
+
+        for (QueryResult<DocumentChunk.Id, DocumentChunk> result : results) {
+            double score = RelevanceScore.fromCosineSimilarity(1.0f - result.getDistance());
+            if (checkMin && score < minScore) {
+                continue;
+            }
+
+            matches.add(embeddingMatch(score, result.getKey(), result.getValue()));
+        }
+
+        return new EmbeddingSearchResult<>(matches);
+    }
+
+    private void addInternal(DocumentChunk.Id id, Embedding embedding, TextSegment segment) {
+        Map<DocumentChunk.Id, DocumentChunk> map = new HashMap<>();
+        map.put(id, createChunk(embedding, segment));
+        documentChunks.putAll(map);
+    }
+
+    /**
+     * Add multiple {@link Embedding} instances to the repository.
+     *
+     * @param ids         the list of identifiers to use for each of the {@link Embedding}
+     * @param embeddings  the {@link Embedding} to add
+     * @param segments    an optional list of {@link TextSegment} to add with the embeddings
+     */
+    private void addAllInternal(List<DocumentChunk.Id> ids, List<Embedding> embeddings, List<TextSegment> segments) {
+        if (isNullOrEmpty(ids) || isNullOrEmpty(embeddings)) {
+            Logger.info("Skipped adding empty embeddings");
+            return;
+        }
+
+        boolean hasEmbedded = segments != null && !segments.isEmpty();
+
+        ensureTrue(ids.size() == embeddings.size(), "ids size is not equal to embeddings size");
+        if (hasEmbedded) {
+            ensureTrue(embeddings.size() == segments.size(), "embeddings size is not equal to embedded size");
+        }
+
+        Map<DocumentChunk.Id, DocumentChunk> map = new HashMap<>();
+        for (int i = 0; i < embeddings.size(); i++) {
+            Embedding embedding = embeddings.get(i);
+            TextSegment segment = hasEmbedded ? segments.get(i) : null;
+            map.put(ids.get(i), createChunk(embedding, segment));
+        }
+        documentChunks.putAll(map);
+    }
+
+    /**
+     * Convert a {@link QueryResult} into an {@link EmbeddingMatch}.
+     *
+     * @param score  the relevance score
+     * @param id     the chunk ID
+     * @param chunk  the matched chunk
+     *
+     * @return an {@link EmbeddingMatch} created from the {@link QueryResult}
+     */
+    private EmbeddingMatch<TextSegment> embeddingMatch(double score, DocumentChunk.Id id, DocumentChunk chunk) {
+        String key = id.toString();
+        String text = chunk.text();
+        TextSegment segment = text == null ? null : new TextSegment(chunk.text(), mapToMetadata(chunk.metadata()));
+        Vector<float[]> vector = chunk.vector();
+        Embedding embedding = vector == null ? null : new Embedding(vector.get());
+
+        return new EmbeddingMatch<>(score, key, embedding, segment);
+    }
+
+    /**
+     * Convert a {@code Map<String, Object>} of metadata attributes into a {@link Metadata} instance.
+     *
+     * @param mapMetadata  the map to convert
+     *
+     * @return a {@link Metadata} instance containing all non-null attributes from the specified Map
+     */
+    private static Metadata mapToMetadata(Map<String, Object> mapMetadata) {
+        mapMetadata.entrySet().removeIf(entry -> entry.getValue() == null);
+        return Metadata.from(mapMetadata);
+    }
+
+    /**
+     * Create a {@link DocumentChunk} from an {@link Embedding} and
+     * optional {@link TextSegment}.
+     *
+     * @param embedding  the {@link Embedding}
+     * @param segment    the optional {@link TextSegment}
+     *
+     * @return a {@link DocumentChunk}
+     */
+    private DocumentChunk createChunk(Embedding embedding, TextSegment segment) {
+        String text = segment == null ? null : segment.text();
+        Map<String, Object> metadata = segment == null ? Collections.emptyMap() : segment.metadata().toMap();
+        DocumentChunk chunk = new DocumentChunk(text, metadata);
+        if (normalizeEmbeddings) {
+            embedding.normalize();
+        }
+        Float32Vector vector = new Float32Vector(embedding.vector());
+        chunk.setVector(vector);
+        return chunk;
+    }
+
+    /**
+     * Generate a number of {@link DocumentChunk.Id} instances.
+     *
+     * @param size  the number of {@link DocumentChunk.Id} instances to create
+     *
+     * @return a list of {@link DocumentChunk.Id} instances
+     */
+    private List<DocumentChunk.Id> generateKeys(int size) {
+        List<DocumentChunk.Id> keys = new ArrayList<>(size);
+        for (int i = 0; i < size; i++) {
+            keys.add(new DocumentChunk.Id(new UUID().toString(), 0));
+        }
+        return keys;
+    }
+
+    /**
+     * Create a {@link Comparator} that sorts a double in reverse order.
+     *
+     * @param keyExtractor  the function to use to extract a double value
+     * @param <T>           the type of value the function extracts from
+     *
+     * @return the result of comparing two extracted doubles in reverse order
+     */
+    private static<T> Comparator<T> reverseComparingDouble(ToDoubleFunction<? super T> keyExtractor) {
+        Objects.requireNonNull(keyExtractor);
+        return (Comparator<T> & Serializable)
+            (c1, c2) -> Double.compare(keyExtractor.applyAsDouble(c2), keyExtractor.applyAsDouble(c1));
+    }
+
+    /**
+     * Create a default {@link CoherenceEmbeddingStore}.
+     *
+     * @return a default {@link CoherenceEmbeddingStore}
+     */
+    public static CoherenceEmbeddingStore create() {
+        return builder().build();
+    }
+
+    /**
+     * Create a {@link CoherenceEmbeddingStore} that uses the
+     * specified Coherence {@link NamedMap} name.
+     *
+     * @param name  the name of the Coherence {@link NamedMap} used to store documents
+     *
+     * @return a {@link CoherenceEmbeddingStore}
+     */
+    public static CoherenceEmbeddingStore create(String name) {
+        return builder().name(name).build();
+    }
+
+    /**
+     * Create a {@link CoherenceEmbeddingStore} that uses the
+     * specified Coherence {@link NamedMap} name.
+     *
+     * @param map  the {@link NamedMap} used to store documents
+     *
+     * @return a {@link CoherenceEmbeddingStore}
+     */
+    public static CoherenceEmbeddingStore create(NamedMap<DocumentChunk.Id, DocumentChunk> map) {
+        return new CoherenceEmbeddingStore(map, false);
+    }
+
+    /**
+     * Return a {@link Builder} to use to build a {@link CoherenceEmbeddingStore}.
+     *
+     * @return  a {@link Builder} to use to build a {@link CoherenceEmbeddingStore}
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    /**
+     * A builder to create {@link CoherenceEmbeddingStore} instances.
+     */
+    public static class Builder {
+        /**
+         * The name of the {@link NamedMap} to contain the {@link DocumentChunk document chunks}.
+         */
+        private String name = DEFAULT_MAP_NAME;
+
+        /**
+         * The name of the {@link Session} to use to obtain the {@link NamedMap}.
+         */
+        private String sessionName;
+
+        /**
+         * The {@link Session} to use to obtain the {@link NamedMap}.
+         */
+        private Session session;
+
+        /**
+         * The {@link VectorIndexExtractor} to use to create a vector index used to query the {@link NamedMap}.
+         */
+        private VectorIndexExtractor<DocumentChunk, Vector<?>> extractor;
+
+        /**
+         * A flag that when {@code true} forces normalization of embeddings on adding and searching
+         */
+        private boolean normalizeEmbeddings = false;
+
+        /**
+         * Create a {@link CoherenceEmbeddingStore.Builder}.
+         */
+        protected Builder() {
+        }
+
+        /**
+         * Set the name of the {@link NamedMap} that will hold the
+         * {@link DocumentChunk document chunks}.
+         *
+         * @param name  the name of the {@link NamedMap} that will hold
+         *              the {@link DocumentChunk document chunks}
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder name(String name) {
+            this.name = name == null || name.isEmpty() ? DEFAULT_MAP_NAME : name;
+            return this;
+        }
+
+        /**
+         * Set the name of the {@link Session} to use to obtain the
+         * document chunk {@link NamedMap}.
+         *
+         * @param sessionName  the session name
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder session(String sessionName) {
+            this.sessionName = sessionName;
+            this.session = null;
+            return this;
+        }
+
+        /**
+         * Set the {@link Session} to use to obtain the
+         * document chunk {@link NamedMap}.
+         *
+         * @param session  the {@link Session} to use
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder session(Session session) {
+            this.session = session;
+            this.sessionName = null;
+            return this;
+        }
+
+        /**
+         * Set the vector index to add to the underlying {@link NamedMap}.
+         *
+         * @param extractor  the {@link VectorIndexExtractor} to use to create the index
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder index(VectorIndexExtractor<DocumentChunk, Vector<?>> extractor) {
+            this.extractor = extractor;
+            return this;
+        }
+
+        /**
+         * Set whether to force normalization of vectors on adding and searching.
+         *
+         * @param f  {@code true} if the {@link CoherenceEmbeddingStore} should call force
+         *           {@link Embedding#normalize()} on embeddings when adding or searching
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder normalizeEmbeddings(boolean f) {
+            normalizeEmbeddings = f;
+            return this;
+        }
+
+        /**
+         * Build a {@link CoherenceEmbeddingStore} from the state in this builder.
+         *
+         * @return a new instance of a {@link CoherenceEmbeddingStore}
+         */
+        public CoherenceEmbeddingStore build() {
+            Session session = this.session;
+            if (session == null) {
+                if (sessionName != null) {
+                    session = Coherence.getInstance().getSession(sessionName);
+                }
+                else {
+                    session = Coherence.getInstance().getSession();
+                }
+            }
+            NamedMap<DocumentChunk.Id, DocumentChunk> map = session.getMap(name);
+            if (extractor != null) {
+                map.addIndex(extractor);
+            }
+            return new CoherenceEmbeddingStore(map, normalizeEmbeddings);
+        }
+    }
+}
diff --git a/langchain4j-coherence/src/main/java/dev/langchain4j/store/embedding/coherence/CoherenceMetadataFilterMapper.java b/langchain4j-coherence/src/main/java/dev/langchain4j/store/embedding/coherence/CoherenceMetadataFilterMapper.java
new file mode 100644
index 00000000000..836ab04b033
--- /dev/null
+++ b/langchain4j-coherence/src/main/java/dev/langchain4j/store/embedding/coherence/CoherenceMetadataFilterMapper.java
@@ -0,0 +1,135 @@
+package dev.langchain4j.store.embedding.coherence;
+
+import com.oracle.coherence.ai.DocumentChunk;
+import com.tangosol.util.Extractors;
+import com.tangosol.util.Filters;
+import com.tangosol.util.ValueExtractor;
+
+import dev.langchain4j.store.embedding.filter.Filter;
+import dev.langchain4j.store.embedding.filter.comparison.IsEqualTo;
+import dev.langchain4j.store.embedding.filter.comparison.IsGreaterThan;
+import dev.langchain4j.store.embedding.filter.comparison.IsGreaterThanOrEqualTo;
+import dev.langchain4j.store.embedding.filter.comparison.IsIn;
+import dev.langchain4j.store.embedding.filter.comparison.IsLessThan;
+import dev.langchain4j.store.embedding.filter.comparison.IsLessThanOrEqualTo;
+import dev.langchain4j.store.embedding.filter.comparison.IsNotEqualTo;
+import dev.langchain4j.store.embedding.filter.comparison.IsNotIn;
+import dev.langchain4j.store.embedding.filter.logical.And;
+import dev.langchain4j.store.embedding.filter.logical.Not;
+import dev.langchain4j.store.embedding.filter.logical.Or;
+
+import java.util.Collection;
+import java.util.HashSet;
+
+/**
+ * A mapper that maps {@link Filter LangChain4j filters} to
+ * {@link com.tangosol.util.Filter Coherence filters} that
+ * can be applied to {@link DocumentChunk} metadata.
+ */
+class CoherenceMetadataFilterMapper
+    {
+    /**
+     * Return the Coherence filter that is equivalent to the
+     * specified LangChain4j filter.
+     *
+     * @param filter  the LangChain filter to convert
+     *
+     * @return the equivalent Coherence filter
+     */
+    static com.tangosol.util.Filter<DocumentChunk> map(Filter filter) {
+        if (filter == null) {
+            return null;
+        } else if (filter instanceof IsEqualTo equalTo) {
+            return mapEqual(equalTo);
+        } else if (filter instanceof IsNotEqualTo notEqualTo) {
+            return mapNotEqual(notEqualTo);
+        } else if (filter instanceof IsGreaterThan greaterThan) {
+            return mapGreaterThan(greaterThan);
+        } else if (filter instanceof IsGreaterThanOrEqualTo greaterThanOrEqualTo) {
+            return mapGreaterThanOrEqual(greaterThanOrEqualTo);
+        } else if (filter instanceof IsLessThan lessThan) {
+            return mapLessThan(lessThan);
+        } else if (filter instanceof IsLessThanOrEqualTo lessThanOrEqualTo) {
+            return mapLessThanOrEqual(lessThanOrEqualTo);
+        } else if (filter instanceof IsIn in) {
+            return mapIn(in);
+        } else if (filter instanceof IsNotIn notIn) {
+            return mapNotIn(notIn);
+        } else if (filter instanceof And and) {
+            return mapAnd(and);
+        } else if (filter instanceof Not not) {
+            return mapNot(not);
+        } else if (filter instanceof Or or) {
+            return mapOr(or);
+        } else {
+            throw new UnsupportedOperationException("Unsupported filter type: " + filter.getClass().getName());
+        }
+    }
+
+    private static <V> ValueExtractor<DocumentChunk, V> extractor(String field) {
+        return Extractors.chained(ValueExtractor.of(DocumentChunk::metadata), Extractors.extract(field));
+    }
+
+    private static com.tangosol.util.Filter<DocumentChunk> mapEqual(IsEqualTo isEqualTo) {
+        return Filters.equal(extractor(isEqualTo.key()), isEqualTo.comparisonValue());
+    }
+
+    private static com.tangosol.util.Filter<DocumentChunk> mapNotEqual(IsNotEqualTo isNotEqualTo) {
+        return Filters.not(Filters.equal(extractor(isNotEqualTo.key()), isNotEqualTo.comparisonValue()));
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private static com.tangosol.util.Filter<DocumentChunk> mapGreaterThan(IsGreaterThan isGreaterThan) {
+        ValueExtractor<DocumentChunk, ? extends Comparable> extractor = extractor(isGreaterThan.key());
+        Comparable value = isGreaterThan.comparisonValue();
+        return Filters.greater(extractor, value);
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private static com.tangosol.util.Filter<DocumentChunk> mapGreaterThanOrEqual(IsGreaterThanOrEqualTo isGreaterThanOrEqualTo) {
+        ValueExtractor<DocumentChunk, ? extends Comparable> extractor = extractor(isGreaterThanOrEqualTo.key());
+        Comparable value = isGreaterThanOrEqualTo.comparisonValue();
+        return Filters.greaterEqual(extractor, value);
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private static com.tangosol.util.Filter<DocumentChunk> mapLessThan(IsLessThan isLessThan) {
+        ValueExtractor<DocumentChunk, ? extends Comparable> extractor = extractor(isLessThan.key());
+        Comparable value = isLessThan.comparisonValue();
+        return Filters.less(extractor, value);
+    }
+
+    @SuppressWarnings({"rawtypes", "unchecked"})
+    private static com.tangosol.util.Filter<DocumentChunk> mapLessThanOrEqual(IsLessThanOrEqualTo isLessThanOrEqualTo) {
+        ValueExtractor<DocumentChunk, ? extends Comparable> extractor = extractor(isLessThanOrEqualTo.key());
+        Comparable value = isLessThanOrEqualTo.comparisonValue();
+        return Filters.lessEqual(extractor, value);
+    }
+
+    public static com.tangosol.util.Filter<DocumentChunk> mapIn(IsIn isIn) {
+        ValueExtractor<DocumentChunk, ?> extractor = extractor(isIn.key());
+        Collection<?> values = isIn.comparisonValues();
+        return Filters.in(extractor, new HashSet<>(values));
+    }
+
+    public static com.tangosol.util.Filter<DocumentChunk> mapNotIn(IsNotIn isNotIn) {
+        ValueExtractor<DocumentChunk, ?> extractor = extractor(isNotIn.key());
+        Collection<?> values = isNotIn.comparisonValues();
+        return Filters.not(Filters.in(extractor, new HashSet<>(values)));
+    }
+
+    @SuppressWarnings("unchecked")
+    private static com.tangosol.util.Filter<DocumentChunk> mapAnd(And and) {
+        return Filters.all(map(and.left()), map(and.right()));
+    }
+
+    private static com.tangosol.util.Filter<DocumentChunk> mapNot(Not not) {
+        return Filters.not(map(not.expression()));
+    }
+
+    @SuppressWarnings("unchecked")
+    private static com.tangosol.util.Filter<DocumentChunk> mapOr(Or or) {
+        return Filters.any(map(or.left()), map(or.right()));
+    }
+}
+
diff --git a/langchain4j-coherence/src/main/java/dev/langchain4j/store/memory/chat/coherence/CoherenceChatMemoryStore.java b/langchain4j-coherence/src/main/java/dev/langchain4j/store/memory/chat/coherence/CoherenceChatMemoryStore.java
new file mode 100644
index 00000000000..d73e9be98db
--- /dev/null
+++ b/langchain4j-coherence/src/main/java/dev/langchain4j/store/memory/chat/coherence/CoherenceChatMemoryStore.java
@@ -0,0 +1,204 @@
+package dev.langchain4j.store.memory.chat.coherence;
+
+import com.oracle.coherence.ai.DocumentChunk;
+import com.tangosol.net.Coherence;
+import com.tangosol.net.NamedMap;
+import com.tangosol.net.Session;
+
+import dev.langchain4j.data.message.ChatMessage;
+import dev.langchain4j.data.message.ChatMessageDeserializer;
+import dev.langchain4j.data.message.ChatMessageSerializer;
+import dev.langchain4j.store.memory.chat.ChatMemoryStore;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static dev.langchain4j.internal.ValidationUtils.ensureNotEmpty;
+
+/**
+ * A {@link ChatMemoryStore} backed by an Oracle Coherence named map.
+ * <p>
+ * The {@link CoherenceChatMemoryStore} supports memory identifiers of any type
+ * that is a valid Coherence {@link NamedMap} key. The key type must properly
+ * implement {@code equals()} and {@code hashCode()} and be serializable by
+ * the configured Coherence serializer.
+ */
+public class CoherenceChatMemoryStore
+        implements ChatMemoryStore {
+
+    /**
+     * The default {@link NamedMap} name.
+     */
+    public static final String DEFAULT_MAP_NAME = "chatMemory";
+
+    /**
+     * The {@link NamedMap} used to store the chat messages.
+     */
+    protected final NamedMap<Object, String> chatMemory;
+
+    /**
+     * Create a {@link CoherenceChatMemoryStore}.
+     * <p>
+     * This method is protected, instances of {@link CoherenceChatMemoryStore}
+     * are created using the builder.
+     *
+     * @param chatMemory  the {@link NamedMap} to store the chat history.
+     */
+    protected CoherenceChatMemoryStore(NamedMap<Object, String> chatMemory) {
+        this.chatMemory = chatMemory;
+    }
+
+    @Override
+    public List<ChatMessage> getMessages(Object memoryId) {
+        validateId(memoryId);
+        String json = chatMemory.get(memoryId);
+        return json == null ? new ArrayList<>() : ChatMessageDeserializer.messagesFromJson(json);
+    }
+
+    @Override
+    public void updateMessages(Object memoryId, List<ChatMessage> messages) {
+        validateId(memoryId);
+        String json = ChatMessageSerializer.messagesToJson(ensureNotEmpty(messages, "messages"));
+        chatMemory.put(memoryId, json);
+    }
+
+    @Override
+    public void deleteMessages(Object memoryId) {
+        validateId(memoryId);
+        chatMemory.remove(memoryId);
+    }
+
+    private void validateId(Object memoryId) {
+        if (memoryId == null) {
+            throw new IllegalArgumentException("memoryId cannot be null");
+        }
+    }
+    /**
+     * Create a default {@link CoherenceChatMemoryStore}.
+     *
+     * @return a default {@link CoherenceChatMemoryStore}
+     */
+    public static CoherenceChatMemoryStore create() {
+        return builder().build();
+    }
+    
+    /**
+     * Create a {@link CoherenceChatMemoryStore} that uses the
+     * specified Coherence {@link NamedMap} name.
+     *
+     * @param name  the name of the Coherence {@link NamedMap} used to store documents
+     *
+     * @return a {@link CoherenceChatMemoryStore}
+     */
+    public static CoherenceChatMemoryStore create(String name) {
+        return builder().name(name).build();
+    }
+    
+    /**
+     * Create a {@link CoherenceChatMemoryStore} that uses the
+     * specified Coherence {@link NamedMap} name.
+     *
+     * @param map  the {@link NamedMap} used to store documents
+     *
+     * @return a {@link CoherenceChatMemoryStore}
+     */
+    public static CoherenceChatMemoryStore create(NamedMap<Object, String> map) {
+        return new CoherenceChatMemoryStore(map);
+    }
+    
+    /**
+     * Return a {@link Builder} to use to build a {@link CoherenceChatMemoryStore}.
+     *
+     * @return  a {@link Builder} to use to build a {@link CoherenceChatMemoryStore}
+     */
+    public static Builder builder() {
+        return new Builder();
+    }
+    
+    /**
+     * A builder to create {@link CoherenceChatMemoryStore} instances.
+     */
+    public static class Builder {
+        /**
+         * The name of the {@link NamedMap} to contain the {@link DocumentChunk document chunks}.
+         */
+        private String name = DEFAULT_MAP_NAME;
+    
+        /**
+         * The name of the {@link Session} to use to obtain the {@link NamedMap}.
+         */
+        private String sessionName;
+    
+        /**
+         * The {@link Session} to use to obtain the {@link NamedMap}.
+         */
+        private Session session;
+    
+        /**
+         * Create a {@link Builder}.
+         */
+        protected Builder() {
+        }
+    
+        /**
+         * Set the name of the {@link NamedMap} that will hold the
+         * {@link DocumentChunk document chunks}.
+         *
+         * @param name  the name of the {@link NamedMap} that will hold
+         *              the {@link DocumentChunk document chunks}
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder name(String name) {
+            this.name = name == null || name.isEmpty() ? DEFAULT_MAP_NAME : name;
+            return this;
+        }
+    
+        /**
+         * Set the name of the {@link Session} to use to obtain the
+         * document chunk {@link NamedMap}.
+         *
+         * @param sessionName  the session name
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder session(String sessionName) {
+            this.sessionName = sessionName;
+            this.session = null;
+            return this;
+        }
+    
+        /**
+         * Set the {@link Session} to use to obtain the
+         * document chunk {@link NamedMap}.
+         *
+         * @param session  the {@link Session} to use
+         *
+         * @return this builder for fluent method calls
+         */
+        public Builder session(Session session) {
+            this.session = session;
+            this.sessionName = null;
+            return this;
+        }
+    
+        /**
+         * Build a {@link CoherenceChatMemoryStore} from the state in this builder.
+         *
+         * @return a new instance of a {@link CoherenceChatMemoryStore}
+         */
+        public CoherenceChatMemoryStore build() {
+            Session session = this.session;
+            if (session == null) {
+                if (sessionName != null) {
+                    session = Coherence.getInstance().getSession(sessionName);
+                }
+                else {
+                    session = Coherence.getInstance().getSession();
+                }
+            }
+            NamedMap<Object, String> map = session.getMap(name);
+            return new CoherenceChatMemoryStore(map);
+        }
+    }
+}
diff --git a/langchain4j-coherence/src/test/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStoreIT.java b/langchain4j-coherence/src/test/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStoreIT.java
new file mode 100644
index 00000000000..bd79423bfd7
--- /dev/null
+++ b/langchain4j-coherence/src/test/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStoreIT.java
@@ -0,0 +1,75 @@
+package dev.langchain4j.store.embedding.coherence;
+
+import com.oracle.bedrock.junit.CoherenceClusterExtension;
+import com.oracle.bedrock.junit.SessionBuilders;
+import com.oracle.bedrock.runtime.coherence.CoherenceClusterMember;
+import com.oracle.bedrock.runtime.coherence.options.ClusterName;
+import com.oracle.bedrock.runtime.coherence.options.LocalHost;
+import com.oracle.bedrock.runtime.coherence.options.RoleName;
+import com.oracle.bedrock.runtime.coherence.options.WellKnownAddress;
+import com.oracle.bedrock.runtime.java.options.IPv4Preferred;
+import com.oracle.bedrock.runtime.java.options.SystemProperty;
+import com.oracle.bedrock.runtime.options.DisplayName;
+import com.oracle.bedrock.testsupport.junit.TestLogsExtension;
+
+import com.tangosol.net.Session;
+
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.EmbeddingStoreIT;
+import dev.langchain4j.store.embedding.EmbeddingStoreWithFilteringIT;
+
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+/**
+ * An extension of the LangChain4J {@link EmbeddingStoreIT} tests
+ * that use Coherence as an {@link EmbeddingStore}.
+ */
+public class CoherenceEmbeddingStoreIT
+        extends EmbeddingStoreWithFilteringIT {
+
+    @RegisterExtension
+    static TestLogsExtension testLogs = new TestLogsExtension();
+
+    @RegisterExtension
+    static CoherenceClusterExtension cluster = new CoherenceClusterExtension()
+            .with(ClusterName.of("CoherenceEmbeddingStoreIT"),
+                    WellKnownAddress.loopback(),
+                    LocalHost.only(),
+                    IPv4Preferred.autoDetect(),
+                    SystemProperty.of("coherence.serializer", "pof"))
+            .include(3, CoherenceClusterMember.class,
+                    DisplayName.of("storage"),
+                    RoleName.of("storage"),
+                    testLogs);
+
+    static Session session;
+
+    static EmbeddingModel model = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    static CoherenceEmbeddingStore embeddingStore;
+
+    @BeforeAll
+    public static void beforeAll() {
+        session = cluster.buildSession(SessionBuilders.storageDisabledMember(RoleName.of("test")));
+        embeddingStore = CoherenceEmbeddingStore.builder().session(session).build();
+    }
+
+    @Override
+    protected EmbeddingStore<TextSegment> embeddingStore() {
+        return embeddingStore;
+    }
+
+    @Override
+    protected EmbeddingModel embeddingModel() {
+        return model;
+    }
+
+    @Override
+    protected void clearStore() {
+        embeddingStore.removeAll();
+    }
+}
diff --git a/langchain4j-coherence/src/test/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStoreRemovalIT.java b/langchain4j-coherence/src/test/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStoreRemovalIT.java
new file mode 100644
index 00000000000..637c6db8e2d
--- /dev/null
+++ b/langchain4j-coherence/src/test/java/dev/langchain4j/store/embedding/coherence/CoherenceEmbeddingStoreRemovalIT.java
@@ -0,0 +1,67 @@
+package dev.langchain4j.store.embedding.coherence;
+
+import com.oracle.bedrock.junit.CoherenceClusterExtension;
+import com.oracle.bedrock.junit.SessionBuilders;
+import com.oracle.bedrock.runtime.coherence.CoherenceClusterMember;
+import com.oracle.bedrock.runtime.coherence.options.ClusterName;
+import com.oracle.bedrock.runtime.coherence.options.LocalHost;
+import com.oracle.bedrock.runtime.coherence.options.RoleName;
+import com.oracle.bedrock.runtime.coherence.options.WellKnownAddress;
+import com.oracle.bedrock.runtime.java.options.IPv4Preferred;
+import com.oracle.bedrock.runtime.java.options.SystemProperty;
+import com.oracle.bedrock.runtime.options.DisplayName;
+import com.oracle.bedrock.testsupport.junit.TestLogsExtension;
+import com.tangosol.net.Session;
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.EmbeddingStoreWithRemovalIT;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+public class CoherenceEmbeddingStoreRemovalIT
+    extends EmbeddingStoreWithRemovalIT {
+
+    @RegisterExtension
+    static TestLogsExtension testLogs = new TestLogsExtension();
+
+    @RegisterExtension
+    static CoherenceClusterExtension cluster = new CoherenceClusterExtension()
+            .with(ClusterName.of("CoherenceEmbeddingStoreRemovalIT"),
+                  WellKnownAddress.loopback(),
+                  LocalHost.only(),
+                  IPv4Preferred.autoDetect(),
+                  SystemProperty.of("coherence.serializer", "pof"))
+            .include(3, CoherenceClusterMember.class,
+                     DisplayName.of("storage"),
+                     RoleName.of("storage"),
+                     testLogs);
+
+    static Session session;
+
+    static EmbeddingModel model = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    static CoherenceEmbeddingStore embeddingStore;
+
+    @BeforeAll
+    public static void beforeAll() {
+        session = cluster.buildSession(SessionBuilders.storageDisabledMember(RoleName.of("test")));
+        embeddingStore = CoherenceEmbeddingStore.builder().session(session).build();
+    }
+
+    @BeforeEach
+    public void clearEmbeddings() {
+        embeddingStore.removeAll();
+    }
+    @Override
+    protected EmbeddingStore<TextSegment> embeddingStore() {
+        return embeddingStore;
+    }
+
+    @Override
+    protected EmbeddingModel embeddingModel() {
+        return model;
+    }
+}
diff --git a/langchain4j-coherence/src/test/java/dev/langchain4j/store/memory/chat/coherence/CoherenceChatMemoryStoreIT.java b/langchain4j-coherence/src/test/java/dev/langchain4j/store/memory/chat/coherence/CoherenceChatMemoryStoreIT.java
new file mode 100644
index 00000000000..f10bfd5dbc2
--- /dev/null
+++ b/langchain4j-coherence/src/test/java/dev/langchain4j/store/memory/chat/coherence/CoherenceChatMemoryStoreIT.java
@@ -0,0 +1,155 @@
+package dev.langchain4j.store.memory.chat.coherence;
+
+import com.oracle.bedrock.junit.CoherenceClusterExtension;
+import com.oracle.bedrock.junit.SessionBuilders;
+import com.oracle.bedrock.runtime.coherence.CoherenceClusterMember;
+import com.oracle.bedrock.runtime.coherence.options.ClusterName;
+import com.oracle.bedrock.runtime.coherence.options.LocalHost;
+import com.oracle.bedrock.runtime.coherence.options.RoleName;
+import com.oracle.bedrock.runtime.coherence.options.WellKnownAddress;
+import com.oracle.bedrock.runtime.java.options.IPv4Preferred;
+import com.oracle.bedrock.runtime.java.options.SystemProperty;
+import com.oracle.bedrock.runtime.options.DisplayName;
+import com.oracle.bedrock.testsupport.junit.TestLogsExtension;
+import com.tangosol.net.Session;
+import dev.langchain4j.data.message.ChatMessage;
+import dev.langchain4j.data.message.ChatMessageType;
+import dev.langchain4j.data.message.Content;
+import dev.langchain4j.data.message.ImageContent;
+import dev.langchain4j.data.message.SystemMessage;
+import dev.langchain4j.data.message.UserMessage;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.junit.jupiter.api.TestInfo;
+import org.junit.jupiter.api.extension.RegisterExtension;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.api.Assertions.assertThatThrownBy;
+
+class CoherenceChatMemoryStoreIT {
+
+    @RegisterExtension
+    static TestLogsExtension testLogs = new TestLogsExtension();
+
+    @RegisterExtension
+    static CoherenceClusterExtension cluster = new CoherenceClusterExtension()
+            .with(ClusterName.of("NamedMapEmbeddingRepositoryIT"),
+                    WellKnownAddress.loopback(),
+                    LocalHost.only(),
+                    IPv4Preferred.autoDetect(),
+                    SystemProperty.of("coherence.serializer", "pof"))
+            .include(3, CoherenceClusterMember.class,
+                    DisplayName.of("storage"),
+                    RoleName.of("storage"),
+                    testLogs);
+
+    static Session session;
+
+    private final String userId = "someUserId";
+
+    private CoherenceChatMemoryStore memoryStore;
+
+    @BeforeAll
+    public static void beforeAll() {
+        session = cluster.buildSession(SessionBuilders.storageDisabledMember(RoleName.of("test")));
+    }
+
+    @BeforeEach
+    void setUp(TestInfo testInfo) {
+        this.memoryStore = CoherenceChatMemoryStore.builder()
+                .session(session)
+                .name(testInfo.getDisplayName())
+                .build();
+        memoryStore.deleteMessages(userId);
+        List<ChatMessage> messages = memoryStore.getMessages(userId);
+        assertThat(messages).isEmpty();
+    }
+
+    @Test
+    void should_set_messages_into_coherence() {
+        // given
+        List<ChatMessage> messages = memoryStore.getMessages(userId);
+        assertThat(messages).isEmpty();
+
+        // when
+        List<ChatMessage> chatMessages = new ArrayList<>();
+        String sysMessage = "You are a large language model working with Langchain4j";
+        chatMessages.add(new SystemMessage(sysMessage));
+        List<Content> userMsgContents = new ArrayList<>();
+        userMsgContents.add(new ImageContent("someCatImageUrl"));
+        chatMessages.add(new UserMessage("user1", userMsgContents));
+        memoryStore.updateMessages(userId, chatMessages);
+
+        // then
+        messages = memoryStore.getMessages(userId);
+        assertThat(messages).hasSize(2);
+
+        assertThat(messages.get(0).type()).isEqualTo(ChatMessageType.SYSTEM);
+        assertThat(messages.get(1).type()).isEqualTo(ChatMessageType.USER);
+
+        SystemMessage sys = (SystemMessage) messages.get(0);
+        assertThat(sys.text()).isEqualTo(sysMessage);
+
+        UserMessage usr = (UserMessage) messages.get(1);
+        assertThat(usr.contents()).isEqualTo(userMsgContents);
+    }
+
+    @Test
+    void should_delete_messages_from_coherence() {
+        // given
+        List<ChatMessage> chatMessages = new ArrayList<>();
+        chatMessages.add(new SystemMessage("You are a large language model working with Langchain4j"));
+        memoryStore.updateMessages(userId, chatMessages);
+        List<ChatMessage> messages = memoryStore.getMessages(userId);
+        assertThat(messages).hasSize(1);
+
+        // when
+        memoryStore.deleteMessages(userId);
+
+        // then
+        messages = memoryStore.getMessages(userId);
+        assertThat(messages).isEmpty();
+    }
+
+    @Test
+    void getMessages_memoryId_null() {
+        assertThatThrownBy(() -> memoryStore.getMessages(null))
+                .isExactlyInstanceOf(IllegalArgumentException.class)
+                .hasMessage("memoryId cannot be null");
+    }
+
+    @Test
+    void updateMessages_messages_null() {
+        assertThatThrownBy(() -> memoryStore.updateMessages(userId, null))
+                .isExactlyInstanceOf(IllegalArgumentException.class)
+                .hasMessage("messages cannot be null or empty");
+    }
+
+    @Test
+    void updateMessages_messages_empty() {
+        List<ChatMessage> chatMessages = new ArrayList<>();
+        assertThatThrownBy(() -> memoryStore.updateMessages(userId, chatMessages))
+                .isExactlyInstanceOf(IllegalArgumentException.class)
+                .hasMessage("messages cannot be null or empty");
+    }
+
+    @Test
+    void updateMessages_memoryId_null() {
+        List<ChatMessage> chatMessages = new ArrayList<>();
+        chatMessages.add(new SystemMessage("You are a large language model working with Langchain4j"));
+        assertThatThrownBy(() -> memoryStore.updateMessages(null, chatMessages))
+                .isExactlyInstanceOf(IllegalArgumentException.class)
+                .hasMessage("memoryId cannot be null");
+    }
+
+    @Test
+    void deleteMessages_memoryId_null() {
+        assertThatThrownBy(() -> memoryStore.deleteMessages(null))
+                .isExactlyInstanceOf(IllegalArgumentException.class)
+                .hasMessage("memoryId cannot be null");
+    }
+}
diff --git a/pom.xml b/pom.xml
index c81cb767225..cbc35d1842c 100644
--- a/pom.xml
+++ b/pom.xml
@@ -54,6 +54,7 @@
         <module>langchain4j-azure-cosmos-nosql</module>
         <module>langchain4j-cassandra</module>
         <module>langchain4j-chroma</module>
+        <module>langchain4j-coherence</module>
         <module>langchain4j-couchbase</module>
         <module>langchain4j-elasticsearch</module>
         <module>langchain4j-infinispan</module>
