diff --git a/docs/docs/integrations/embedding-stores/mariadb.md b/docs/docs/integrations/embedding-stores/mariadb.md
new file mode 100644
index 00000000000..6745b527d3f
--- /dev/null
+++ b/docs/docs/integrations/embedding-stores/mariadb.md
@@ -0,0 +1,23 @@
+---
+sidebar_position: 18
+---
+
+# Mariadb Vector
+
+https://mariadb.com/kb/en/vector-overview
+
+
+## Maven Dependency
+
+```xml
+<dependency>
+    <groupId>dev.langchain4j</groupId>
+    <artifactId>langchain4j-mariadb</artifactId>
+    <version>1.0.0-beta1</version>
+</dependency>
+```
+
+
+## APIs
+
+- `MariaDbEmbeddingStore`
diff --git a/langchain4j-bom/pom.xml b/langchain4j-bom/pom.xml
index 36f8a6293ef..0e1f26db8bf 100644
--- a/langchain4j-bom/pom.xml
+++ b/langchain4j-bom/pom.xml
@@ -213,6 +213,12 @@
                 <version>${project.version}</version>
             </dependency>
 
+            <dependency>
+                <groupId>dev.langchain4j</groupId>
+                <artifactId>langchain4j-mariadb</artifactId>
+                <version>${project.version}</version>
+            </dependency>
+
             <dependency>
                 <groupId>dev.langchain4j</groupId>
                 <artifactId>langchain4j-mcp</artifactId>
diff --git a/langchain4j-mariadb/pom.xml b/langchain4j-mariadb/pom.xml
new file mode 100644
index 00000000000..bc2926057bd
--- /dev/null
+++ b/langchain4j-mariadb/pom.xml
@@ -0,0 +1,125 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
+    <modelVersion>4.0.0</modelVersion>
+
+    <parent>
+        <groupId>dev.langchain4j</groupId>
+        <artifactId>langchain4j-parent</artifactId>
+        <version>1.0.0-alpha2-SNAPSHOT</version>
+        <relativePath>../langchain4j-parent/pom.xml</relativePath>
+    </parent>
+
+    <artifactId>langchain4j-mariadb</artifactId>
+    <name>LangChain4j :: Integration :: MariaDB</name>
+    <description>MariaDB Vector support implementation</description>
+
+    <properties>
+        <mariadb-client.version>3.5.1</mariadb-client.version>
+        <jspecify.version>1.0.0</jspecify.version>
+        <enforcer.skipRules>dependencyConvergence</enforcer.skipRules>
+    </properties>
+
+    <dependencies>
+
+        <dependency>
+            <groupId>dev.langchain4j</groupId>
+            <artifactId>langchain4j-core</artifactId>
+            <version>${project.version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>com.fasterxml.jackson.core</groupId>
+            <artifactId>jackson-databind</artifactId>
+        </dependency>
+
+        <dependency>
+            <groupId>org.mariadb.jdbc</groupId>
+            <artifactId>mariadb-java-client</artifactId>
+            <version>${mariadb-client.version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>org.jspecify</groupId>
+            <artifactId>jspecify</artifactId>
+            <version>${jspecify.version}</version>
+        </dependency>
+
+        <dependency>
+            <groupId>dev.langchain4j</groupId>
+            <artifactId>langchain4j-core</artifactId>
+            <version>${project.version}</version>
+            <classifier>tests</classifier>
+            <type>test-jar</type>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-api</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <!-- junit-jupiter-params should be declared explicitly
+                to run parameterized tests inherited from EmbeddingStore*IT-->
+        <dependency>
+            <groupId>org.junit.jupiter</groupId>
+            <artifactId>junit-jupiter-params</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.assertj</groupId>
+            <artifactId>assertj-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>testcontainers</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.mockito</groupId>
+            <artifactId>mockito-core</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.testcontainers</groupId>
+            <artifactId>mariadb</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>dev.langchain4j</groupId>
+            <artifactId>langchain4j-embeddings-all-minilm-l6-v2-q</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+        <dependency>
+            <groupId>org.awaitility</groupId>
+            <artifactId>awaitility</artifactId>
+            <scope>test</scope>
+        </dependency>
+
+    </dependencies>
+
+    <build>
+        <plugins>
+            <plugin>
+                <groupId>org.honton.chas</groupId>
+                <artifactId>license-maven-plugin</artifactId>
+                <configuration>
+                    <acceptableLicenses combine.children="append">
+                        <license>
+                            <name>LGPL-2.1-or-later</name>
+                            <url>https://spdx.org/licenses/LGPL-2.1-or-later.html</url>
+                        </license>
+                    </acceptableLicenses>
+                </configuration>
+            </plugin>
+        </plugins>
+    </build>
+
+</project>
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/ColumnFilterMapper.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/ColumnFilterMapper.java
new file mode 100644
index 00000000000..ffba5b11352
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/ColumnFilterMapper.java
@@ -0,0 +1,15 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.sql.SQLException;
+import org.mariadb.jdbc.Driver;
+
+class ColumnFilterMapper extends MariaDbFilterMapper {
+
+    String formatKey(String key) {
+        try {
+            return Driver.enquoteIdentifier(key, true);
+        } catch (SQLException e) {
+            return key;
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/ColumnsMetadataHandler.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/ColumnsMetadataHandler.java
new file mode 100644
index 00000000000..dc7b3d279f6
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/ColumnsMetadataHandler.java
@@ -0,0 +1,132 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static dev.langchain4j.internal.Utils.getOrDefault;
+import static dev.langchain4j.internal.ValidationUtils.ensureNotEmpty;
+
+import dev.langchain4j.data.document.Metadata;
+import dev.langchain4j.store.embedding.filter.Filter;
+import java.sql.*;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+/**
+ * Handle Metadata stored in independent columns
+ */
+class ColumnsMetadataHandler implements MetadataHandler {
+
+    private final List<MetadataColumDefinition> columnsDefinition;
+    private final List<String> columnsName;
+    private final List<String> escapedColumnsName;
+    private final String insertClause;
+
+    private final MariaDbFilterMapper filterMapper;
+    private final List<String> indexes;
+
+    /**
+     * MetadataHandler constructor
+     * @param config {@link MetadataStorageConfig} configuration
+     */
+    public ColumnsMetadataHandler(MetadataStorageConfig config, List<String> sqlKeywords) {
+        List<String> columnsDefinitionList = ensureNotEmpty(config.columnDefinitions(), "Metadata definition");
+        this.filterMapper = new ColumnFilterMapper();
+
+        // enquote identifier if keywords
+        this.indexes = ((List<String>) getOrDefault(config.indexes(), Collections.emptyList()))
+                .stream()
+                        .map(key -> {
+                            if (sqlKeywords.contains(key.toLowerCase(Locale.ROOT))) {
+                                try {
+                                    return org.mariadb.jdbc.Driver.enquoteIdentifier(key, true);
+                                } catch (SQLException e) {
+                                    // eat
+                                }
+                            }
+                            return key;
+                        })
+                        .toList();
+        this.columnsDefinition = columnsDefinitionList.stream()
+                .map(str -> MetadataColumDefinition.from(str, sqlKeywords))
+                .collect(Collectors.toList());
+        this.escapedColumnsName = columnsDefinition.stream()
+                .map(MetadataColumDefinition::escapedName)
+                .collect(Collectors.toList());
+        this.insertClause = ", "
+                + this.escapedColumnsName.stream()
+                        .map(c -> String.format("%s = VALUES(%s)", c, c))
+                        .collect(Collectors.joining(","));
+        this.columnsName =
+                columnsDefinition.stream().map(MetadataColumDefinition::name).collect(Collectors.toList());
+    }
+
+    @Override
+    public String columnDefinitionsString() {
+        return this.columnsDefinition.stream()
+                .map(MetadataColumDefinition::fullDefinition)
+                .collect(Collectors.joining(","));
+    }
+
+    @Override
+    public List<String> escapedColumnsName() {
+        return this.escapedColumnsName;
+    }
+
+    @Override
+    public void createMetadataIndexes(Statement statement, String table) {
+        StringBuilder sb = new StringBuilder();
+        this.indexes.stream().map(String::trim).forEach(index -> {
+            sb.append(",").append(MariaDbValidator.validateAndEnquoteIdentifier(index, false));
+        });
+        String indexFields = sb.toString().substring(1);
+        String indexSql = "create index if not exists %s on %s ( %s )"
+                .formatted((table + "_metadata_idx").replaceAll("[ \\`\"'\\\\\\P{Print}]", ""), table, indexFields);
+        try {
+            statement.executeUpdate(indexSql);
+        } catch (SQLException e) {
+            throw new RuntimeException(String.format("Cannot create indexes on %s: %s", indexFields, e));
+        }
+    }
+
+    @Override
+    public String insertClause() {
+        return insertClause;
+    }
+
+    @Override
+    public void setMetadata(PreparedStatement upsertStmt, Integer parameterInitialIndex, Metadata metadata) {
+        int i = 0;
+        // only column names fields will be stored
+        Map<String, Object> meta = metadata.toMap();
+        for (String c : this.columnsName) {
+            try {
+                upsertStmt.setObject(parameterInitialIndex + i, meta.get(c));
+                i++;
+            } catch (SQLException e) {
+                throw new RuntimeException(e);
+            }
+        }
+    }
+
+    @Override
+    public String whereClause(Filter filter) {
+        return filterMapper.map(filter);
+    }
+
+    @Override
+    public Metadata fromResultSet(ResultSet resultSet) {
+        try {
+            Map<String, Object> metadataMap = new HashMap<>();
+            for (String c : this.columnsName) {
+                if (resultSet.getObject(c) != null) {
+                    metadataMap.put(c, resultSet.getObject(c));
+                }
+            }
+            return new Metadata(metadataMap);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/DefaultMetadataStorageConfig.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/DefaultMetadataStorageConfig.java
new file mode 100644
index 00000000000..e7f5b6d688f
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/DefaultMetadataStorageConfig.java
@@ -0,0 +1,58 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.util.Collections;
+import java.util.List;
+import org.jspecify.annotations.NonNull;
+
+/**
+ * Metadata configuration implementation
+ */
+public record DefaultMetadataStorageConfig(
+        MetadataStorageMode storageMode, List<String> columnDefinitions, List<String> indexes)
+        implements MetadataStorageConfig {
+
+    /**
+     * Default configuration
+     *
+     * @return Default configuration
+     */
+    public static MetadataStorageConfig defaultConfig() {
+        return builder()
+                .storageMode(MetadataStorageMode.COMBINED_JSON)
+                .columnDefinitions(Collections.singletonList("metadata JSON NULL"))
+                .build();
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+        private MetadataStorageMode storageMode;
+        private List<String> columnDefinitions;
+        private List<String> indexes;
+
+        @NonNull
+        public Builder storageMode(@NonNull MetadataStorageMode storageMode) {
+            this.storageMode = storageMode;
+            return this;
+        }
+
+        @NonNull
+        public Builder columnDefinitions(@NonNull List<String> columnDefinitions) {
+            this.columnDefinitions = columnDefinitions;
+            return this;
+        }
+
+        @NonNull
+        public Builder indexes(@NonNull List<String> indexes) {
+            this.indexes = indexes;
+            return this;
+        }
+
+        @NonNull
+        public DefaultMetadataStorageConfig build() {
+            return new DefaultMetadataStorageConfig(this.storageMode, this.columnDefinitions, this.indexes);
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/JSONFilterMapper.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/JSONFilterMapper.java
new file mode 100644
index 00000000000..85f00a9c8c3
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/JSONFilterMapper.java
@@ -0,0 +1,13 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+class JSONFilterMapper extends MariaDbFilterMapper {
+    final String metadataColumn;
+
+    public JSONFilterMapper(String metadataColumn) {
+        this.metadataColumn = metadataColumn;
+    }
+
+    String formatKey(String key) {
+        return "JSON_VALUE(" + this.metadataColumn + ", '$." + key + "')";
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/JSONMetadataHandler.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/JSONMetadataHandler.java
new file mode 100644
index 00000000000..f2d70931ca9
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/JSONMetadataHandler.java
@@ -0,0 +1,93 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static com.fasterxml.jackson.databind.SerializationFeature.INDENT_OUTPUT;
+import static dev.langchain4j.internal.Utils.getOrDefault;
+import static dev.langchain4j.internal.ValidationUtils.ensureNotEmpty;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import dev.langchain4j.data.document.Metadata;
+import dev.langchain4j.store.embedding.filter.Filter;
+import java.sql.*;
+import java.util.*;
+
+/**
+ * Handle metadata as JSON column.
+ */
+class JSONMetadataHandler implements MetadataHandler {
+    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper().enable(INDENT_OUTPUT);
+    public static final String DEFAULT_COLUMN_METADATA = "metadata";
+    private final MetadataColumDefinition columnDefinition;
+    private final String escapedColumnsName;
+    private final JSONFilterMapper filterMapper;
+    private final List<String> indexes;
+
+    /**
+     * MetadataHandler constructor
+     * @param config {@link MetadataStorageConfig} configuration
+     */
+    public JSONMetadataHandler(MetadataStorageConfig config, List<String> sqlKeywords) {
+        List<String> definition = ensureNotEmpty(config.columnDefinitions(), "Metadata definition");
+        if (definition.size() > 1) {
+            throw new IllegalArgumentException(
+                    "Metadata definition should be an unique column definition, " + "example: metadata JSON NULL");
+        }
+        this.columnDefinition = MetadataColumDefinition.from(definition.get(0), sqlKeywords);
+        if (this.columnDefinition.escapedName() == null) {
+            this.escapedColumnsName = DEFAULT_COLUMN_METADATA;
+        } else {
+            this.escapedColumnsName = this.columnDefinition.escapedName();
+        }
+
+        this.filterMapper = new JSONFilterMapper(escapedColumnsName);
+        this.indexes = getOrDefault(config.indexes(), Collections.emptyList());
+    }
+
+    @Override
+    public String columnDefinitionsString() {
+        return columnDefinition.fullDefinition();
+    }
+
+    @Override
+    public List<String> escapedColumnsName() {
+        return Collections.singletonList(this.escapedColumnsName);
+    }
+
+    @Override
+    public void createMetadataIndexes(Statement statement, String table) {
+        if (!this.indexes.isEmpty()) {
+            throw new RuntimeException("Indexes are actually not allowed for JSON metadata");
+        }
+    }
+
+    @Override
+    public String whereClause(Filter filter) {
+        return filterMapper.map(filter);
+    }
+
+    @Override
+    @SuppressWarnings("unchecked")
+    public Metadata fromResultSet(ResultSet resultSet) {
+        try {
+            String metadataJson = getOrDefault(resultSet.getString(5), "{}");
+            return new Metadata(OBJECT_MAPPER.readValue(metadataJson, Map.class));
+        } catch (SQLException | JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public String insertClause() {
+        return ", " + String.format("%s = VALUES(%s)", this.escapedColumnsName, this.escapedColumnsName);
+    }
+
+    @Override
+    public void setMetadata(PreparedStatement upsertStmt, Integer parameterInitialIndex, Metadata metadata) {
+        try {
+            String jsonValue = OBJECT_MAPPER.writeValueAsString(metadata.toMap());
+            upsertStmt.setString(parameterInitialIndex, jsonValue);
+        } catch (SQLException | JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDBDistanceType.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDBDistanceType.java
new file mode 100644
index 00000000000..2eb3c45e177
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDBDistanceType.java
@@ -0,0 +1,6 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+public enum MariaDBDistanceType {
+    EUCLIDEAN,
+    COSINE;
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStore.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStore.java
new file mode 100644
index 00000000000..786505cd61e
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStore.java
@@ -0,0 +1,478 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static dev.langchain4j.internal.Utils.*;
+import static dev.langchain4j.internal.ValidationUtils.*;
+
+import dev.langchain4j.data.document.Metadata;
+import dev.langchain4j.data.embedding.Embedding;
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.store.embedding.EmbeddingMatch;
+import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
+import dev.langchain4j.store.embedding.EmbeddingSearchResult;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.filter.Filter;
+import java.sql.*;
+import java.util.*;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+import javax.sql.DataSource;
+import org.mariadb.jdbc.MariaDbDataSource;
+import org.slf4j.Logger;
+import org.slf4j.LoggerFactory;
+
+/**
+ * MariaDB EmbeddingStore Implementation
+ * <p>
+ * Using cosine or Euclidean similarity
+ *
+ */
+public class MariaDbEmbeddingStore implements EmbeddingStore<TextSegment> {
+    private static final Logger log = LoggerFactory.getLogger(MariaDbEmbeddingStore.class);
+
+    /**
+     * Datasource used to create the store
+     */
+    private final DataSource datasource;
+
+    /**
+     * Embeddings table name
+     */
+    private final String table;
+
+    /**
+     * distance
+     */
+    private final MariaDBDistanceType distanceType;
+
+    private final String idFieldName;
+    private final String embeddingFieldName;
+    private final String contentFieldName;
+
+    public static final String DEFAULT_TABLE_NAME = "vector_store";
+
+    public static final String DEFAULT_COLUMN_EMBEDDING = "embedding";
+
+    public static final String DEFAULT_COLUMN_ID = "id";
+
+    public static final String DEFAULT_COLUMN_CONTENT = "content";
+
+    /**
+     * Metadata handler
+     */
+    final MetadataHandler metadataHandler;
+
+    /**
+     * Constructor for MariaDbEmbeddingStore Class
+     *
+     * @param datasource            The datasource to use
+     * @param builder               builder
+     */
+    private MariaDbEmbeddingStore(DataSource datasource, Builder builder) {
+        this.datasource = ensureNotNull(datasource, "datasource");
+        this.table = validateAndEnquoteIdentifier(builder.table, DEFAULT_TABLE_NAME);
+        this.contentFieldName = validateAndEnquoteIdentifier(builder.contentFieldName, DEFAULT_COLUMN_CONTENT);
+        this.embeddingFieldName = validateAndEnquoteIdentifier(builder.embeddingFieldName, DEFAULT_COLUMN_EMBEDDING);
+        this.idFieldName = validateAndEnquoteIdentifier(builder.idFieldName, DEFAULT_COLUMN_ID);
+
+        MetadataStorageConfig config =
+                getOrDefault(builder.metadataStorageConfig, DefaultMetadataStorageConfig.defaultConfig());
+        this.metadataHandler = MetadataHandlerFactory.get(config, this.datasource);
+        this.distanceType = builder.distanceType == null ? MariaDBDistanceType.COSINE : builder.distanceType;
+        int dimension = ensureNotNull(builder.dimension, "dimension");
+        initTable(builder.dropTableFirst, builder.createTable, dimension);
+    }
+
+    private String validateAndEnquoteIdentifier(String value, String defaultValue) {
+        return value == null || value.isEmpty()
+                ? defaultValue
+                : MariaDbValidator.validateAndEnquoteIdentifier(value, false);
+    }
+
+    /**
+     * Initialize metadata table following configuration
+     *
+     * @param dropTableFirst Should drop table first, usually for testing
+     * @param createTable    Should create table automatically
+     * @param dimension      The vector dimension
+     */
+    protected void initTable(boolean dropTableFirst, boolean createTable, int dimension) {
+        String query = "init";
+        try (Connection connection = datasource.getConnection();
+                Statement statement = connection.createStatement()) {
+            if (dropTableFirst) {
+                statement.executeUpdate("DROP TABLE IF EXISTS " + table);
+            }
+            if (createTable) {
+                query = String.format(
+                        "CREATE TABLE IF NOT EXISTS %s ("
+                                + "%s UUID NOT NULL DEFAULT uuid() PRIMARY KEY, "
+                                + "%s VECTOR(%s) NOT NULL, "
+                                + "%s TEXT NULL, "
+                                + "%s, "
+                                + "VECTOR INDEX %s_idx (%s) "
+                                + ") ENGINE=InnoDB COLLATE uca1400_ai_cs",
+                        table,
+                        idFieldName,
+                        embeddingFieldName,
+                        ensureGreaterThanZero(dimension, "dimension"),
+                        contentFieldName,
+                        metadataHandler.columnDefinitionsString(),
+                        (table + "_" + embeddingFieldName).replaceAll("[ \\`\"'\\\\\\P{Print}]", ""),
+                        embeddingFieldName);
+                statement.executeUpdate(query);
+                metadataHandler.createMetadataIndexes(statement, table);
+            }
+
+        } catch (SQLException e) {
+            throw new RuntimeException(String.format("Failed to execute '%s'", query), e);
+        }
+    }
+
+    /**
+     * Adds a given embedding to the store.
+     *
+     * @param embedding The embedding to be added to the store.
+     * @return The auto-generated ID associated with the added embedding.
+     */
+    @Override
+    public String add(Embedding embedding) {
+        String id = randomUUID();
+        addInternal(id, embedding, null);
+        return id;
+    }
+
+    /**
+     * Adds a given embedding to the store.
+     *
+     * @param id        The unique identifier for the embedding to be added.
+     * @param embedding The embedding to be added to the store.
+     */
+    @Override
+    public void add(String id, Embedding embedding) {
+        addInternal(id, embedding, null);
+    }
+
+    /**
+     * Adds a given embedding and the corresponding content that has been embedded to the store.
+     *
+     * @param embedding   The embedding to be added to the store.
+     * @param textSegment Original content that was embedded.
+     * @return The auto-generated ID associated with the added embedding.
+     */
+    @Override
+    public String add(Embedding embedding, TextSegment textSegment) {
+        String id = randomUUID();
+        addInternal(id, embedding, textSegment);
+        return id;
+    }
+
+    /**
+     * Adds multiple embeddings to the store.
+     *
+     * @param embeddings A list of embeddings to be added to the store.
+     * @return A list of auto-generated IDs associated with the added embeddings.
+     */
+    @Override
+    public List<String> addAll(List<Embedding> embeddings) {
+        List<String> ids = embeddings.stream().map(ignored -> randomUUID()).toList();
+        addAllInternal(ids, embeddings, null);
+        return ids;
+    }
+
+    /**
+     * Adds multiple embeddings and their corresponding contents that have been embedded to the store.
+     *
+     * @param embeddings A list of embeddings to be added to the store.
+     * @param embedded   A list of original contents that were embedded.
+     * @return A list of auto-generated IDs associated with the added embeddings.
+     */
+    @Override
+    public List<String> addAll(List<Embedding> embeddings, List<TextSegment> embedded) {
+        List<String> ids = embeddings.stream().map(ignored -> randomUUID()).toList();
+        addAllInternal(ids, embeddings, embedded);
+        return ids;
+    }
+
+    @Override
+    public void addAll(List<String> ids, List<Embedding> embeddings, List<TextSegment> embedded) {
+        addAllInternal(ids, embeddings, embedded);
+    }
+
+    @Override
+    public void removeAll(Collection<String> ids) {
+        ensureNotEmpty(ids, "ids");
+        try (Connection connection = datasource.getConnection();
+                Statement statement = connection.createStatement()) {
+            // ensure ids are UUID to avoid injection
+            String commaSeparated = ids.stream()
+                    .map(UUID::fromString)
+                    .map(uuid -> "'" + uuid + "'")
+                    .collect(Collectors.joining(","));
+
+            String sql = String.format("DELETE FROM %s WHERE %s IN (%s)", table, idFieldName, commaSeparated);
+            statement.executeUpdate(sql);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void removeAll(Filter filter) {
+        ensureNotNull(filter, "filter");
+        String whereClause = metadataHandler.whereClause(filter);
+        String sql = String.format("DELETE FROM %s WHERE %s", table, whereClause);
+        try (Connection connection = datasource.getConnection();
+                PreparedStatement statement = connection.prepareStatement(sql)) {
+            statement.executeUpdate();
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void removeAll() {
+        try (Connection connection = datasource.getConnection();
+                Statement statement = connection.createStatement()) {
+            statement.executeUpdate(String.format("TRUNCATE TABLE %s", table));
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Searches for the most similar (closest in the embedding space) {@link Embedding}s.
+     * <br>
+     * All search criteria are defined inside the {@link EmbeddingSearchRequest}.
+     * <br>
+     * {@link EmbeddingSearchRequest#filter()} is used to filter by meta dada.
+     *
+     * @param request A request to search in an {@link EmbeddingStore}. Contains all search criteria.
+     * @return An {@link EmbeddingSearchResult} containing all found {@link Embedding}s.
+     */
+    @Override
+    public EmbeddingSearchResult<TextSegment> search(EmbeddingSearchRequest request) {
+        Embedding referenceEmbedding = request.queryEmbedding();
+        int maxResults = request.maxResults();
+        double minScore = request.minScore();
+        Filter filter = request.filter();
+
+        List<EmbeddingMatch<TextSegment>> result = new ArrayList<>();
+        try (Connection connection = datasource.getConnection()) {
+
+            String metadataFilterClause = filter != null ? metadataHandler.whereClause(filter) : null;
+            String filterClause = "";
+            if (metadataFilterClause != null && !metadataFilterClause.isEmpty()) {
+                filterClause = "and " + metadataFilterClause + " ";
+            }
+
+            String distanceTypeName = this.distanceType.name().toLowerCase(Locale.ROOT);
+
+            final String sql = String.format(
+                    "SELECT * FROM (select %s, %s, %s, (2 - vec_distance_%s(%s, ?)) / 2 as"
+                            + " score, %s from %s) as t where score >= ? %sorder by score desc"
+                            + " LIMIT %s",
+                    idFieldName,
+                    embeddingFieldName,
+                    contentFieldName,
+                    distanceTypeName,
+                    embeddingFieldName,
+                    String.join(",", metadataHandler.escapedColumnsName()),
+                    table,
+                    filterClause,
+                    maxResults);
+
+            try (PreparedStatement selectStmt = connection.prepareStatement(sql)) {
+                selectStmt.setObject(1, referenceEmbedding.vector());
+                selectStmt.setDouble(2, minScore);
+
+                try (ResultSet resultSet = selectStmt.executeQuery()) {
+                    while (resultSet.next()) {
+                        String embeddingId = resultSet.getString(1);
+                        Embedding embedding = new Embedding(resultSet.getObject(2, float[].class));
+                        String text = resultSet.getString(3);
+                        double score = resultSet.getDouble(4);
+
+                        TextSegment textSegment = null;
+                        if (isNotNullOrBlank(text)) {
+                            Metadata metadata = metadataHandler.fromResultSet(resultSet);
+                            textSegment = TextSegment.from(text, metadata);
+                        }
+                        result.add(new EmbeddingMatch<>(score, embeddingId, embedding, textSegment));
+                    }
+                }
+            }
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+        return new EmbeddingSearchResult<>(result);
+    }
+
+    private void addInternal(String id, Embedding embedding, TextSegment embedded) {
+        addAllInternal(
+                Collections.singletonList(id),
+                Collections.singletonList(embedding),
+                embedded == null ? null : Collections.singletonList(embedded));
+    }
+
+    private void addAllInternal(List<String> ids, List<Embedding> embeddings, List<TextSegment> embedded) {
+        if (isNullOrEmpty(ids) || isNullOrEmpty(embeddings)) {
+            log.info("Empty embeddings - no ops");
+            return;
+        }
+        ensureTrue(ids.size() == embeddings.size(), "ids size is not equal to embeddings size");
+        ensureTrue(
+                embedded == null || embeddings.size() == embedded.size(),
+                "embeddings size is not equal to embedded size");
+
+        try (Connection connection = datasource.getConnection()) {
+            String query = String.format(
+                    "INSERT INTO %s (%s, %s, %s, %s) VALUES (?, ?, ?, %s) "
+                            + "ON DUPLICATE KEY UPDATE %s = VALUES(%s), %s = VALUES(%s)%s",
+                    table,
+                    idFieldName,
+                    embeddingFieldName,
+                    contentFieldName,
+                    String.join(",", metadataHandler.escapedColumnsName()),
+                    String.join(
+                            ",",
+                            Collections.nCopies(
+                                    metadataHandler.escapedColumnsName().size(), "?")),
+                    embeddingFieldName,
+                    embeddingFieldName,
+                    contentFieldName,
+                    contentFieldName,
+                    metadataHandler.insertClause());
+            try (PreparedStatement upsertStmt = connection.prepareStatement(query)) {
+                for (int i = 0; i < ids.size(); ++i) {
+                    upsertStmt.setString(1, ids.get(i));
+                    upsertStmt.setObject(2, embeddings.get(i).vector());
+
+                    if (embedded != null && embedded.get(i) != null) {
+                        upsertStmt.setString(3, embedded.get(i).text());
+                        metadataHandler.setMetadata(
+                                upsertStmt, 4, embedded.get(i).metadata());
+                    } else {
+                        upsertStmt.setNull(3, Types.VARCHAR);
+                        IntStream.range(
+                                        4,
+                                        4 + metadataHandler.escapedColumnsName().size())
+                                .forEach(j -> {
+                                    try {
+                                        upsertStmt.setNull(j, Types.OTHER);
+                                    } catch (SQLException e) {
+                                        throw new RuntimeException(e);
+                                    }
+                                });
+                    }
+                    upsertStmt.addBatch();
+                }
+                upsertStmt.executeBatch();
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public static Builder builder() {
+        return new Builder();
+    }
+
+    public static final class Builder {
+        private String table;
+        private MariaDBDistanceType distanceType;
+        private String idFieldName;
+        private String embeddingFieldName;
+        private String contentFieldName;
+        private MetadataStorageConfig metadataStorageConfig;
+        private boolean dropTableFirst;
+        private boolean createTable = false;
+        private Integer dimension;
+        private DataSource datasource;
+        private String url;
+        private String user;
+        private String password;
+
+        public Builder url(String url) {
+            this.url = url;
+            return this;
+        }
+
+        public Builder user(String user) {
+            this.user = user;
+            return this;
+        }
+
+        public Builder password(String password) {
+            this.password = password;
+            return this;
+        }
+
+        public Builder datasource(DataSource datasource) {
+            this.datasource = datasource;
+            return this;
+        }
+
+        public Builder table(String table) {
+            this.table = table;
+            return this;
+        }
+
+        public Builder distanceType(MariaDBDistanceType distanceType) {
+            this.distanceType = distanceType;
+            return this;
+        }
+
+        public Builder idFieldName(String idFieldName) {
+            this.idFieldName = idFieldName;
+            return this;
+        }
+
+        public Builder embeddingFieldName(String embeddingFieldName) {
+            this.embeddingFieldName = embeddingFieldName;
+            return this;
+        }
+
+        public Builder contentFieldName(String contentFieldName) {
+            this.contentFieldName = contentFieldName;
+            return this;
+        }
+
+        public Builder metadataStorageConfig(MetadataStorageConfig metadataStorageConfig) {
+            this.metadataStorageConfig = metadataStorageConfig;
+            return this;
+        }
+
+        public Builder dropTableFirst(boolean dropTableFirst) {
+            this.dropTableFirst = dropTableFirst;
+            return this;
+        }
+
+        public Builder createTable(boolean createTable) {
+            this.createTable = createTable;
+            return this;
+        }
+
+        public Builder dimension(Integer dimension) {
+            this.dimension = dimension;
+            return this;
+        }
+
+        public MariaDbEmbeddingStore build() {
+            if (datasource == null) {
+                if (url == null) {
+                    throw new IllegalArgumentException("set datasource or url ");
+                }
+                MariaDbDataSource ds = new MariaDbDataSource();
+                try {
+                    ds.setUrl(this.url);
+                    ds.setUser(this.user);
+                    ds.setPassword(this.password);
+                } catch (SQLException e) {
+                    throw new IllegalArgumentException("Wrong url configuring builder: '%s'".formatted(url), e);
+                }
+                datasource = ds;
+            }
+            return new MariaDbEmbeddingStore(datasource, this);
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbFilterMapper.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbFilterMapper.java
new file mode 100644
index 00000000000..cdb77d8586c
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbFilterMapper.java
@@ -0,0 +1,106 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static java.lang.String.format;
+
+import dev.langchain4j.store.embedding.filter.Filter;
+import dev.langchain4j.store.embedding.filter.comparison.*;
+import dev.langchain4j.store.embedding.filter.logical.And;
+import dev.langchain4j.store.embedding.filter.logical.Not;
+import dev.langchain4j.store.embedding.filter.logical.Or;
+import java.util.Collection;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+abstract class MariaDbFilterMapper {
+
+    public String map(Filter filter) {
+        if (filter instanceof IsEqualTo) {
+            return mapEqual((IsEqualTo) filter);
+        } else if (filter instanceof IsNotEqualTo) {
+            return mapNotEqual((IsNotEqualTo) filter);
+        } else if (filter instanceof IsGreaterThan) {
+            return mapGreaterThan((IsGreaterThan) filter);
+        } else if (filter instanceof IsGreaterThanOrEqualTo) {
+            return mapGreaterThanOrEqual((IsGreaterThanOrEqualTo) filter);
+        } else if (filter instanceof IsLessThan) {
+            return mapLessThan((IsLessThan) filter);
+        } else if (filter instanceof IsLessThanOrEqualTo) {
+            return mapLessThanOrEqual((IsLessThanOrEqualTo) filter);
+        } else if (filter instanceof IsIn) {
+            return mapIn((IsIn) filter);
+        } else if (filter instanceof IsNotIn) {
+            return mapNotIn((IsNotIn) filter);
+        } else if (filter instanceof And) {
+            return mapAnd((And) filter);
+        } else if (filter instanceof Not) {
+            return mapNot((Not) filter);
+        } else if (filter instanceof Or) {
+            return mapOr((Or) filter);
+        } else {
+            throw new UnsupportedOperationException(
+                    "Unsupported filter type: " + filter.getClass().getName());
+        }
+    }
+
+    private String mapEqual(IsEqualTo isEqualTo) {
+        String key = formatKey(isEqualTo.key());
+        return format("%s is not null and %s = %s", key, key, formatValue(isEqualTo.comparisonValue()));
+    }
+
+    private String mapNotEqual(IsNotEqualTo isNotEqualTo) {
+        String key = formatKey(isNotEqualTo.key());
+        return format("(%s is null or %s != %s)", key, key, formatValue(isNotEqualTo.comparisonValue()));
+    }
+
+    private String mapGreaterThan(IsGreaterThan isGreaterThan) {
+        return format("%s > %s", formatKey(isGreaterThan.key()), formatValue(isGreaterThan.comparisonValue()));
+    }
+
+    private String mapGreaterThanOrEqual(IsGreaterThanOrEqualTo isGreaterThanOrEqualTo) {
+        return format(
+                "%s >= %s",
+                formatKey(isGreaterThanOrEqualTo.key()), formatValue(isGreaterThanOrEqualTo.comparisonValue()));
+    }
+
+    private String mapLessThan(IsLessThan isLessThan) {
+        return format("%s < %s", formatKey(isLessThan.key()), formatValue(isLessThan.comparisonValue()));
+    }
+
+    private String mapLessThanOrEqual(IsLessThanOrEqualTo isLessThanOrEqualTo) {
+        return format(
+                "%s <= %s", formatKey(isLessThanOrEqualTo.key()), formatValue(isLessThanOrEqualTo.comparisonValue()));
+    }
+
+    private String mapIn(IsIn isIn) {
+        return format("%s in %s", formatKey(isIn.key()), formatValue(isIn.comparisonValues()));
+    }
+
+    private String mapNotIn(IsNotIn isNotIn) {
+        String key = formatKey(isNotIn.key());
+        return format("(%s is null or %s not in %s)", key, key, formatValue(isNotIn.comparisonValues()));
+    }
+
+    private String mapAnd(And and) {
+        return format("%s and %s", map(and.left()), map(and.right()));
+    }
+
+    private String mapNot(Not not) {
+        return format("not (%s)", map(not.expression()));
+    }
+
+    private String mapOr(Or or) {
+        return format("(%s or %s)", map(or.left()), map(or.right()));
+    }
+
+    abstract String formatKey(String key);
+
+    String formatValue(Object value) {
+        if (value instanceof final Collection<?> vals) {
+            return "(" + vals.stream().map(v -> formatValue(v)).collect(Collectors.joining(",")) + ")";
+        } else if (value instanceof String || value instanceof UUID) {
+            return "'" + value + "'";
+        } else {
+            return value.toString();
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbValidator.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbValidator.java
new file mode 100644
index 00000000000..fe76c587dc8
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MariaDbValidator.java
@@ -0,0 +1,24 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.sql.SQLException;
+import org.mariadb.jdbc.Driver;
+
+class MariaDbValidator {
+
+    /**
+     * Escaped identifier according to MariaDB requirement.
+     * @param identifier identifier
+     * @param alwaysQuote indicate if identifier must be quoted even if not necessary.
+     * @return return escaped identifier, quoted when necessary or indicated with
+     * alwaysQuote.
+     * @see <a href="https://mariadb.com/kb/en/library/identifier-names/">mariadb
+     * identifier name</a>
+     */
+    public static String validateAndEnquoteIdentifier(String identifier, boolean alwaysQuote) {
+        try {
+            return Driver.enquoteIdentifier(identifier, alwaysQuote);
+        } catch (SQLException e) {
+            throw new IllegalArgumentException(e);
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataColumDefinition.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataColumDefinition.java
new file mode 100644
index 00000000000..6178527d9bf
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataColumDefinition.java
@@ -0,0 +1,53 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import dev.langchain4j.internal.ValidationUtils;
+import java.util.List;
+import java.util.Locale;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * MetadataColumDefinition used to define column definition from sql String
+ */
+public record MetadataColumDefinition(String fullDefinition, String escapedName, String name, String type) {
+    private static final Pattern litteralPattern =
+            Pattern.compile("^(([a-zA-Z0-9_]+)|(`((``)|[^`])+`))", Pattern.DOTALL);
+
+    /**
+     * transform sql string to MetadataColumDefinition
+     * @param sqlDefinition sql definition string
+     * @param sqlKeywords sql reserved keywords
+     * @return MetadataColumDefinition
+     */
+    public static MetadataColumDefinition from(String sqlDefinition, List<String> sqlKeywords) {
+        String fullDefinition = ValidationUtils.ensureNotNull(sqlDefinition, "Metadata column definition")
+                .trim();
+        Matcher matcher = litteralPattern.matcher(sqlDefinition);
+        if (matcher.find()) {
+            String fieldName = matcher.group(0);
+            String remainingDefinition =
+                    fullDefinition.substring(fieldName.length()).trim();
+            if (remainingDefinition.isEmpty()) {
+                throw new IllegalArgumentException("Definition format should be: <column name> <type> "
+                        + " [ NULL | NOT NULL ] [ UNIQUE ] [ DEFAULT value ]");
+            }
+            String escapedName = fieldName;
+            String unescapedName =
+                    (fieldName.startsWith("`")) ? fieldName.substring(1, fieldName.length() - 1) : fieldName;
+            String type = fullDefinition
+                    .substring(fieldName.length())
+                    .trim()
+                    .split(" ")[0]
+                    .toLowerCase();
+
+            if (!fieldName.startsWith("`") && sqlKeywords.contains(unescapedName.toLowerCase(Locale.ROOT))) {
+                // if field name is a reserved keywords, force quote
+                escapedName = MariaDbValidator.validateAndEnquoteIdentifier(unescapedName, true);
+                fullDefinition = escapedName + fullDefinition.substring(fieldName.length());
+            }
+            return new MetadataColumDefinition(fullDefinition, escapedName, unescapedName, type);
+        } else
+            throw new IllegalArgumentException("Wrong definition format should be: <column name> <type> "
+                    + " [ NULL | NOT NULL ] [ UNIQUE ] [ DEFAULT value ]");
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataHandler.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataHandler.java
new file mode 100644
index 00000000000..fde1154a295
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataHandler.java
@@ -0,0 +1,70 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import dev.langchain4j.data.document.Metadata;
+import dev.langchain4j.store.embedding.filter.Filter;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.Statement;
+import java.util.List;
+
+/**
+ * Handle PV Store metadata.
+ */
+interface MetadataHandler {
+
+    /**
+     * String definition used to create the metadata field(s) in embeddings table
+     *
+     * @return the sql clause that creates metadata field(s)
+     *
+     */
+    String columnDefinitionsString();
+
+    /**
+     * Setup indexes for metadata fields
+     * By default, no index is created.
+     *
+     * @param statement used to execute indexes creation.
+     * @param table table name.
+     */
+    void createMetadataIndexes(Statement statement, String table);
+
+    /**
+     * Metadata escaped (if needed) columns name
+     *
+     * @return list of columns used as metadata
+     */
+    List<String> escapedColumnsName();
+
+    /**
+     * Generate the SQL where clause following @{@link Filter}
+     *
+     * @param filter filter
+     * @return the sql where clause
+     */
+    String whereClause(Filter filter);
+
+    /**
+     * Extract Metadata from Resultset and Metadata definition
+     *
+     * @param resultSet resultSet
+     * @return metadata object
+     */
+    Metadata fromResultSet(ResultSet resultSet);
+
+    /**
+     * Generate the SQL insert clause following Metadata definition
+     *
+     * @return the sql insert clause
+     */
+    String insertClause();
+
+    /**
+     * Set meta data values following metadata and metadata definition
+     *
+     * @param upsertStmt statement to set values
+     * @param parameterInitialIndex initial parameter index
+     * @param metadata metadata values
+     */
+    void setMetadata(PreparedStatement upsertStmt, Integer parameterInitialIndex, Metadata metadata);
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataHandlerFactory.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataHandlerFactory.java
new file mode 100644
index 00000000000..874524e54aa
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataHandlerFactory.java
@@ -0,0 +1,49 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.stream.Collectors;
+import javax.sql.DataSource;
+
+/**
+ * MetadataHandlerFactory class
+ * Use the {@link MetadataStorageConfig#storageMode()} to switch between different Handler implementation
+ */
+class MetadataHandlerFactory {
+    /**
+     * Default Constructor
+     */
+    public MetadataHandlerFactory() {}
+
+    /**
+     * Retrieve the handler associated to the config
+     * @param config MetadataConfig config
+     * @param dataSource datasource
+     * @return MetadataHandler
+     */
+    static MetadataHandler get(MetadataStorageConfig config, DataSource dataSource) {
+
+        List<String> sqlKeywords = new ArrayList<>();
+        try (Connection connection = dataSource.getConnection()) {
+            sqlKeywords = Arrays.stream(
+                            connection.getMetaData().getSQLKeywords().split(","))
+                    .map(str -> str.toLowerCase(Locale.ROOT))
+                    .collect(Collectors.toList());
+        } catch (SQLException e) {
+            // eat
+        }
+
+        switch (config.storageMode()) {
+            case COMBINED_JSON:
+                return new JSONMetadataHandler(config, sqlKeywords);
+            case COLUMN_PER_KEY:
+                return new ColumnsMetadataHandler(config, sqlKeywords);
+            default:
+                throw new RuntimeException(String.format("Type %s not handled.", config.storageMode()));
+        }
+    }
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataStorageConfig.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataStorageConfig.java
new file mode 100644
index 00000000000..a7a1255f99c
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataStorageConfig.java
@@ -0,0 +1,39 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.util.List;
+
+/**
+ * Metadata configuration.
+ */
+public interface MetadataStorageConfig {
+    /**
+     * Metadata storage mode
+     * <ul>
+     * <li>COMBINED_JSON: For dynamic metadata, when you don't know the list of metadata that will be used.
+     * <li>COLUMN_PER_KEY: for static metadata, when you know in advance the list of metadata
+     * </ul>
+     * @return Metadata storage mode
+     */
+    MetadataStorageMode storageMode();
+
+    /**
+     * SQL definition of metadata field(s) list.
+     * Example:
+     * <ul>
+     * <li>COMBINED_JSON: <code>Collections.singletonList("metadata JSON NULL")</code>
+     * <li>COLUMN_PER_KEY: <code>Arrays.asList("condominium_id uuid null", "user uuid null")</code>
+     * </ul>
+     * @return list of column definitions
+     */
+    List<String> columnDefinitions();
+
+    /**
+     * Metadata Indexes, list of fields to use as index.
+     * Example:
+     * <ul>
+     * <li>COLUMN_PER_KEY: <code>Arrays.asList("key", "name", "age")</code>
+     * </ul>
+     * @return Metadata Indexes list
+     */
+    List<String> indexes();
+}
diff --git a/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataStorageMode.java b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataStorageMode.java
new file mode 100644
index 00000000000..5b185eee20b
--- /dev/null
+++ b/langchain4j-mariadb/src/main/java/dev/langchain4j/store/embedding/mariadb/MetadataStorageMode.java
@@ -0,0 +1,22 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+/**
+ * Metadata storage mode
+ * <ul>
+ * <li>COLUMN_PER_KEY: for static metadata, when you know in advance the list of metadata
+ * <li>COMBINED_JSON: For dynamic metadata, when you don't know the list of metadata that will be used.
+ * </ul>
+ * <p>
+ * Default value: COMBINED_JSON
+ */
+public enum MetadataStorageMode {
+    /**
+     * COLUMN_PER_KEY: for static metadata, when you know in advance the list of metadata
+     */
+    COLUMN_PER_KEY,
+
+    /**
+     * COMBINED_JSON: For dynamic metadata, when you don't know the list of metadata that will be used.
+     */
+    COMBINED_JSON,
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/JSONMetadataHandlerTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/JSONMetadataHandlerTest.java
new file mode 100644
index 00000000000..6a36dc9ed3d
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/JSONMetadataHandlerTest.java
@@ -0,0 +1,77 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.mockito.Mockito.*;
+
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collections;
+import java.util.List;
+import org.junit.Assert;
+import org.junit.jupiter.api.Test;
+import org.mockito.AdditionalAnswers;
+
+class JSONMetadataHandlerTest {
+
+    @Test
+    void createSimpleMetadataIndexes() throws SQLException {
+        Statement statement = mock(Statement.class);
+        List<String> sqlStatementQueries = new ArrayList<>();
+        when(statement.executeUpdate(anyString()))
+                .thenAnswer(AdditionalAnswers.answerVoid(q -> sqlStatementQueries.add((String) q)));
+
+        MetadataStorageConfig metadataStorageConfig = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COMBINED_JSON)
+                .columnDefinitions(Collections.singletonList("metadata JSON"))
+                .indexes(Collections.singletonList("country"))
+                .build();
+        JSONMetadataHandler jsonMetadataHandler =
+                new JSONMetadataHandler(metadataStorageConfig, Collections.emptyList());
+        Assert.assertThrows(
+                RuntimeException.class, () -> jsonMetadataHandler.createMetadataIndexes(statement, "embeddings"));
+
+        assertThat(sqlStatementQueries).isEmpty();
+    }
+
+    @Test
+    void createSimpleMetadataIndexes_json_path_ops() throws SQLException {
+        Statement statement = mock(Statement.class);
+        List<String> sqlStatementQueries = new ArrayList<>();
+        when(statement.executeUpdate(anyString()))
+                .thenAnswer(AdditionalAnswers.answerVoid(q -> sqlStatementQueries.add((String) q)));
+
+        MetadataStorageConfig metadataStorageConfig = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COMBINED_JSON)
+                .columnDefinitions(Collections.singletonList("metadata JSON"))
+                .indexes(Collections.singletonList("json_path_ops"))
+                .build();
+        JSONMetadataHandler jsonMetadataHandler =
+                new JSONMetadataHandler(metadataStorageConfig, Collections.emptyList());
+        Assert.assertThrows(
+                RuntimeException.class, () -> jsonMetadataHandler.createMetadataIndexes(statement, "embeddings"));
+
+        assertThat(sqlStatementQueries).isEmpty();
+    }
+
+    @Test
+    void createJSONNodeMetadataIndexes() throws SQLException {
+        Statement statement = mock(Statement.class);
+        List<String> sqlStatementQueries = new ArrayList<>();
+        when(statement.executeUpdate(anyString()))
+                .thenAnswer(AdditionalAnswers.answerVoid(q -> sqlStatementQueries.add((String) q)));
+
+        MetadataStorageConfig metadataStorageConfig = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COMBINED_JSON)
+                .columnDefinitions(Collections.singletonList("metadata JSON"))
+                .indexes(Arrays.asList("key1", "key2"))
+                .build();
+        JSONMetadataHandler jsonMetadataHandler =
+                new JSONMetadataHandler(metadataStorageConfig, Collections.emptyList());
+        Assert.assertThrows(
+                RuntimeException.class, () -> jsonMetadataHandler.createMetadataIndexes(statement, "embeddings"));
+
+        assertThat(sqlStatementQueries).isEmpty();
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingCustomNamingTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingCustomNamingTest.java
new file mode 100644
index 00000000000..3be41915758
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingCustomNamingTest.java
@@ -0,0 +1,198 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static org.assertj.core.api.Assertions.assertThat;
+
+import dev.langchain4j.data.embedding.Embedding;
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
+import dev.langchain4j.store.embedding.EmbeddingSearchResult;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import java.sql.Connection;
+import java.sql.DriverManager;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.util.Arrays;
+import java.util.Collections;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.params.ParameterizedTest;
+import org.junit.jupiter.params.provider.CsvSource;
+import org.testcontainers.containers.MariaDBContainer;
+
+class MariaDbEmbeddingCustomNamingTest {
+
+    static MariaDBContainer<?> mariadbContainer = MariaDbTests.defaultContainer;
+
+    EmbeddingModel embeddingModel = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    @BeforeAll
+    public static void beforeAll() {
+        mariadbContainer.start();
+    }
+
+    @ParameterizedTest
+    @CsvSource({
+        "my_table,my_id,my_embedding,my_content,my_meta",
+        "my_table2,my_id 2,my_embedding 2,my_content 2,`my_meta 2`",
+        "`my_ta``ble3`,`my_id3`,`my_embedding3`,`my_content3`,`my_meta3`"
+    })
+    void testJsonNaming(
+            String tableName, String idName, String embeddingName, String contentName, String metadataJsonName)
+            throws SQLException {
+        MetadataStorageConfig metadataStorageConfig = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COMBINED_JSON)
+                .columnDefinitions(Collections.singletonList(metadataJsonName + " JSON"))
+                .build();
+        EmbeddingStore<TextSegment> embeddingStore = MariaDbEmbeddingStore.builder()
+                .url(mariadbContainer.getJdbcUrl())
+                .user(mariadbContainer.getUsername())
+                .password(mariadbContainer.getPassword())
+                .table(tableName)
+                .idFieldName(idName)
+                .embeddingFieldName(embeddingName)
+                .contentFieldName(contentName)
+                .metadataStorageConfig(metadataStorageConfig)
+                .dimension(384)
+                .createTable(true)
+                .dropTableFirst(true)
+                .build();
+
+        Embedding embedding = embeddingModel.embed("hello").content();
+        String id = embeddingStore.add(embedding);
+        EmbeddingSearchRequest embeddingSearchRequest = EmbeddingSearchRequest.builder()
+                .queryEmbedding(embedding)
+                .maxResults(10)
+                .minScore(0.0)
+                .build();
+        EmbeddingSearchResult<?> embeddingSearchResult = embeddingStore.search(embeddingSearchRequest);
+        var relevant = embeddingSearchResult.matches();
+        assertThat(relevant).hasSize(1);
+
+        embeddingStore.remove(id);
+
+        assertThat(isTableExists(tableName)).isTrue();
+        assertThat(areColumnsExisting(tableName, new String[] {idName, embeddingName, contentName, metadataJsonName}))
+                .isTrue();
+        assertThat(isVectorIndexExists(tableName)).isTrue();
+    }
+
+    @ParameterizedTest
+    @CsvSource({
+        "my_table,my_id,my_embedding,my_content,my_meta",
+        "my_table2,my_id 2,my_embedding 2,my_content 2",
+        "`my_ta``ble3`,`my_id3`,`my_embedding3`,`my_content3`"
+    })
+    void testColsNaming(String tableName, String idName, String embeddingName, String contentName) throws SQLException {
+        MetadataStorageConfig metadataStorageConfig = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COLUMN_PER_KEY)
+                .columnDefinitions(Arrays.asList("key varchar(255)", "`name` varchar(255)", "`age` float"))
+                .indexes(Arrays.asList("key", "name"))
+                .build();
+        EmbeddingStore<TextSegment> embeddingStore = MariaDbEmbeddingStore.builder()
+                .url(mariadbContainer.getJdbcUrl())
+                .user(mariadbContainer.getUsername())
+                .password(mariadbContainer.getPassword())
+                .table(tableName)
+                .idFieldName(idName)
+                .embeddingFieldName(embeddingName)
+                .contentFieldName(contentName)
+                .metadataStorageConfig(metadataStorageConfig)
+                .dimension(384)
+                .createTable(true)
+                .dropTableFirst(true)
+                .build();
+
+        Embedding embedding = embeddingModel.embed("hello").content();
+        String id = embeddingStore.add(embedding);
+        EmbeddingSearchRequest embeddingSearchRequest = EmbeddingSearchRequest.builder()
+                .queryEmbedding(embedding)
+                .maxResults(10)
+                .minScore(0.0)
+                .build();
+        EmbeddingSearchResult<?> embeddingSearchResult = embeddingStore.search(embeddingSearchRequest);
+        var relevant = embeddingSearchResult.matches();
+        assertThat(relevant).hasSize(1);
+
+        embeddingStore.remove(id);
+
+        assertThat(isTableExists(tableName)).isTrue();
+        assertThat(areColumnsExisting(
+                        tableName, new String[] {idName, embeddingName, contentName, "key", "name", "age"}))
+                .isTrue();
+        assertThat(isColIndexExists(tableName, new String[] {"key", "name"})).isTrue();
+    }
+
+    private static boolean isVectorIndexExists(String tableName) throws SQLException {
+        try (Connection connection = DriverManager.getConnection(
+                mariadbContainer.getJdbcUrl(), mariadbContainer.getUsername(), mariadbContainer.getPassword())) {
+            String sql = "SELECT EXISTS (SELECT * FROM information_schema.statistics WHERE"
+                    + " TABLE_SCHEMA=? AND TABLE_NAME=? AND INDEX_TYPE='VECTOR')";
+            try (PreparedStatement prep = connection.prepareStatement(sql)) {
+                prep.setString(1, mariadbContainer.getDatabaseName());
+                prep.setString(2, removeQuotes(tableName));
+                ResultSet rs = prep.executeQuery();
+                return rs.next() && rs.getBoolean(1);
+            }
+        }
+    }
+
+    private static boolean isColIndexExists(String tableName, String[] indexFieldNames) throws SQLException {
+        try (Connection connection = DriverManager.getConnection(
+                mariadbContainer.getJdbcUrl(), mariadbContainer.getUsername(), mariadbContainer.getPassword())) {
+
+            String sql = "SELECT EXISTS (SELECT * FROM information_schema.statistics WHERE table_schema="
+                    + " ? AND  table_name = ? AND column_name = ?)";
+            try (PreparedStatement prep = connection.prepareStatement(sql)) {
+                for (String field : indexFieldNames) {
+                    prep.setString(1, mariadbContainer.getDatabaseName());
+                    prep.setString(2, removeQuotes(tableName));
+                    prep.setString(3, removeQuotes(field));
+                    ResultSet rs = prep.executeQuery();
+                    if (!rs.next() || !rs.getBoolean(1)) return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    @SuppressWarnings("null")
+    private static boolean isTableExists(String tableName) throws SQLException {
+        try (Connection connection = DriverManager.getConnection(
+                mariadbContainer.getJdbcUrl(), mariadbContainer.getUsername(), mariadbContainer.getPassword())) {
+            String sql = "SELECT EXISTS (SELECT * FROM information_schema.tables WHERE table_schema= ?"
+                    + " AND table_name = ?)";
+            try (PreparedStatement prep = connection.prepareStatement(sql)) {
+                prep.setString(1, mariadbContainer.getDatabaseName());
+                prep.setString(2, removeQuotes(tableName));
+                ResultSet rs = prep.executeQuery();
+                return rs.next() && rs.getBoolean(1);
+            }
+        }
+    }
+
+    private static boolean areColumnsExisting(String tableName, String[] fieldNames) throws SQLException {
+
+        try (Connection connection = DriverManager.getConnection(
+                mariadbContainer.getJdbcUrl(), mariadbContainer.getUsername(), mariadbContainer.getPassword())) {
+
+            String sql = "SELECT EXISTS (SELECT * FROM information_schema.columns WHERE table_schema= ?"
+                    + " AND  table_name = ? AND column_name = ?)";
+            try (PreparedStatement prep = connection.prepareStatement(sql)) {
+                for (String field : fieldNames) {
+                    prep.setString(1, mariadbContainer.getDatabaseName());
+                    prep.setString(2, removeQuotes(tableName));
+                    prep.setString(3, removeQuotes(field));
+                    ResultSet rs = prep.executeQuery();
+                    if (!rs.next() || !rs.getBoolean(1)) return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    private static String removeQuotes(String field) {
+        return field.charAt(0) == '`' ? field.substring(1, field.length() - 1) : field;
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingIndexedStoreTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingIndexedStoreTest.java
new file mode 100644
index 00000000000..0d7c7cc0256
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingIndexedStoreTest.java
@@ -0,0 +1,48 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static org.testcontainers.shaded.org.apache.commons.lang3.RandomUtils.nextInt;
+
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.EmbeddingStoreWithFilteringIT;
+import org.junit.jupiter.api.BeforeAll;
+import org.testcontainers.containers.MariaDBContainer;
+
+class MariaDbEmbeddingIndexedStoreTest extends EmbeddingStoreWithFilteringIT {
+
+    private final EmbeddingModel embeddingModel = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    private EmbeddingStore<TextSegment> embeddingStore;
+
+    static MariaDBContainer<?> mariadbContainer = MariaDbTests.defaultContainer;
+
+    @BeforeAll
+    public static void beforeAll() {
+        mariadbContainer.start();
+    }
+
+    @Override
+    protected void ensureStoreIsReady() {
+        embeddingStore = MariaDbEmbeddingStore.builder()
+                .url(mariadbContainer.getJdbcUrl())
+                .user(mariadbContainer.getUsername())
+                .password(mariadbContainer.getPassword())
+                .table("test" + nextInt(1, 1000))
+                .createTable(true)
+                .dimension(embeddingModel.dimension())
+                .dropTableFirst(true)
+                .build();
+    }
+
+    @Override
+    protected EmbeddingStore<TextSegment> embeddingStore() {
+        return embeddingStore;
+    }
+
+    @Override
+    protected EmbeddingModel embeddingModel() {
+        return embeddingModel;
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreConfigTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreConfigTest.java
new file mode 100644
index 00000000000..88e3191204f
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreConfigTest.java
@@ -0,0 +1,79 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.EmbeddingStoreWithFilteringIT;
+import java.sql.SQLException;
+import org.junit.jupiter.api.AfterAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.mariadb.jdbc.MariaDbPoolDataSource;
+import org.testcontainers.containers.MariaDBContainer;
+
+abstract class MariaDbEmbeddingStoreConfigTest extends EmbeddingStoreWithFilteringIT {
+    static MariaDBContainer<?> mariadbContainer = MariaDbTests.defaultContainer;
+
+    static EmbeddingStore<TextSegment> embeddingStore;
+
+    EmbeddingModel embeddingModel = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    static MariaDbPoolDataSource dataSource;
+
+    static final String TABLE_NAME = "test";
+    static final int TABLE_DIMENSION = 384;
+
+    static void configureStore(MetadataStorageConfig config) {
+        mariadbContainer.start();
+        String jdbcUrl = "%s?useBulkStmtsForInserts=false&connectionCollation=utf8mb4_bin&user=%s&password=%s"
+                .formatted(
+                        mariadbContainer.getJdbcUrl(), mariadbContainer.getUsername(), mariadbContainer.getPassword());
+        try {
+            dataSource = new MariaDbPoolDataSource(jdbcUrl);
+            embeddingStore = MariaDbEmbeddingStore.builder()
+                    .datasource(dataSource)
+                    .table(TABLE_NAME)
+                    .dimension(TABLE_DIMENSION)
+                    .createTable(true)
+                    .dropTableFirst(true)
+                    .metadataStorageConfig(config)
+                    .build();
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @AfterAll
+    static void afterAll() {
+        dataSource.close();
+    }
+
+    @BeforeEach
+    void beforeEach() {
+        try (var connection = dataSource.getConnection()) {
+            connection.createStatement().executeUpdate("TRUNCATE TABLE %s".formatted(TABLE_NAME));
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    protected void ensureStoreIsEmpty() {
+        // it's not necessary to clear the store before every test
+    }
+
+    @Override
+    protected EmbeddingStore<TextSegment> embeddingStore() {
+        return embeddingStore;
+    }
+
+    @Override
+    protected EmbeddingModel embeddingModel() {
+        return embeddingModel;
+    }
+
+    @Override
+    protected boolean testFloatExactly() {
+        return false;
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreRemovalTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreRemovalTest.java
new file mode 100644
index 00000000000..ca2ab1a411a
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreRemovalTest.java
@@ -0,0 +1,42 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static org.testcontainers.shaded.org.apache.commons.lang3.RandomUtils.nextInt;
+
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.EmbeddingStoreWithRemovalIT;
+import org.junit.jupiter.api.BeforeAll;
+import org.testcontainers.containers.MariaDBContainer;
+
+class MariaDbEmbeddingStoreRemovalTest extends EmbeddingStoreWithRemovalIT {
+    static MariaDBContainer<?> mariadbContainer = MariaDbTests.defaultContainer;
+
+    final EmbeddingStore<TextSegment> embeddingStore = MariaDbEmbeddingStore.builder()
+            .url(mariadbContainer.getJdbcUrl())
+            .user(mariadbContainer.getUsername())
+            .password(mariadbContainer.getPassword())
+            .table("test" + nextInt(2000, 3000))
+            .dimension(384)
+            .createTable(true)
+            .dropTableFirst(true)
+            .build();
+
+    final EmbeddingModel embeddingModel = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    @BeforeAll
+    public static void beforeAll() {
+        mariadbContainer.start();
+    }
+
+    @Override
+    protected EmbeddingStore<TextSegment> embeddingStore() {
+        return embeddingStore;
+    }
+
+    @Override
+    protected EmbeddingModel embeddingModel() {
+        return embeddingModel;
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreTest.java
new file mode 100644
index 00000000000..a979c814275
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreTest.java
@@ -0,0 +1,46 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static org.testcontainers.shaded.org.apache.commons.lang3.RandomUtils.nextInt;
+
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import dev.langchain4j.store.embedding.EmbeddingStoreWithFilteringIT;
+import org.junit.jupiter.api.BeforeAll;
+import org.testcontainers.containers.MariaDBContainer;
+
+class MariaDbEmbeddingStoreTest extends EmbeddingStoreWithFilteringIT {
+
+    static MariaDBContainer<?> mariadbContainer = MariaDbTests.defaultContainer;
+    final EmbeddingModel embeddingModel = new AllMiniLmL6V2QuantizedEmbeddingModel();
+    EmbeddingStore<TextSegment> embeddingStore;
+
+    @BeforeAll
+    public static void beforeAll() {
+        mariadbContainer.start();
+    }
+
+    @Override
+    protected void ensureStoreIsReady() {
+        embeddingStore = MariaDbEmbeddingStore.builder()
+                .url(mariadbContainer.getJdbcUrl())
+                .user(mariadbContainer.getUsername())
+                .password(mariadbContainer.getPassword())
+                .table("test" + nextInt(1000, 2000))
+                .dimension(384)
+                .createTable(true)
+                .dropTableFirst(true)
+                .build();
+    }
+
+    @Override
+    protected EmbeddingStore<TextSegment> embeddingStore() {
+        return embeddingStore;
+    }
+
+    @Override
+    protected EmbeddingModel embeddingModel() {
+        return embeddingModel;
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreUpgradeTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreUpgradeTest.java
new file mode 100644
index 00000000000..e54c94b9df7
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreUpgradeTest.java
@@ -0,0 +1,115 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import static org.assertj.core.api.Assertions.assertThat;
+import static org.assertj.core.data.Percentage.withPercentage;
+import static org.testcontainers.shaded.org.apache.commons.lang3.RandomUtils.nextInt;
+
+import dev.langchain4j.data.segment.TextSegment;
+import dev.langchain4j.model.embedding.EmbeddingModel;
+import dev.langchain4j.model.embedding.onnx.allminilml6v2q.AllMiniLmL6V2QuantizedEmbeddingModel;
+import dev.langchain4j.store.embedding.EmbeddingSearchRequest;
+import dev.langchain4j.store.embedding.EmbeddingSearchResult;
+import dev.langchain4j.store.embedding.EmbeddingStore;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.BeforeEach;
+import org.junit.jupiter.api.Test;
+import org.testcontainers.containers.MariaDBContainer;
+
+/**
+ * Test upgrade from 029 to latest version
+ */
+class MariaDbEmbeddingStoreUpgradeTest {
+    static MariaDBContainer<?> mariadbContainer = MariaDbTests.defaultContainer;
+
+    EmbeddingStore<TextSegment> embeddingStore029;
+
+    EmbeddingStore<TextSegment> embeddingStore;
+
+    private final EmbeddingModel embeddingModel = new AllMiniLmL6V2QuantizedEmbeddingModel();
+
+    @BeforeAll
+    public static void beforeAll() {
+        mariadbContainer.start();
+    }
+
+    @BeforeEach
+    void beforeEach() {
+        final var tableName = "test" + nextInt(3000, 4000);
+        embeddingStore029 = MariaDbEmbeddingStore.builder()
+                .url(mariadbContainer.getJdbcUrl())
+                .user(mariadbContainer.getUsername())
+                .password(mariadbContainer.getPassword())
+                .table(tableName)
+                .dimension(384)
+                .createTable(true)
+                .dropTableFirst(true)
+                .build();
+
+        embeddingStore = MariaDbEmbeddingStore.builder()
+                .url(mariadbContainer.getJdbcUrl())
+                .user(mariadbContainer.getUsername())
+                .password(mariadbContainer.getPassword())
+                .table(tableName)
+                .createTable(true)
+                .dimension(384)
+                .build();
+    }
+
+    @Test
+    void upgrade() {
+        var embedding = embeddingModel.embed("hello").content();
+
+        var id = embeddingStore029.add(embedding);
+        assertThat(id).isNotBlank();
+
+        // Check 029 results
+        EmbeddingSearchRequest embeddingSearchRequest = EmbeddingSearchRequest.builder()
+                .queryEmbedding(embedding)
+                .maxResults(10)
+                .minScore(0.0)
+                .build();
+        EmbeddingSearchResult<?> embeddingSearchResult = embeddingStore029.search(embeddingSearchRequest);
+        var relevant = embeddingSearchResult.matches();
+        assertThat(relevant).hasSize(1);
+
+        var match = relevant.get(0);
+        assertThat(match.score()).isCloseTo(1, withPercentage(1));
+        assertThat(match.embeddingId()).isEqualTo(id);
+        assertThat(match.embedding()).isEqualTo(embedding);
+        assertThat(match.embedded()).isNull();
+
+        // new API
+        assertThat(embeddingStore029
+                        .search(EmbeddingSearchRequest.builder()
+                                .queryEmbedding(embedding)
+                                .maxResults(10)
+                                .build())
+                        .matches())
+                .isEqualTo(relevant);
+
+        // Check Latest Store results
+        EmbeddingSearchRequest embeddingSearchRequest2 = EmbeddingSearchRequest.builder()
+                .queryEmbedding(embedding)
+                .maxResults(10)
+                .minScore(0.0)
+                .build();
+        EmbeddingSearchResult<?> embeddingSearchResult2 = embeddingStore.search(embeddingSearchRequest2);
+        var relevant2 = embeddingSearchResult2.matches();
+        assertThat(relevant2).hasSize(1);
+
+        match = relevant.get(0);
+        assertThat(match.score()).isCloseTo(1, withPercentage(1));
+        assertThat(match.embeddingId()).isEqualTo(id);
+        assertThat(match.embedding()).isEqualTo(embedding);
+        assertThat(match.embedded()).isNull();
+
+        // new API
+        assertThat(embeddingStore
+                        .search(EmbeddingSearchRequest.builder()
+                                .queryEmbedding(embedding)
+                                .maxResults(10)
+                                .build())
+                        .matches())
+                .isEqualTo(relevant);
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreWithColumnsFilteringTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreWithColumnsFilteringTest.java
new file mode 100644
index 00000000000..084ea65ab30
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreWithColumnsFilteringTest.java
@@ -0,0 +1,47 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.util.Arrays;
+import org.junit.jupiter.api.BeforeAll;
+
+public class MariaDbEmbeddingStoreWithColumnsFilteringTest extends MariaDbEmbeddingStoreConfigTest {
+
+    @BeforeAll
+    static void beforeAllTests() {
+        MetadataStorageConfig config = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COLUMN_PER_KEY)
+                .columnDefinitions(Arrays.asList(
+                        "key varchar(255)",
+                        "`name` varchar(255)",
+                        "`age` float",
+                        "city text",
+                        "country varchar(255)",
+                        "string_empty varchar(255)",
+                        "string_space varchar(255)",
+                        "string_abc varchar(255)",
+                        "uuid uuid",
+                        "integer_min int",
+                        "integer_minus_1 int",
+                        "integer_0 int",
+                        "integer_1 int",
+                        "integer_max int",
+                        "long_min bigint",
+                        "long_minus_1 bigint",
+                        "long_0 bigint",
+                        "long_1 bigint",
+                        "long_1746714878034235396 bigint",
+                        "long_max bigint",
+                        "float_min double",
+                        "float_minus_1 double",
+                        "float_0 double",
+                        "float_1 double",
+                        "float_123 double",
+                        "float_max double",
+                        "double_minus_1 double",
+                        "double_0 double",
+                        "double_1 double",
+                        "double_123 double"))
+                .indexes(Arrays.asList("key", "name", "age"))
+                .build();
+        configureStore(config);
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreWithJSONFilteringTest.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreWithJSONFilteringTest.java
new file mode 100644
index 00000000000..a81a4638aff
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbEmbeddingStoreWithJSONFilteringTest.java
@@ -0,0 +1,15 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import java.util.Collections;
+import org.junit.jupiter.api.BeforeAll;
+
+public class MariaDbEmbeddingStoreWithJSONFilteringTest extends MariaDbEmbeddingStoreConfigTest {
+    @BeforeAll
+    static void beforeAllTests() {
+        MetadataStorageConfig config = DefaultMetadataStorageConfig.builder()
+                .storageMode(MetadataStorageMode.COMBINED_JSON)
+                .columnDefinitions(Collections.singletonList("metadata JSON NULL"))
+                .build();
+        configureStore(config);
+    }
+}
diff --git a/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbTests.java b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbTests.java
new file mode 100644
index 00000000000..ee4e5ff4dcd
--- /dev/null
+++ b/langchain4j-mariadb/src/test/java/dev/langchain4j/store/embedding/mariadb/MariaDbTests.java
@@ -0,0 +1,10 @@
+package dev.langchain4j.store.embedding.mariadb;
+
+import org.testcontainers.containers.MariaDBContainer;
+import org.testcontainers.utility.DockerImageName;
+
+public class MariaDbTests {
+    private static final DockerImageName DEFAULT_IMAGE = DockerImageName.parse("mariadb:11.7-rc");
+
+    static final MariaDBContainer<?> defaultContainer = new MariaDBContainer<>(DEFAULT_IMAGE).withReuse(true);
+}
diff --git a/langchain4j-mariadb/src/test/resources/logback-test.xml b/langchain4j-mariadb/src/test/resources/logback-test.xml
new file mode 100644
index 00000000000..83ef7a1a3ef
--- /dev/null
+++ b/langchain4j-mariadb/src/test/resources/logback-test.xml
@@ -0,0 +1,16 @@
+<configuration>
+
+    <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
+        <!-- encoders are assigned the type
+             ch.qos.logback.classic.encoder.PatternLayoutEncoder by default -->
+        <encoder>
+            <pattern>%d{HH:mm:ss.SSS} %-5level %logger - %msg%n</pattern>
+        </encoder>
+    </appender>
+
+    <root level="INFO">
+        <appender-ref ref="STDOUT"/>
+    </root>
+
+    <logger name="org.testcontainers" level="INFO"/>
+</configuration>
diff --git a/pom.xml b/pom.xml
index 8fffb5a1cf4..ff6e740cb51 100644
--- a/pom.xml
+++ b/pom.xml
@@ -48,6 +48,7 @@
         <module>langchain4j-couchbase</module>
         <module>langchain4j-elasticsearch</module>
         <module>langchain4j-infinispan</module>
+        <module>langchain4j-mariadb</module>
         <module>langchain4j-milvus</module>
         <module>langchain4j-mongodb-atlas</module>
         <module>langchain4j-neo4j</module>
