diff --git a/.github/.cspell/gamedev_dictionary.txt b/.github/.cspell/gamedev_dictionary.txt
index 734bdf43c4d..a50a60423b4 100644
--- a/.github/.cspell/gamedev_dictionary.txt
+++ b/.github/.cspell/gamedev_dictionary.txt
@@ -23,6 +23,7 @@ goldens # test files used as reference for Golden Tests
 hitbox # the collision box around objects for the purposes of collision detection
 hitboxes # plural of hitbox
 ints # short for integers
+impellerc # Flutter's impeller compiler
 jank # stutter or inconsistent gap or timing
 lerp # short for linear interpolation
 LTRB # left top right bottom
@@ -48,8 +49,11 @@ respawn # when the player character dies and is brought back after some time and
 retarget # to direct (something) toward a different target
 RGBA # red green blue alpha
 RGBO # red green blue opacity
+BGRA # blue green red alpha
 rrect # rounded rect
 scos # cosine of a rotation multiplied by the scale factor
+shaderbundle # a file extension used to bundle shaders for GLSL
+slerp # short for spherical linear interpolation, a method to interpolate quaternions
 spritesheet # a single image packing multiple sprites, normally in a grid
 ssin # sine of a rotation multiplied by the scale factor
 stylesheet # name of a CSS style file
@@ -57,6 +61,7 @@ subfolders # plural of subfolders
 sublist # any sub-set of elements of a given list
 sublists # plural of sublist
 subrange # a range entirely contained on a given range
+struct # a type of data model in programming that aggregates fields
 SVGs # plural of SVG
 tileset # image with a collection of tiles. in games, tiles are small square sprites laid out in a grid to form the game map
 tilesets # plural of tileset
diff --git a/.github/.cspell/people_usernames.txt b/.github/.cspell/people_usernames.txt
index 7bfcc866e73..1e3bb244abc 100644
--- a/.github/.cspell/people_usernames.txt
+++ b/.github/.cspell/people_usernames.txt
@@ -1,5 +1,6 @@
 # specific people's names and/or usernames
 akida # github.com/akida 
+bdero # github.com/bdero
 bluefireteam # github.com/bluefireteam
 erayzesen # erayzesen.itch.io
 erickzanardo # github.com/erickzanardo 
@@ -19,3 +20,4 @@ tavian # tavianator.com
 videon # github.com/markvideon
 wolfenrain # github.com/wolfenrain
 xaha # github.com/xvrh
+luan # github.com/luanpotter
\ No newline at end of file
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 6d8fa0b56b2..92e8dc24513 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -3,6 +3,66 @@
 All notable changes to this project will be documented in this file.
 See [Conventional Commits](https://conventionalcommits.org) for commit guidelines.
 
+## 2024-12-10
+
+### Changes
+
+---
+
+Packages with breaking changes:
+
+ - There are no breaking changes in this release.
+
+Packages with other changes:
+
+ - [`flame_3d` - `v0.1.0-dev.3`](#flame_3d---v010-dev3)
+
+---
+
+#### `flame_3d` - `v0.1.0-dev.3`
+
+ - **FIX**: Improve behavior of Quaternion.slerp function [flame_3d] ([#3306](https://github.com/flame-engine/flame/issues/3306)). ([b9d6a0f1](https://github.com/flame-engine/flame/commit/b9d6a0f1d34e009cd91ae9d2ab0eed09b546d110))
+ - **DOCS**: Update README.md docs to reflect current state of affairs ([#3305](https://github.com/flame-engine/flame/issues/3305)). ([be72daee](https://github.com/flame-engine/flame/commit/be72daee6b92bcef2af3af78c1f64abe94c49d18))
+
+
+## 2024-12-10
+
+### Changes
+
+---
+
+Packages with breaking changes:
+
+ - There are no breaking changes in this release.
+
+Packages with other changes:
+
+ - [`flame_3d` - `v0.1.0-dev.2`](#flame_3d---v010-dev2)
+
+---
+
+#### `flame_3d` - `v0.1.0-dev.2`
+
+ - **FIX**: Improve quaternion slerp logic to avoid NaN edge cases ([#3303](https://github.com/flame-engine/flame/issues/3303)). ([565b68b9](https://github.com/flame-engine/flame/commit/565b68b9da52d44281e93f9ae8617f9dbe9551f3))
+ - **FIX**: MeshComponent.bind should bind to the provided device ([#3278](https://github.com/flame-engine/flame/issues/3278)). ([3ae3ef54](https://github.com/flame-engine/flame/commit/3ae3ef5476fa5f9ead7069efeee35cc31c0e9dd2))
+ - **FIX**: Add missing export for CylinderMesh [flame_3d] ([#3256](https://github.com/flame-engine/flame/issues/3256)). ([d517c169](https://github.com/flame-engine/flame/commit/d517c169ed9b4d4457df6ac1ae363277577597fa))
+ - **FIX**: Fix typo on loadTexture ([#3253](https://github.com/flame-engine/flame/issues/3253)). ([3a20a8cd](https://github.com/flame-engine/flame/commit/3a20a8cd61543aad21c1015de5c31ec1cbe71aed))
+ - **FIX**: Use saner default value for camera's target ([#3238](https://github.com/flame-engine/flame/issues/3238)). ([78522c62](https://github.com/flame-engine/flame/commit/78522c624d846c827a1c0d7377837e04a30ba4e7))
+ - **FIX**: Revert "feat(flame_3d): initial implementation of 3D support" ([#3060](https://github.com/flame-engine/flame/issues/3060)). ([741d9384](https://github.com/flame-engine/flame/commit/741d9384dbfea7bb692f181a7689a7b10a947ef0))
+ - **FEAT**: Support skeletal animation basics [flame_3d]  ([#3291](https://github.com/flame-engine/flame/issues/3291)). ([12927e41](https://github.com/flame-engine/flame/commit/12927e4100a7b4b46e4218db6792d25be1623f88))
+ - **FEAT**: Add more useful extensions to VectorN and Quaternion [flame_3d] ([#3296](https://github.com/flame-engine/flame/issues/3296)). ([9cb95279](https://github.com/flame-engine/flame/commit/9cb9527909a4faa38609d25ebd7463f1e2e1a1ab))
+ - **FEAT**: More Lights! [flame_3d] ([#3250](https://github.com/flame-engine/flame/issues/3250)). ([1780630e](https://github.com/flame-engine/flame/commit/1780630e7fcb386a331ba1219c15cb1ae8b139e6))
+ - **FEAT**: Add normals to surfaces when not specified ([#3257](https://github.com/flame-engine/flame/issues/3257)). ([844c1d72](https://github.com/flame-engine/flame/commit/844c1d726e04e9c3c5739214720cf26fc62d3f9f))
+ - **FEAT**: Add CylinderMesh [flame_3d] ([#3239](https://github.com/flame-engine/flame/issues/3239)). ([01872fb6](https://github.com/flame-engine/flame/commit/01872fb6e45e10dc380fee7a176a8b37eeaef880))
+ - **FEAT**(flame_3d): Make shader api more useful ([#3085](https://github.com/flame-engine/flame/issues/3085)). ([fe2e4f20](https://github.com/flame-engine/flame/commit/fe2e4f20195b453268b34e589616343fdce6201a))
+ - **FEAT**: Make it easier work with the Mesh class [flame_3d] ([#3212](https://github.com/flame-engine/flame/issues/3212)). ([ebf2ee62](https://github.com/flame-engine/flame/commit/ebf2ee62e535fd1d0f499112b314e1d88e59bbc1))
+ - **FEAT**: Expose vector classes on core file [flame_3d] ([#3211](https://github.com/flame-engine/flame/issues/3211)). ([c3e68dff](https://github.com/flame-engine/flame/commit/c3e68dffd2e53a8dc8d4d3804c47e956dfc0ebb4))
+ - **FEAT**(flame_3d): Add helpful extension functions to Vector ([#3141](https://github.com/flame-engine/flame/issues/3141)). ([92195989](https://github.com/flame-engine/flame/commit/9219598904131d8fceba8d1ad980bea2805e3515))
+ - **FEAT**(flame_3d): Fix minor nits on flame_3d ([#3140](https://github.com/flame-engine/flame/issues/3140)). ([11cdfb5e](https://github.com/flame-engine/flame/commit/11cdfb5ebeb62dd1aec2d51fd7fadfbfb17c6da5))
+ - **FEAT**(flame_3d): initial implementation of 3D support ([#3012](https://github.com/flame-engine/flame/issues/3012)). ([0242e1dd](https://github.com/flame-engine/flame/commit/0242e1dd12a9b50a411d895b662f9df33536f6d9))
+ - **FEAT**(flame_3d): initial implementation of 3D support ([#3012](https://github.com/flame-engine/flame/issues/3012)). ([e434bafb](https://github.com/flame-engine/flame/commit/e434bafb15fc486c51b43aaa9d9190b8b7e783cb))
+ - **DOCS**: Update docs and comments (flame_3d) ([#3057](https://github.com/flame-engine/flame/issues/3057)). ([14047879](https://github.com/flame-engine/flame/commit/14047879a13e1f13e51ce3411feb7c7962d6d7ee))
+
 ## 2024-11-24
 
 ### Changes
diff --git a/packages/flame_3d/.metadata b/packages/flame_3d/.metadata
new file mode 100644
index 00000000000..18428991e0b
--- /dev/null
+++ b/packages/flame_3d/.metadata
@@ -0,0 +1,10 @@
+# This file tracks properties of this Flutter project.
+# Used by Flutter tool to assess capabilities and perform upgrades etc.
+#
+# This file should be version controlled and should not be manually edited.
+
+version:
+  revision: "1b197762c51e993cb77d7fafe9729ef2506e2bf7"
+  channel: "beta"
+
+project_type: package
diff --git a/packages/flame_3d/CHANGELOG.md b/packages/flame_3d/CHANGELOG.md
new file mode 100644
index 00000000000..956107fedd4
--- /dev/null
+++ b/packages/flame_3d/CHANGELOG.md
@@ -0,0 +1,30 @@
+## 0.1.0-dev.3
+
+ - **FIX**: Improve behavior of Quaternion.slerp function [flame_3d] ([#3306](https://github.com/flame-engine/flame/issues/3306)). ([b9d6a0f1](https://github.com/flame-engine/flame/commit/b9d6a0f1d34e009cd91ae9d2ab0eed09b546d110))
+ - **DOCS**: Update README.md docs to reflect current state of affairs ([#3305](https://github.com/flame-engine/flame/issues/3305)). ([be72daee](https://github.com/flame-engine/flame/commit/be72daee6b92bcef2af3af78c1f64abe94c49d18))
+
+## 0.1.0-dev.2
+
+ - **FIX**: Improve quaternion slerp logic to avoid NaN edge cases ([#3303](https://github.com/flame-engine/flame/issues/3303)). ([565b68b9](https://github.com/flame-engine/flame/commit/565b68b9da52d44281e93f9ae8617f9dbe9551f3))
+ - **FIX**: MeshComponent.bind should bind to the provided device ([#3278](https://github.com/flame-engine/flame/issues/3278)). ([3ae3ef54](https://github.com/flame-engine/flame/commit/3ae3ef5476fa5f9ead7069efeee35cc31c0e9dd2))
+ - **FIX**: Add missing export for CylinderMesh [flame_3d] ([#3256](https://github.com/flame-engine/flame/issues/3256)). ([d517c169](https://github.com/flame-engine/flame/commit/d517c169ed9b4d4457df6ac1ae363277577597fa))
+ - **FIX**: Fix typo on loadTexture ([#3253](https://github.com/flame-engine/flame/issues/3253)). ([3a20a8cd](https://github.com/flame-engine/flame/commit/3a20a8cd61543aad21c1015de5c31ec1cbe71aed))
+ - **FIX**: Use saner default value for camera's target ([#3238](https://github.com/flame-engine/flame/issues/3238)). ([78522c62](https://github.com/flame-engine/flame/commit/78522c624d846c827a1c0d7377837e04a30ba4e7))
+ - **FIX**: Revert "feat(flame_3d): initial implementation of 3D support" ([#3060](https://github.com/flame-engine/flame/issues/3060)). ([741d9384](https://github.com/flame-engine/flame/commit/741d9384dbfea7bb692f181a7689a7b10a947ef0))
+ - **FEAT**: Support skeletal animation basics [flame_3d]  ([#3291](https://github.com/flame-engine/flame/issues/3291)). ([12927e41](https://github.com/flame-engine/flame/commit/12927e4100a7b4b46e4218db6792d25be1623f88))
+ - **FEAT**: Add more useful extensions to VectorN and Quaternion [flame_3d] ([#3296](https://github.com/flame-engine/flame/issues/3296)). ([9cb95279](https://github.com/flame-engine/flame/commit/9cb9527909a4faa38609d25ebd7463f1e2e1a1ab))
+ - **FEAT**: More Lights! [flame_3d] ([#3250](https://github.com/flame-engine/flame/issues/3250)). ([1780630e](https://github.com/flame-engine/flame/commit/1780630e7fcb386a331ba1219c15cb1ae8b139e6))
+ - **FEAT**: Add normals to surfaces when not specified ([#3257](https://github.com/flame-engine/flame/issues/3257)). ([844c1d72](https://github.com/flame-engine/flame/commit/844c1d726e04e9c3c5739214720cf26fc62d3f9f))
+ - **FEAT**: Add CylinderMesh [flame_3d] ([#3239](https://github.com/flame-engine/flame/issues/3239)). ([01872fb6](https://github.com/flame-engine/flame/commit/01872fb6e45e10dc380fee7a176a8b37eeaef880))
+ - **FEAT**(flame_3d): Make shader api more useful ([#3085](https://github.com/flame-engine/flame/issues/3085)). ([fe2e4f20](https://github.com/flame-engine/flame/commit/fe2e4f20195b453268b34e589616343fdce6201a))
+ - **FEAT**: Make it easier work with the Mesh class [flame_3d] ([#3212](https://github.com/flame-engine/flame/issues/3212)). ([ebf2ee62](https://github.com/flame-engine/flame/commit/ebf2ee62e535fd1d0f499112b314e1d88e59bbc1))
+ - **FEAT**: Expose vector classes on core file [flame_3d] ([#3211](https://github.com/flame-engine/flame/issues/3211)). ([c3e68dff](https://github.com/flame-engine/flame/commit/c3e68dffd2e53a8dc8d4d3804c47e956dfc0ebb4))
+ - **FEAT**(flame_3d): Add helpful extension functions to Vector ([#3141](https://github.com/flame-engine/flame/issues/3141)). ([92195989](https://github.com/flame-engine/flame/commit/9219598904131d8fceba8d1ad980bea2805e3515))
+ - **FEAT**(flame_3d): Fix minor nits on flame_3d ([#3140](https://github.com/flame-engine/flame/issues/3140)). ([11cdfb5e](https://github.com/flame-engine/flame/commit/11cdfb5ebeb62dd1aec2d51fd7fadfbfb17c6da5))
+ - **FEAT**(flame_3d): initial implementation of 3D support ([#3012](https://github.com/flame-engine/flame/issues/3012)). ([0242e1dd](https://github.com/flame-engine/flame/commit/0242e1dd12a9b50a411d895b662f9df33536f6d9))
+ - **FEAT**(flame_3d): initial implementation of 3D support ([#3012](https://github.com/flame-engine/flame/issues/3012)). ([e434bafb](https://github.com/flame-engine/flame/commit/e434bafb15fc486c51b43aaa9d9190b8b7e783cb))
+ - **DOCS**: Update docs and comments (flame_3d) ([#3057](https://github.com/flame-engine/flame/issues/3057)). ([14047879](https://github.com/flame-engine/flame/commit/14047879a13e1f13e51ce3411feb7c7962d6d7ee))
+
+## 0.1.0-dev.1
+
+- Initial experimental release of `flame_3d`.
diff --git a/packages/flame_3d/CONTRIBUTING.md b/packages/flame_3d/CONTRIBUTING.md
new file mode 100644
index 00000000000..ca74d6d7b18
--- /dev/null
+++ b/packages/flame_3d/CONTRIBUTING.md
@@ -0,0 +1,53 @@
+# Contribution Guidelines
+
+Read the main [Flame Contribution Guidelines](https://github.com/flame-engine/flame/blob/main/CONTRIBUTING.md)
+first and then come back to this one.
+
+
+## How To Contribute
+
+
+### Environment Setup
+
+First follow the steps described in the main [Flame Contribution Guidelines](https://github.com/flame-engine/flame/blob/main/CONTRIBUTING.md#environment-setup)
+
+After you have followed those steps you have to setup Flutter to use the specific build that this
+package is built against:
+
+```sh
+cd $(dirname $(which flutter)) \
+  && git fetch \
+  && git checkout bcdd1b2c481bca0647beff690238efaae68ca5ac -q \
+  && echo "Engine commit: $(cat internal/engine.version)" \
+  && cd - >/dev/null
+```
+
+This will check out the GIT repo of your Flutter installation to the specific commit that we require
+and also gets us the commit SHA of the Flutter Engine that you need to use in setting up the
+Flutter GPU. For that you can follow the steps described in the
+[Flutter Wiki](https://github.com/flutter/flutter/wiki/Flutter-GPU#try-out-flutter-gpu).
+
+Once you have cloned the Flutter engine you can add the `flutter_gpu` as an override dependency
+to the `pubspec_overrides.yaml` file in the `flame_3d` directory and it's example:
+
+```yaml
+dependency_overrides:
+  ... # Melos related overrides
+  flutter_gpu:
+    path: <path_to_the_cloned_flutter_engine_directory>/lib/gpu
+```
+
+After all of that you should run `flutter pub get` one more time to ensure all dependencies are
+set up correctly.
+
+
+### Shader changes
+
+If you have added/changed/removed any of the shaders in the `shaders` directory make sure to run the
+build script for shaders:
+
+```sh
+dart bin/build_shaders.dart
+```
+
+This is currently a manual process until Flutter provides bundling support.
diff --git a/packages/flame_3d/LICENSE b/packages/flame_3d/LICENSE
new file mode 100644
index 00000000000..f7831247594
--- /dev/null
+++ b/packages/flame_3d/LICENSE
@@ -0,0 +1,22 @@
+MIT License
+
+Copyright (c) 2024 Blue Fire
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
+
diff --git a/packages/flame_3d/README.md b/packages/flame_3d/README.md
new file mode 100644
index 00000000000..a06680f6960
--- /dev/null
+++ b/packages/flame_3d/README.md
@@ -0,0 +1,122 @@
+<!-- markdownlint-disable MD013 -->
+<p align="center">
+  <a href="https://flame-engine.org">
+    <img alt="flame" width="200px" src="https://user-images.githubusercontent.com/6718144/101553774-3bc7b000-39ad-11eb-8a6a-de2daa31bd64.png">
+  </a>
+</p>
+
+<p align="center">
+Adds 3D support for <a href="https://github.com/flame-engine/flame">Flame</a> using the <a href="https://github.com/flutter/flutter/wiki/Flutter-GPU">Flutter GPU</a>.
+</p>
+
+<p align="center">
+  <a title="Pub" href="https://pub.dev/packages/flame_3d" ><img src="https://img.shields.io/pub/v/flame_3d.svg?style=popout" /></a>
+  <a title="Test" href="https://github.com/flame-engine/flame/actions?query=workflow%3Acicd+branch%3Amain"><img src="https://github.com/flame-engine/flame/workflows/cicd/badge.svg?branch=main&event=push"/></a>
+  <a title="Discord" href="https://discord.gg/pxrBmy4"><img src="https://img.shields.io/discord/509714518008528896.svg"/></a>
+  <a title="Melos" href="https://github.com/invertase/melos"><img src="https://img.shields.io/badge/maintained%20with-melos-f700ff.svg"/></a>
+</p>
+
+---
+<!-- markdownlint-enable MD013 -->
+
+<!-- markdownlint-disable-next-line MD002 -->
+# flame_3d
+
+This package provides an experimental implementation of 3D support for Flame. The main focus is to
+explore the potential capabilities of 3D for Flame while providing a familiar API to existing Flame
+developers.
+
+Supported platforms:
+
+| Platform | Supported |
+| -------- | --------- |
+| Android  | ❌        |
+| iOS      | ❌        |
+| macOS    | ✅        |
+| Windows  | ❌        |
+| Linux    | ❌        |
+| Web      | ❌        |
+
+
+## Prologue
+
+**STOP**, we know you are hyped up and want to start coding some funky 3D stuff but we first have to
+set your expectations and clarify some things. So turn down your music, put away the coffee and make
+some tea instead because you have to do some reading first!
+
+This package provides 3D support for Flame but it depends on the still experimental
+[Flutter GPU](https://github.com/flutter/flutter/wiki/Flutter-GPU), which in turn depends on
+Impeller.
+
+Because of that, this package is also highly experimental. Our long term goal is to
+eventually merge this branch into Flame's `main`, but we currently need to depend on Flutter's `main`
+(Flame depends on `stable`). For more information on this, check out our
+[Roadmap](https://github.com/flame-engine/flame/blob/main/packages/flame_3d/ROADMAP.md).
+
+This package does not guarantee that it will follow correct [semver](https://semver.org/) versioning
+rules, nor does it assure that its APIs wont break. Be ready to constantly have to refactor your
+code if you are planning on using this package, and potentially to have to contribute with
+improvements and fixes. Please do not use this for production environments.
+
+Documentation and tests might be lacking for quite a while because of the potential constant changes
+of the API. Where possible, we will try to provide in-code documentation and code examples to help
+developers but our main goal for now is to enable the usage of 3D rendering within a Flame
+ecosystem.
+
+
+## Prerequisites
+
+In order to use flame_3d, you will need to ensure a few things. First of all, you need to be on
+the `main` channel of Flutter, and on MacOS, the only currently supported platform.
+
+Then, you need to enable Impeller; to do that, add the following to the
+`Info.plist` in your `macos/` directory:
+
+```xml
+<dict>
+    ...
+ <key>FLTEnableImpeller</key>
+ <true/>
+</dict>
+```
+
+Now everything is set up you can start doing some 3D magic! You can check out the
+[example](https://github.com/flame-engine/flame/tree/main/packages/flame_3d/example) to see how you
+can set up a simple 3D environment using Flame.
+
+Also check out the [flame_3d_extras](https://github.com/luanpotter/flame_3d_extras) package for more
+utilities and helpers not yet merged into `flame_3d`.
+
+
+## Building shaders
+
+If you are using the `SpatialMaterial` provided by `flame_3d`, you do not need to worry about shaders.
+
+That being said, you can write your own shaders and use them on custom materials.
+Currently, Flutter does not do the bundling of shaders for us so this package provides a simple
+Dart script. Create your fragment and vertex shader in a `shaders` directory,
+make sure the file names are identical. Like so:
+
+- `my_custom_shader`.frag
+- `my_custom_shader`.vert
+
+You can then run `dart pub run flame_3d:build_shaders` to bundle the shaders. They will
+automatically be placed in `assets/shaders`.
+
+You can check out the
+[default shaders](https://github.com/flame-engine/flame/tree/main/packages/flame_3d/shaders) if you
+want to have some examples.
+
+
+## Contributing
+
+Have you found a bug or have a suggestion of how to enhance the 3D APIs? Open an issue and we will
+take a look at it as soon as possible.
+
+Do you want to contribute with a PR? PRs are always welcome, just make sure to create it from the
+correct branch (main) and follow the [checklist](.github/pull_request_template.md) which will
+appear when you open the PR.
+
+For bigger changes, or if in doubt, make sure to talk about your contribution to the team. Either
+via an issue, GitHub discussion, or reach out to the team using the
+[Discord server](https://discord.gg/pxrBmy4).
diff --git a/packages/flame_3d/ROADMAP.md b/packages/flame_3d/ROADMAP.md
new file mode 100644
index 00000000000..913c06cbf48
--- /dev/null
+++ b/packages/flame_3d/ROADMAP.md
@@ -0,0 +1,52 @@
+# Roadmap
+
+In the interest of transparency, we provide a high-level detail of the roadmap for adding 3D
+support to Flame. We hope this roadmap will help others in making plans and priorities based on the
+work we are doing and potentially contribute back to the project itself.
+
+The goal of the package can be split up into two sections, the primary goal is to provide an API for
+Flame developers so they can create 3D environments without having to learn new Flame concepts. This
+means the package will tie into the existing [FCS](https://docs.flame-engine.org/latest/flame/components.html#component)
+and provide the tools needed, like a [`CameraComponent`](https://docs.flame-engine.org/latest/flame/camera_component.html),
+`World` and similar components.
+
+In a perfect world this API does not depend or even know about the Flutter GPU, which brings us
+to our secondary goal: to abstract the Flutter GPU into an API that is user-friendly for 3D
+development. That includes simplifying things like creating render targets, setting up the color
+and depth textures and configuring depth stencils. But it also includes higher level APIs like
+geometric shapes, texture/material rendering and creating Meshes that can use those shapes and
+materials.
+
+
+## Goals
+
+
+### Abstracting the Flutter GPU into a user-friendly API for 3D
+
+- [x] Abstract the GPU setup into a class that represents the graphics device
+  - [ ] Setup binding logic for meshes, geometry and materials.
+- [ ] Provide a `Mesh` API
+  - [x] Provide `Surface`s that can hold geometric shapes.
+  - [x] Provide a `Material` API
+    - [x] Define a `Texture` API to be used with the `Material` API
+      - [x] Support images as textures
+      - [x] Support single color textures
+      - [x] Support generated textures
+    - [x] Provide a standard `Material`
+  - [ ] Support custom shaders
+    - [ ] Add a more dev friendly way to set uniforms
+  - [x] Support multiple `Material`s by defining surfaces on a mesh.
+
+
+### Providing a familiar API for developers to use 3D with Flame
+
+- [x] Use the existing `CameraComponent` API for 3D rendering
+  - [x] Provide a custom `World`
+  - [x] Support existing and custom viewports
+  - [ ] Support existing and custom viewfinders
+- [x] Create a new core component for 3D rendering (`Component3D`)
+  - [x] Implement a `Transform3D` for 3D transformations
+    - [x] Implement a notifying `Vector3` and `Quaternion` for 3D positioning and rotation
+  - [ ] Add support for gesture event callbacks
+- [x] Create a component that can show meshes (`MeshComponent`)
+  - [x] Ensure materials can be set outside of construction (in the `onLoad` for instance)
diff --git a/packages/flame_3d/analysis_options.yaml b/packages/flame_3d/analysis_options.yaml
new file mode 100644
index 00000000000..92aae2f2499
--- /dev/null
+++ b/packages/flame_3d/analysis_options.yaml
@@ -0,0 +1 @@
+include: package:flame_lint/analysis_options_with_dcm.yaml
diff --git a/packages/flame_3d/assets/shaders/spatial_material.shaderbundle b/packages/flame_3d/assets/shaders/spatial_material.shaderbundle
new file mode 100644
index 00000000000..841e7a8b93b
Binary files /dev/null and b/packages/flame_3d/assets/shaders/spatial_material.shaderbundle differ
diff --git a/packages/flame_3d/bin/build_shaders.dart b/packages/flame_3d/bin/build_shaders.dart
new file mode 100644
index 00000000000..bf5aac83902
--- /dev/null
+++ b/packages/flame_3d/bin/build_shaders.dart
@@ -0,0 +1,72 @@
+import 'dart:convert';
+import 'dart:io';
+
+/// Bundle a shader (<name>.frag & <name>.vert) into a single shader bundle and
+/// store it in the assets directory.
+///
+/// This script is just a temporary way to bundle shaders. In the long run
+/// Flutter might support auto-bundling themselves but until then we have to
+/// do it manually.
+///
+/// Note: this script should be run from the root of the package:
+/// packages/flame_3d
+void main(List<String> arguments) async {
+  final root = Directory.current;
+  final assets = Directory.fromUri(root.uri.resolve('assets/shaders'));
+  final shaders = Directory.fromUri(root.uri.resolve('shaders'));
+
+  await compute(assets, shaders);
+  if (arguments.contains('watch')) {
+    stdout.writeln('Running in watch mode');
+    shaders.watch(recursive: true).listen((event) {
+      compute(assets, shaders);
+    });
+  }
+}
+
+Future<void> compute(Directory assets, Directory shaders) async {
+  // Delete all the bundled shaders so we can replace them with new ones.
+  if (assets.existsSync()) {
+    assets.deleteSync(recursive: true);
+  }
+  // Create if not exists.
+  assets.createSync(recursive: true);
+
+  if (!shaders.existsSync()) {
+    return stderr.writeln('Missing shader directory');
+  }
+
+  // Get a list of unique shader names. Each shader should have a .frag and
+  // .vert with the same basename to be considered a bundle.
+  final uniqueShaders = shaders
+      .listSync()
+      .whereType<File>()
+      .map((f) => f.path.split('/').last.split('.').first)
+      .toSet();
+
+  for (final name in uniqueShaders) {
+    final bundle = {
+      'TextureFragment': {
+        'type': 'fragment',
+        'file': '${shaders.path}/$name.frag',
+      },
+      'TextureVertex': {
+        'type': 'vertex',
+        'file': '${shaders.path}/$name.vert',
+      },
+    };
+
+    stdout.writeln('Computing shader "$name"');
+    final result = await Process.run(impellerC, [
+      '--sl=${assets.path}/$name.shaderbundle',
+      '--shader-bundle=${jsonEncode(bundle)}',
+    ]);
+
+    if (result.exitCode != 0) {
+      return stderr.writeln(result.stderr);
+    }
+  }
+}
+
+final impellerC =
+    '${Platform.environment['FLUTTER_HOME']}/bin/cache/artifacts/engine/darwin-x64/impellerc';
diff --git a/packages/flame_3d/example/.gitignore b/packages/flame_3d/example/.gitignore
new file mode 100644
index 00000000000..79c113f9b50
--- /dev/null
+++ b/packages/flame_3d/example/.gitignore
@@ -0,0 +1,45 @@
+# Miscellaneous
+*.class
+*.log
+*.pyc
+*.swp
+.DS_Store
+.atom/
+.build/
+.buildlog/
+.history
+.svn/
+.swiftpm/
+migrate_working_dir/
+
+# IntelliJ related
+*.iml
+*.ipr
+*.iws
+.idea/
+
+# The .vscode folder contains launch configuration and tasks you configure in
+# VS Code which you may wish to be included in version control, so this line
+# is commented out by default.
+#.vscode/
+
+# Flutter/Dart/Pub related
+**/doc/api/
+**/ios/Flutter/.last_build_id
+.dart_tool/
+.flutter-plugins
+.flutter-plugins-dependencies
+.pub-cache/
+.pub/
+/build/
+
+# Symbolication related
+app.*.symbols
+
+# Obfuscation related
+app.*.map.json
+
+# Android Studio will place build artifacts here
+/android/app/debug
+/android/app/profile
+/android/app/release
diff --git a/packages/flame_3d/example/.metadata b/packages/flame_3d/example/.metadata
new file mode 100644
index 00000000000..f4bb071e916
--- /dev/null
+++ b/packages/flame_3d/example/.metadata
@@ -0,0 +1,30 @@
+# This file tracks properties of this Flutter project.
+# Used by Flutter tool to assess capabilities and perform upgrades etc.
+#
+# This file should be version controlled and should not be manually edited.
+
+version:
+  revision: "bcdd1b2c481bca0647beff690238efaae68ca5ac"
+  channel: "[user-branch]"
+
+project_type: app
+
+# Tracks metadata for the flutter migrate command
+migration:
+  platforms:
+    - platform: root
+      create_revision: bcdd1b2c481bca0647beff690238efaae68ca5ac
+      base_revision: bcdd1b2c481bca0647beff690238efaae68ca5ac
+    - platform: ios
+      create_revision: bcdd1b2c481bca0647beff690238efaae68ca5ac
+      base_revision: bcdd1b2c481bca0647beff690238efaae68ca5ac
+
+  # User provided section
+
+  # List of Local paths (relative to this file) that should be
+  # ignored by the migrate tool.
+  #
+  # Files that are not part of the templates will be ignored by default.
+  unmanaged_files:
+    - 'lib/main.dart'
+    - 'ios/Runner.xcodeproj/project.pbxproj'
diff --git a/packages/flame_3d/example/README.md b/packages/flame_3d/example/README.md
new file mode 100644
index 00000000000..70b4e1d1456
--- /dev/null
+++ b/packages/flame_3d/example/README.md
@@ -0,0 +1,3 @@
+# flame_3d example
+
+An example for using the `flame_3d` package.
diff --git a/packages/flame_3d/example/analysis_options.yaml b/packages/flame_3d/example/analysis_options.yaml
new file mode 100644
index 00000000000..92aae2f2499
--- /dev/null
+++ b/packages/flame_3d/example/analysis_options.yaml
@@ -0,0 +1 @@
+include: package:flame_lint/analysis_options_with_dcm.yaml
diff --git a/packages/flame_3d/example/assets/images/crate.jpg b/packages/flame_3d/example/assets/images/crate.jpg
new file mode 100644
index 00000000000..eaebeba1786
Binary files /dev/null and b/packages/flame_3d/example/assets/images/crate.jpg differ
diff --git a/packages/flame_3d/example/lib/crate.dart b/packages/flame_3d/example/lib/crate.dart
new file mode 100644
index 00000000000..2721acab3d8
--- /dev/null
+++ b/packages/flame_3d/example/lib/crate.dart
@@ -0,0 +1,33 @@
+import 'dart:async';
+
+import 'package:flame/flame.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+class Crate extends MeshComponent {
+  Crate({
+    required Vector3 size,
+    super.position,
+  }) : super(mesh: CuboidMesh(size: size));
+
+  @override
+  FutureOr<void> onLoad() async {
+    final crateTexture = await Flame.images.loadTexture('crate.jpg');
+    mesh.updateSurfaces((surfaces) {
+      surfaces[0].material = SpatialMaterial(
+        albedoTexture: crateTexture,
+      );
+    });
+  }
+
+  double direction = 0.1;
+
+  @override
+  void update(double dt) {
+    if (scale.x >= 1.19 || scale.x <= 0.99) {
+      direction *= -1;
+    }
+    scale.add(Vector3.all(direction * dt));
+  }
+}
diff --git a/packages/flame_3d/example/lib/keyboard_controlled_camera.dart b/packages/flame_3d/example/lib/keyboard_controlled_camera.dart
new file mode 100644
index 00000000000..936e8685631
--- /dev/null
+++ b/packages/flame_3d/example/lib/keyboard_controlled_camera.dart
@@ -0,0 +1,196 @@
+import 'package:flame/components.dart' show KeyboardHandler;
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flutter/gestures.dart' show kMiddleMouseButton;
+import 'package:flutter/services.dart'
+    show KeyEvent, KeyRepeatEvent, LogicalKeyboardKey, PointerEvent;
+
+class KeyboardControlledCamera extends CameraComponent3D with KeyboardHandler {
+  KeyboardControlledCamera({
+    super.world,
+    super.viewport,
+    super.viewfinder,
+    super.backdrop,
+    super.hudComponents,
+  }) : super(
+          projection: CameraProjection.perspective,
+          mode: CameraMode.firstPerson,
+          position: Vector3(0, 2, 4),
+          target: Vector3(0, 2, 0),
+          up: Vector3(0, 1, 0),
+          fovY: 60,
+        );
+
+  final double moveSpeed = 0.9;
+  final double rotationSpeed = 0.3;
+  final double panSpeed = 2;
+  final double orbitalSpeed = 0.5;
+
+  Set<Key> _keysDown = {};
+  PointerEvent? pointerEvent;
+  double scrollMove = 0;
+
+  final Matrix4 _orbitalMatrix = Matrix4.identity();
+
+  @override
+  bool onKeyEvent(KeyEvent event, Set<Key> keysPressed) {
+    _keysDown = keysPressed;
+
+    // Switch camera mode
+    if (isKeyDown(Key.digit1)) {
+      mode = CameraMode.free;
+      up = Vector3(0, 1, 0); // Reset roll
+    } else if (isKeyDown(Key.digit2)) {
+      mode = CameraMode.firstPerson;
+      up = Vector3(0, 1, 0); // Reset roll
+    } else if (isKeyDown(Key.digit3)) {
+      mode = CameraMode.thirdPerson;
+      up = Vector3(0, 1, 0); // Reset roll
+    } else if (isKeyDown(Key.digit4)) {
+      mode = CameraMode.orbital;
+      up = Vector3(0, 1, 0); // Reset roll
+    }
+
+    if (isKeyDown(Key.keyP) && event is! KeyRepeatEvent) {
+      if (projection == CameraProjection.perspective) {
+        // Create an isometric view.
+        mode = CameraMode.thirdPerson;
+        projection = CameraProjection.orthographic;
+
+        position = Vector3(0, 2, -100);
+        target = Vector3(0, 2, 0);
+        up = Vector3(0, 1, 0);
+        fovY = 20;
+
+        yaw(-135 * degrees2Radians, rotateAroundTarget: true);
+        pitch(-45 * degrees2Radians, lockView: true, rotateAroundTarget: true);
+      } else if (projection == CameraProjection.orthographic) {
+        // Reset to default view.
+        mode = CameraMode.thirdPerson;
+        projection = CameraProjection.perspective;
+
+        position = Vector3(0, 2, 10);
+        target = Vector3(0, 2, 0);
+        up = Vector3(0, 1, 0);
+        fovY = 60;
+      }
+    }
+
+    return false;
+  }
+
+  @override
+  void update(double dt) {
+    final moveInWorldPlane = switch (mode) {
+      CameraMode.firstPerson || CameraMode.thirdPerson => true,
+      _ => false,
+    };
+    final rotateAroundTarget = switch (mode) {
+      CameraMode.thirdPerson || CameraMode.orbital => true,
+      _ => false,
+    };
+    final lockView = switch (mode) {
+      CameraMode.free || CameraMode.firstPerson || CameraMode.orbital => true,
+      _ => false,
+    };
+
+    if (mode == CameraMode.orbital) {
+      final rotation = _orbitalMatrix
+        ..setIdentity()
+        ..rotate(up, orbitalSpeed * dt);
+      final view = rotation.transform3(position - target);
+      position = target + view;
+    } else {
+      // Camera rotation
+      if (isKeyDown(Key.arrowDown)) {
+        pitch(
+          -rotationSpeed * dt,
+          lockView: lockView,
+          rotateAroundTarget: rotateAroundTarget,
+        );
+      } else if (isKeyDown(Key.arrowUp)) {
+        pitch(
+          rotationSpeed * dt,
+          lockView: lockView,
+          rotateAroundTarget: rotateAroundTarget,
+        );
+      }
+      if (isKeyDown(Key.arrowRight)) {
+        yaw(-rotationSpeed * dt, rotateAroundTarget: rotateAroundTarget);
+      } else if (isKeyDown(Key.arrowLeft)) {
+        yaw(rotationSpeed * dt, rotateAroundTarget: rotateAroundTarget);
+      }
+      if (isKeyDown(Key.keyQ)) {
+        roll(-rotationSpeed * dt);
+      } else if (isKeyDown(Key.keyE)) {
+        roll(rotationSpeed * dt);
+      }
+
+      // Camera movement, if mode is free and mouse button is down we pan the
+      // camera.
+      if (pointerEvent != null) {
+        if (mode == CameraMode.free &&
+            pointerEvent?.buttons == kMiddleMouseButton) {
+          final mouseDelta = pointerEvent!.delta;
+          if (mouseDelta.dx > 0) {
+            moveRight(panSpeed * dt, moveInWorldPlane: moveInWorldPlane);
+          } else if (mouseDelta.dx < 0) {
+            moveRight(-panSpeed * dt, moveInWorldPlane: moveInWorldPlane);
+          }
+          if (mouseDelta.dy > 0) {
+            moveUp(-panSpeed * dt);
+          } else if (mouseDelta.dy < 0) {
+            moveUp(panSpeed * dt);
+          }
+        } else {
+          const mouseMoveSensitivity = 0.003;
+          yaw(
+            (pointerEvent?.delta.dx ?? 0) * mouseMoveSensitivity,
+            rotateAroundTarget: rotateAroundTarget,
+          );
+          pitch(
+            (pointerEvent?.delta.dy ?? 0) * mouseMoveSensitivity,
+            lockView: lockView,
+            rotateAroundTarget: rotateAroundTarget,
+          );
+        }
+        pointerEvent = null;
+      }
+
+      // Keyboard movement
+      if (isKeyDown(Key.keyW)) {
+        moveForward(moveSpeed * dt);
+      } else if (isKeyDown(Key.keyS)) {
+        moveForward(-moveSpeed * dt);
+      }
+      if (isKeyDown(Key.keyA)) {
+        moveRight(-moveSpeed * dt);
+      } else if (isKeyDown(Key.keyD)) {
+        moveRight(moveSpeed * dt);
+      }
+
+      if (mode == CameraMode.free) {
+        if (isKeyDown(Key.space)) {
+          moveUp(moveSpeed * dt);
+        } else if (isKeyDown(Key.controlLeft)) {
+          moveUp(-moveSpeed * dt);
+        }
+      }
+    }
+
+    // if (mode == CameraMode.thirdPerson ||
+    //     mode == CameraMode.orbital ||
+    //     mode == CameraMode.free) {
+    //   moveToTarget(-scrollMove);
+    //   if (isKeyDown(Key.numpadSubtract)) {
+    //     moveToTarget(2 * dt);
+    //   } else if (isKeyDown(Key.numpadAdd)) {
+    //     moveToTarget(-2 * dt);
+    //   }
+    // }
+  }
+
+  bool isKeyDown(Key key) => _keysDown.contains(key);
+}
+
+typedef Key = LogicalKeyboardKey;
diff --git a/packages/flame_3d/example/lib/main.dart b/packages/flame_3d/example/lib/main.dart
new file mode 100644
index 00000000000..d58aea29c58
--- /dev/null
+++ b/packages/flame_3d/example/lib/main.dart
@@ -0,0 +1,179 @@
+import 'dart:async';
+import 'dart:math';
+
+import 'package:example/crate.dart';
+import 'package:example/keyboard_controlled_camera.dart';
+import 'package:example/player_box.dart';
+import 'package:example/rotating_light.dart';
+import 'package:example/simple_hud.dart';
+import 'package:flame/events.dart';
+import 'package:flame/extensions.dart' as v64 show Vector2;
+import 'package:flame/game.dart' show FlameGame, GameWidget;
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flutter/gestures.dart';
+import 'package:flutter/material.dart' show runApp, Color, Colors, Listener;
+
+class ExampleGame3D extends FlameGame<World3D>
+    with HasKeyboardHandlerComponents {
+  ExampleGame3D()
+      : super(
+          world: World3D(clearColor: const Color(0xFFFFFFFF)),
+          camera: KeyboardControlledCamera(
+            viewport: FixedResolutionViewport(
+              resolution: v64.Vector2(800, 600),
+            ),
+            hudComponents: [SimpleHud()],
+          ),
+        );
+
+  @override
+  KeyboardControlledCamera get camera =>
+      super.camera as KeyboardControlledCamera;
+
+  @override
+  FutureOr<void> onLoad() async {
+    world.addAll([
+      LightComponent.ambient(
+        intensity: 1.0,
+      ),
+      RotatingLight(),
+
+      LightComponent.point(
+        position: Vector3(0, 0.1, 0),
+        color: const Color(0xFFFF00FF),
+      ),
+      MeshComponent(
+        mesh: SphereMesh(
+          radius: 0.05,
+          material: SpatialMaterial(
+            albedoTexture: ColorTexture(
+              const Color(0xFFFF00FF),
+            ),
+          ),
+        ),
+        position: Vector3(0, 0.1, 0),
+      ),
+
+      LightComponent.point(
+        position: Vector3(-2, 3, 2),
+        color: const Color(0xFFFF2255),
+      ),
+      MeshComponent(
+        mesh: SphereMesh(
+          radius: 0.05,
+          material: SpatialMaterial(
+            albedoTexture: ColorTexture(
+              const Color(0xFFFF2255),
+            ),
+          ),
+        ),
+        position: Vector3(-2, 4, 2),
+      ),
+
+      // Add a player box
+      PlayerBox(),
+
+      // Floating crate
+      Crate(size: Vector3.all(1), position: Vector3(0, 5, 0)),
+
+      // Floating sphere
+      MeshComponent(
+        position: Vector3(5, 5, 5),
+        mesh: SphereMesh(
+          radius: 1,
+          material: SpatialMaterial(
+            albedoTexture: ColorTexture(Colors.green),
+          ),
+        ),
+      ),
+
+      // Floor
+      MeshComponent(
+        mesh: PlaneMesh(
+          size: Vector2(32, 32),
+          material: SpatialMaterial(albedoTexture: ColorTexture(Colors.grey)),
+        ),
+      ),
+
+      // Front wall
+      MeshComponent(
+        position: Vector3(16.5, 2.5, 0),
+        mesh: CuboidMesh(
+          size: Vector3(1, 5, 32),
+          material: SpatialMaterial(albedoTexture: ColorTexture(Colors.yellow)),
+        ),
+      ),
+
+      // Left wall
+      MeshComponent(
+        position: Vector3(0, 2.5, 16.5),
+        mesh: CuboidMesh(
+          size: Vector3(32, 5, 1),
+          material: SpatialMaterial(albedoTexture: ColorTexture(Colors.blue)),
+        ),
+      ),
+
+      // Right wall
+      MeshComponent(
+        position: Vector3(0, 2.5, -16.5),
+        mesh: CuboidMesh(
+          size: Vector3(32, 5, 1),
+          material: SpatialMaterial(albedoTexture: ColorTexture(Colors.lime)),
+          useFaceNormals: false,
+        ),
+      ),
+    ]);
+
+    final rnd = Random();
+    for (var i = 0; i < 20; i++) {
+      final height = rnd.range(1, 12);
+
+      world.add(
+        MeshComponent(
+          position: Vector3(rnd.range(-15, 15), height / 2, rnd.range(-15, 15)),
+          mesh: CuboidMesh(
+            size: Vector3(1, height, 1),
+            material: SpatialMaterial(
+              albedoTexture: ColorTexture(
+                Color.fromRGBO(rnd.iRange(20, 255), rnd.iRange(10, 55), 30, 1),
+              ),
+            ),
+          ),
+        ),
+      );
+    }
+  }
+}
+
+void main() {
+  final example = ExampleGame3D();
+
+  runApp(
+    Listener(
+      onPointerMove: (event) {
+        if (!event.down) {
+          return;
+        }
+        example.camera.pointerEvent = event;
+      },
+      onPointerSignal: (event) {
+        if (event is! PointerScrollEvent || !event.down) {
+          return;
+        }
+        example.camera.scrollMove = event.delta.dy / 3000;
+      },
+      onPointerUp: (event) => example.camera.pointerEvent = null,
+      onPointerCancel: (event) => example.camera.pointerEvent = null,
+      child: GameWidget(game: example),
+    ),
+  );
+}
+
+extension on Random {
+  double range(num min, num max) => nextDouble() * (max - min) + min;
+
+  int iRange(int min, int max) => range(min, max).toInt();
+}
diff --git a/packages/flame_3d/example/lib/player_box.dart b/packages/flame_3d/example/lib/player_box.dart
new file mode 100644
index 00000000000..39bc0c34e70
--- /dev/null
+++ b/packages/flame_3d/example/lib/player_box.dart
@@ -0,0 +1,29 @@
+import 'dart:ui';
+
+import 'package:example/main.dart';
+import 'package:flame/components.dart' show HasGameReference;
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flutter/material.dart' show Colors;
+
+class PlayerBox extends MeshComponent with HasGameReference<ExampleGame3D> {
+  PlayerBox()
+      : super(
+          mesh: CuboidMesh(
+            size: Vector3.all(0.5),
+            material:
+                SpatialMaterial(albedoTexture: ColorTexture(Colors.purple)),
+          ),
+        );
+
+  @override
+  void renderTree(Canvas canvas) {
+    // Only show the box if we are in third person mode.
+    if (game.camera.mode == CameraMode.thirdPerson) {
+      position.setFrom(game.camera.target);
+      super.renderTree(canvas);
+    }
+  }
+}
diff --git a/packages/flame_3d/example/lib/rotating_light.dart b/packages/flame_3d/example/lib/rotating_light.dart
new file mode 100644
index 00000000000..8ba9cb048a8
--- /dev/null
+++ b/packages/flame_3d/example/lib/rotating_light.dart
@@ -0,0 +1,23 @@
+import 'dart:math';
+import 'dart:ui';
+
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+
+class RotatingLight extends LightComponent {
+  RotatingLight()
+      : super.point(
+          position: Vector3.zero(),
+          color: const Color(0xFF00FF00),
+          intensity: 20.0,
+        );
+
+  @override
+  void update(double dt) {
+    const radius = 15;
+    final angle = DateTime.now().millisecondsSinceEpoch / 4000;
+    final x = cos(angle) * radius;
+    final z = sin(angle) * radius;
+    position.setValues(x, 10, z);
+  }
+}
diff --git a/packages/flame_3d/example/lib/simple_hud.dart b/packages/flame_3d/example/lib/simple_hud.dart
new file mode 100644
index 00000000000..757a70a34a1
--- /dev/null
+++ b/packages/flame_3d/example/lib/simple_hud.dart
@@ -0,0 +1,76 @@
+import 'dart:ui';
+
+import 'package:example/main.dart';
+import 'package:flame/components.dart';
+import 'package:flame/text.dart';
+import 'package:flame_3d/camera.dart';
+
+const _width = 1.2;
+const _color = Color(0xFFFFFFFF);
+
+final _style = TextStyle(
+  color: const Color(0xFF000000),
+  shadows: [
+    for (var x = 1; x < _width + 5; x++)
+      for (var y = 1; y < _width + 5; y++) ...[
+        Shadow(offset: Offset(-_width / x, -_width / y), color: _color),
+        Shadow(offset: Offset(-_width / x, _width / y), color: _color),
+        Shadow(offset: Offset(_width / x, -_width / y), color: _color),
+        Shadow(offset: Offset(_width / x, _width / y), color: _color),
+      ],
+  ],
+);
+
+class SimpleHud extends Component with HasGameReference<ExampleGame3D> {
+  SimpleHud() : super(children: [FpsComponent()]);
+
+  String get fps =>
+      children.query<FpsComponent>().firstOrNull?.fps.toStringAsFixed(2) ?? '0';
+
+  final _textLeft = TextPaint(style: _style);
+
+  final _textCenter = TextPaint(style: _style.copyWith(fontSize: 20));
+
+  final _textRight = TextPaint(style: _style, textDirection: TextDirection.rtl);
+
+  @override
+  void render(Canvas canvas) {
+    final CameraComponent3D(:position, :target, :up) = game.camera;
+
+    _textLeft.render(
+      canvas,
+      '''
+Camera controls:
+- Move using W, A, S, D, Space, Left-Ctrl
+- Look around with arrow keys or mouse
+- Change camera mode with 1, 2, 3 or 4
+- Change camera projection with P
+- Zoom in and out with scroll
+''',
+      Vector2.all(8),
+    );
+
+    _textCenter.render(
+      canvas,
+      'Welcome to the 3D world',
+      Vector2(game.size.x / 2, game.size.y - 8),
+      anchor: Anchor.bottomCenter,
+    );
+
+    _textRight.render(
+      canvas,
+      '''
+FPS: $fps
+Mode: ${game.camera.mode.name}
+Projection: ${game.camera.projection.name}
+Culled: ${game.world.culled}
+
+Position: ${position.x.toStringAsFixed(2)}, ${position.y.toStringAsFixed(2)}, ${position.z.toStringAsFixed(2)}
+Target: ${target.x.toStringAsFixed(2)}, ${target.y.toStringAsFixed(2)}, ${target.z.toStringAsFixed(2)}
+Up: ${up.x.toStringAsFixed(2)}, ${up.y.toStringAsFixed(2)}, ${up.z.toStringAsFixed(2)}
+''',
+      Vector2(game.size.x - 8, 8),
+      anchor: Anchor.topRight,
+    );
+  }
+}
diff --git a/packages/flame_3d/example/pubspec.yaml b/packages/flame_3d/example/pubspec.yaml
new file mode 100644
index 00000000000..801cd8c41b7
--- /dev/null
+++ b/packages/flame_3d/example/pubspec.yaml
@@ -0,0 +1,22 @@
+name: example
+description: An example for flame_3d. The example shows how to set up 3D support in a flame game.
+version: 0.0.1+1
+publish_to: none
+
+environment:
+  sdk: ">=3.4.0 <4.0.0"
+
+dependencies:
+  flame: ^1.16.0
+  flame_3d: ^0.1.0-dev.3
+  flutter:
+    sdk: flutter
+
+dev_dependencies:
+  flame_lint: ^1.2.0
+
+flutter:
+  uses-material-design: true
+
+  assets:
+    - assets/images/
diff --git a/packages/flame_3d/lib/camera.dart b/packages/flame_3d/lib/camera.dart
new file mode 100644
index 00000000000..cf4e46ba3ba
--- /dev/null
+++ b/packages/flame_3d/lib/camera.dart
@@ -0,0 +1,6 @@
+export 'package:flame/camera.dart';
+
+export 'package:vector_math/vector_math.dart' show Frustum;
+
+export 'src/camera/camera_component_3d.dart';
+export 'src/camera/world_3d.dart';
diff --git a/packages/flame_3d/lib/components.dart b/packages/flame_3d/lib/components.dart
new file mode 100644
index 00000000000..98af07237d0
--- /dev/null
+++ b/packages/flame_3d/lib/components.dart
@@ -0,0 +1,4 @@
+export 'src/components/component_3d.dart';
+export 'src/components/light_component.dart';
+export 'src/components/mesh_component.dart';
+export 'src/components/object_3d.dart';
diff --git a/packages/flame_3d/lib/core.dart b/packages/flame_3d/lib/core.dart
new file mode 100644
index 00000000000..97d9212061c
--- /dev/null
+++ b/packages/flame_3d/lib/core.dart
@@ -0,0 +1,12 @@
+export 'package:vector_math/vector_math.dart'
+    show
+        Vector2,
+        Vector3,
+        Vector4,
+        Matrix2,
+        Matrix3,
+        Matrix4,
+        Quaternion,
+        Aabb3;
+
+export 'extensions.dart';
diff --git a/packages/flame_3d/lib/extensions.dart b/packages/flame_3d/lib/extensions.dart
new file mode 100644
index 00000000000..726fd676a33
--- /dev/null
+++ b/packages/flame_3d/lib/extensions.dart
@@ -0,0 +1,7 @@
+export 'src/extensions/aabb3.dart';
+export 'src/extensions/color.dart';
+export 'src/extensions/matrix4.dart';
+export 'src/extensions/quaternion.dart';
+export 'src/extensions/vector2.dart';
+export 'src/extensions/vector3.dart';
+export 'src/extensions/vector4.dart';
diff --git a/packages/flame_3d/lib/game.dart b/packages/flame_3d/lib/game.dart
new file mode 100644
index 00000000000..71ecd61de4b
--- /dev/null
+++ b/packages/flame_3d/lib/game.dart
@@ -0,0 +1,5 @@
+export 'core.dart';
+export 'src/game/flame_game_3d.dart';
+export 'src/game/notifying_quaternion.dart';
+export 'src/game/notifying_vector3.dart';
+export 'src/game/transform_3d.dart';
diff --git a/packages/flame_3d/lib/graphics.dart b/packages/flame_3d/lib/graphics.dart
new file mode 100644
index 00000000000..ab2eee25192
--- /dev/null
+++ b/packages/flame_3d/lib/graphics.dart
@@ -0,0 +1 @@
+export 'src/graphics/graphics_device.dart';
diff --git a/packages/flame_3d/lib/resources.dart b/packages/flame_3d/lib/resources.dart
new file mode 100644
index 00000000000..2d6b7eccc94
--- /dev/null
+++ b/packages/flame_3d/lib/resources.dart
@@ -0,0 +1,15 @@
+import 'package:flame/cache.dart';
+import 'package:flame_3d/resources.dart';
+
+export 'src/resources/light.dart';
+export 'src/resources/material.dart';
+export 'src/resources/mesh.dart';
+export 'src/resources/resource.dart';
+export 'src/resources/shader.dart';
+export 'src/resources/texture.dart';
+
+extension TextureCache on Images {
+  Future<Texture> loadTexture(String path) {
+    return load(path).then(ImageTexture.create);
+  }
+}
diff --git a/packages/flame_3d/lib/src/camera/camera_component_3d.dart b/packages/flame_3d/lib/src/camera/camera_component_3d.dart
new file mode 100644
index 00000000000..0d849f66501
--- /dev/null
+++ b/packages/flame_3d/lib/src/camera/camera_component_3d.dart
@@ -0,0 +1,211 @@
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/game.dart';
+
+enum CameraProjection { perspective, orthographic }
+
+enum CameraMode { custom, free, orbital, firstPerson, thirdPerson }
+
+/// {@template camera_component_3d}
+/// [CameraComponent3D] is a component through which a [World3D] is observed.
+/// {@endtemplate}
+class CameraComponent3D extends CameraComponent {
+  /// {@macro camera_component_3d}
+  CameraComponent3D({
+    this.fovY = 60,
+    Vector3? position,
+    Vector3? target,
+    Vector3? up,
+    this.projection = CameraProjection.perspective,
+    this.mode = CameraMode.free,
+    World3D? super.world,
+    super.viewport,
+    super.viewfinder,
+    super.backdrop,
+    super.hudComponents,
+  })  : position = position?.clone() ?? Vector3.zero(),
+        target = target?.clone() ?? Vector3(0, 0, -1),
+        _up = up?.clone() ?? Vector3(0, 1, 0);
+
+  @override
+  World3D? get world => super.world as World3D?;
+
+  @override
+  set world(covariant World3D? world) => super.world = world;
+
+  /// The [fovY] is the field of view in Y (degrees) when the [projection] is
+  /// [CameraProjection.perspective] otherwise it is used as the near plane when
+  /// the [projection] is [CameraProjection.orthographic].
+  double fovY;
+
+  /// The position of the camera in 3D space.
+  ///
+  /// Often also referred to as the "eye".
+  Vector3 position;
+
+  /// The target in 3D space that the camera is looking at.
+  Vector3 target;
+
+  /// The forward direction relative to the camera.
+  Vector3 get forward => target - position;
+
+  /// The right direction relative to the camera.
+  Vector3 get right => forward.cross(up);
+
+  /// The up direction relative to the camera.
+  Vector3 get up => _up.normalized();
+  set up(Vector3 up) => _up.setFrom(up);
+  final Vector3 _up;
+
+  /// The current camera projection.
+  CameraProjection projection;
+
+  /// The current camera mode.
+  CameraMode mode;
+
+  /// The view matrix of the camera, this is without any projection applied on
+  /// it.
+  Matrix4 get viewMatrix => _viewMatrix..setAsViewMatrix(position, target, up);
+  final Matrix4 _viewMatrix = Matrix4.zero();
+
+  /// The projection matrix of the camera.
+  Matrix4 get projectionMatrix {
+    final aspectRatio = viewport.virtualSize.x / viewport.virtualSize.y;
+    return switch (projection) {
+      CameraProjection.perspective => _projectionMatrix
+        ..setAsPerspective(fovY, aspectRatio, distanceNear, distanceFar),
+      CameraProjection.orthographic => _projectionMatrix
+        ..setAsOrthographic(fovY, aspectRatio, distanceNear, distanceFar)
+    };
+  }
+
+  final Matrix4 _projectionMatrix = Matrix4.zero();
+
+  Matrix4 get viewProjectionMatrix => _viewProjectionMatrix
+    ..setFrom(projectionMatrix)
+    ..multiply(viewMatrix);
+  final Matrix4 _viewProjectionMatrix = Matrix4.zero();
+
+  final Frustum _frustum = Frustum();
+
+  Frustum get frustum => _frustum..setFromMatrix(viewProjectionMatrix);
+
+  void moveForward(double distance, {bool moveInWorldPlane = false}) {
+    final forward = this.forward..scale(distance);
+
+    if (moveInWorldPlane) {
+      forward.y = 0;
+      forward.normalize();
+    }
+
+    position.add(forward);
+    target.add(forward);
+  }
+
+  void moveUp(double distance) {
+    final up = this.up..scale(distance);
+    position.add(up);
+    target.add(up);
+  }
+
+  void moveRight(double distance, {bool moveInWorldPlane = false}) {
+    final right = this.right..scale(distance);
+
+    if (moveInWorldPlane) {
+      right.y = 0;
+      right.normalize();
+    }
+
+    position.add(right);
+    target.add(right);
+  }
+
+  void moveToTarget(double delta) {
+    var distance = position.distanceTo(target);
+    distance += delta;
+
+    if (distance <= 0) {
+      distance = 0.001;
+    }
+
+    final forward = this.forward;
+    position.setValues(
+      target.x + (forward.x * -distance),
+      target.y + (forward.y * -distance),
+      target.z + (forward.z * -distance),
+    );
+  }
+
+  void yaw(double angle, {bool rotateAroundTarget = false}) {
+    final targetPosition = (target - position)..applyAxisAngle(up, angle);
+
+    if (rotateAroundTarget) {
+      position.setValues(
+        target.x - targetPosition.x,
+        target.y - targetPosition.y,
+        target.z - targetPosition.z,
+      );
+    } else {
+      target.setValues(
+        position.x + targetPosition.x,
+        position.y + targetPosition.y,
+        position.z + targetPosition.z,
+      );
+    }
+  }
+
+  void pitch(
+    double angle, {
+    bool lockView = false,
+    bool rotateAroundTarget = false,
+    bool rotateUp = false,
+  }) {
+    var localAngle = angle;
+    final up = this.up;
+    final targetPosition = target - position;
+
+    if (lockView) {
+      final maxAngleUp = up.angleTo(targetPosition);
+      if (localAngle > maxAngleUp) {
+        localAngle = maxAngleUp;
+      }
+
+      var maxAngleDown = (-up).angleTo(targetPosition);
+      maxAngleDown *= -1.0;
+
+      if (localAngle < maxAngleDown) {
+        localAngle = maxAngleDown;
+      }
+    }
+
+    final right = this.right;
+    targetPosition.applyAxisAngle(right, localAngle);
+
+    if (rotateAroundTarget) {
+      position.setValues(
+        target.x - targetPosition.x,
+        target.y - targetPosition.y,
+        target.z - targetPosition.z,
+      );
+    } else {
+      target.setValues(
+        position.x + targetPosition.x,
+        position.y + targetPosition.y,
+        position.z + targetPosition.z,
+      );
+    }
+
+    if (rotateUp) {
+      _up.applyAxisAngle(right, angle);
+    }
+  }
+
+  void roll(double angle) {
+    _up.applyAxisAngle(forward, angle);
+  }
+
+  static CameraComponent3D? get currentCamera =>
+      CameraComponent.currentCamera as CameraComponent3D?;
+
+  static const distanceNear = 0.01;
+  static const distanceFar = 1000.0;
+}
diff --git a/packages/flame_3d/lib/src/camera/world_3d.dart b/packages/flame_3d/lib/src/camera/world_3d.dart
new file mode 100644
index 00000000000..d7ee43e12d7
--- /dev/null
+++ b/packages/flame_3d/lib/src/camera/world_3d.dart
@@ -0,0 +1,79 @@
+import 'dart:ui';
+
+import 'package:flame/components.dart' as flame;
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flutter/widgets.dart' show MediaQuery;
+import 'package:meta/meta.dart';
+
+/// {@template world_3d}
+/// The root component for all 3D world elements.
+///
+/// The primary feature of this component is that it allows [Component3D]s to
+/// render directly to a [GraphicsDevice] instead of the regular rendering.
+/// {@endtemplate}
+class World3D extends flame.World with flame.HasGameReference {
+  /// {@macro world_3d}
+  World3D({
+    super.children,
+    super.priority,
+    Color clearColor = const Color(0x00000000),
+  }) : device = GraphicsDevice(clearValue: clearColor) {
+    children.register<LightComponent>();
+  }
+
+  /// The graphical device attached to this world.
+  @internal
+  final GraphicsDevice device;
+
+  Iterable<Light> get lights =>
+      children.query<LightComponent>().map((component) => component.light);
+
+  final _paint = Paint();
+
+  @internal
+  @override
+  void renderFromCamera(Canvas canvas) {
+    final camera = CameraComponent3D.currentCamera!;
+    final viewport = camera.viewport;
+
+    final devicePixelRatio = MediaQuery.of(game.buildContext!).devicePixelRatio;
+    final size = Size(
+      viewport.virtualSize.x * devicePixelRatio,
+      viewport.virtualSize.y * devicePixelRatio,
+    );
+
+    device
+      // Set the view matrix
+      ..view.setFrom(camera.viewMatrix)
+      // Set the projection matrix
+      ..projection.setFrom(camera.projectionMatrix)
+      ..begin(size);
+
+    culled = 0;
+
+    _prepareDevice();
+    // ignore: invalid_use_of_internal_member
+    super.renderFromCamera(canvas);
+
+    final image = device.end();
+    canvas.drawImageRect(
+      image,
+      Offset.zero & size,
+      (-viewport.virtualSize / 2).toOffset() &
+          Size(viewport.virtualSize.x, viewport.virtualSize.y),
+      _paint,
+    );
+    image.dispose();
+  }
+
+  // TODO(luan): consider making this a fixed-size array later
+  void _prepareDevice() {
+    device.lightingInfo.lights = lights;
+  }
+
+  // TODO(wolfenrain): this is only here for testing purposes
+  int culled = 0;
+}
diff --git a/packages/flame_3d/lib/src/components/component_3d.dart b/packages/flame_3d/lib/src/components/component_3d.dart
new file mode 100644
index 00000000000..3ada2bdb9c4
--- /dev/null
+++ b/packages/flame_3d/lib/src/components/component_3d.dart
@@ -0,0 +1,83 @@
+import 'package:flame/components.dart' show Component, HasWorldReference;
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+
+/// {@template component_3d}
+/// [Component3D] is a base class for any concept that lives in 3D space.
+///
+/// It is a [Component] implementation that represents a 3D object that can be
+/// freely moved around in 3D space, rotated, and scaled.
+///
+/// The main property of this class is the [transform] (which combines
+/// the [position], [rotation], and [scale]). Thus, the [Component3D] can be
+/// seen as an object in 3D space.
+///
+/// It is typically not used directly, but rather use one of the following
+/// implementations:
+/// - [Object3D] for a 3D object that can be bound and rendered by the GPU
+/// - [LightComponent] for a light source that affects how objects are rendered
+///
+/// If you want to have a pure group for several components, you have two
+/// options:
+/// - Use an [Object3D], the group itself will have some superfluous render
+/// logic but should not affect your children.
+/// - Extend the abstract class [Component3D] yourself.
+///
+/// The base [Component3D] class can also be used as a container
+/// for several other components. In this case, changing the position,
+/// rotating or scaling the [Component3D] will affect the whole
+/// group as if it was a single entity.
+/// {@endtemplate}
+abstract class Component3D extends Component with HasWorldReference<World3D> {
+  final Transform3D transform;
+
+  /// {@macro component_3d}
+  Component3D({
+    Vector3? position,
+    Vector3? scale,
+    Quaternion? rotation,
+    List<Component3D> children = const [],
+  })  : transform = Transform3D()
+          ..position = position ?? Vector3.zero()
+          ..rotation = rotation ?? Quaternion.euler(0, 0, 0)
+          ..scale = scale ?? Vector3.all(1),
+        super(children: children);
+
+  /// The total transformation matrix for the component. This matrix combines
+  /// translation, rotation and scale transforms into a single entity. The
+  /// matrix is cached and gets recalculated only as necessary.
+  Matrix4 get transformMatrix => transform.transformMatrix;
+
+  /// The position of this component's anchor on the screen.
+  NotifyingVector3 get position => transform.position;
+  set position(Vector3 position) => transform.position = position;
+
+  /// X position of this component's anchor on the screen.
+  double get x => transform.x;
+  set x(double x) => transform.x = x;
+
+  /// Y position of this component's anchor on the screen.
+  double get y => transform.y;
+  set y(double y) => transform.y = y;
+
+  /// Z position of this component's anchor on the screen.
+  double get z => transform.z;
+  set z(double z) => transform.z = z;
+
+  /// The rotation of this component.
+  NotifyingQuaternion get rotation => transform.rotation;
+  set rotation(NotifyingQuaternion rotation) => transform.rotation = rotation;
+
+  /// The scale factor of this component. The scale can be different along
+  /// the X, Y and Z dimensions. A scale greater than 1 makes the component
+  /// bigger along that axis, and less than 1 smaller. The scale can also be
+  /// negative, which results in a mirror reflection along the corresponding
+  /// axis.
+  NotifyingVector3 get scale => transform.scale;
+  set scale(Vector3 scale) => transform.scale = scale;
+
+  /// Measure the distance (in parent's coordinate space) between this
+  /// component's anchor and the [other] component's anchor.
+  double distance(Component3D other) => position.distanceTo(other.position);
+}
diff --git a/packages/flame_3d/lib/src/components/light_component.dart b/packages/flame_3d/lib/src/components/light_component.dart
new file mode 100644
index 00000000000..095d8b6ad35
--- /dev/null
+++ b/packages/flame_3d/lib/src/components/light_component.dart
@@ -0,0 +1,53 @@
+import 'dart:ui';
+
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+/// A [Component3D] that represents a light source in the 3D world.
+class LightComponent extends Component3D {
+  LightComponent({
+    required this.source,
+    super.position,
+  });
+
+  LightComponent.point({
+    Vector3? position,
+    Color color = const Color(0xFFFFFFFF),
+    double intensity = 1.0,
+  }) : this(
+          source: PointLight(
+            color: color,
+            intensity: intensity,
+          ),
+          position: position,
+        );
+
+  LightComponent.ambient({
+    Color color = const Color(0xFFFFFFFF),
+    double intensity = 0.2,
+  }) : this(
+          source: AmbientLight(
+            color: color,
+            intensity: intensity,
+          ),
+        );
+
+  final LightSource source;
+
+  late final Light _light = Light(
+    transform: transform,
+    source: source,
+  );
+
+  Light get light => _light;
+
+  @override
+  void onMount() {
+    assert(
+      parent is World3D,
+      'Lights must be added to the root of the World3D',
+    );
+  }
+}
diff --git a/packages/flame_3d/lib/src/components/mesh_component.dart b/packages/flame_3d/lib/src/components/mesh_component.dart
new file mode 100644
index 00000000000..0dcb35c9a2d
--- /dev/null
+++ b/packages/flame_3d/lib/src/components/mesh_component.dart
@@ -0,0 +1,42 @@
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flame_3d/src/camera/camera_component_3d.dart';
+import 'package:flame_3d/src/graphics/graphics_device.dart';
+
+/// {@template mesh_component}
+/// An [Object3D] that renders a [Mesh] at the [position] with the [rotation]
+/// and [scale] applied.
+///
+/// This is a commonly used subclass of [Object3D].
+/// {@endtemplate}
+class MeshComponent extends Object3D {
+  /// {@macro mesh_component}
+  MeshComponent({
+    required Mesh mesh,
+    super.position,
+    super.scale,
+    super.rotation,
+  }) : _mesh = mesh;
+
+  /// The mesh resource.
+  Mesh get mesh => _mesh;
+  final Mesh _mesh;
+
+  Aabb3 get aabb => _aabb
+    ..setFrom(mesh.aabb)
+    ..transform(transformMatrix);
+  final Aabb3 _aabb = Aabb3();
+
+  @override
+  void bind(GraphicsDevice device) {
+    device
+      ..model.setFrom(transformMatrix)
+      ..bindMesh(mesh);
+  }
+
+  @override
+  bool shouldCull(CameraComponent3D camera) {
+    return camera.frustum.intersectsWithAabb3(aabb);
+  }
+}
diff --git a/packages/flame_3d/lib/src/components/object_3d.dart b/packages/flame_3d/lib/src/components/object_3d.dart
new file mode 100644
index 00000000000..eff41e3231a
--- /dev/null
+++ b/packages/flame_3d/lib/src/components/object_3d.dart
@@ -0,0 +1,62 @@
+import 'dart:ui';
+
+import 'package:flame/game.dart' show FlameGame;
+import 'package:flame_3d/camera.dart';
+import 'package:flame_3d/components.dart';
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template object_3d}
+/// [Object3D]s are the basic building blocks for a 3D [FlameGame].
+///
+/// It is an object that is positioned in 3D space and can be bind to be
+/// rendered by a [GraphicsDevice].
+///
+/// However, it has no visual representation of its own (except in
+/// debug mode). It is common, therefore, to derive from this class
+/// and implement a specific rendering logic.
+///
+/// See the [MeshComponent] for an [Object3D] that has a visual representation
+/// using a [Mesh].
+/// {@endtemplate}
+abstract class Object3D extends Component3D {
+  /// {@macro object_3d}
+  Object3D({
+    super.position,
+    super.scale,
+    super.rotation,
+  });
+
+  @override
+  void renderTree(Canvas canvas) {
+    super.renderTree(canvas);
+    final camera = CameraComponent3D.currentCamera;
+    assert(
+      camera != null,
+      '''Component is either not part of a World3D or the render is being called outside of the camera rendering''',
+    );
+    if (!shouldCull(camera!)) {
+      world.culled++;
+      return;
+    }
+
+    // We set the priority to the distance between the camera and the object.
+    // This ensures that our rendering is done in a specific order allowing for
+    // alpha blending.
+    //
+    // Note(wolfenrain): we should optimize this in the long run it currently
+    // sucks.
+    priority = -(CameraComponent3D.currentCamera!.position - position)
+        .length
+        .abs()
+        .toInt();
+
+    bind(world.device);
+  }
+
+  void bind(GraphicsDevice device);
+
+  bool shouldCull(CameraComponent3D camera) {
+    return camera.frustum.containsVector3(position);
+  }
+}
diff --git a/packages/flame_3d/lib/src/extensions/aabb3.dart b/packages/flame_3d/lib/src/extensions/aabb3.dart
new file mode 100644
index 00000000000..1fc56a27269
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/aabb3.dart
@@ -0,0 +1,15 @@
+import 'package:flame_3d/game.dart';
+
+extension Aabb3Extension on Aabb3 {
+  /// Set the min and max from the [other].
+  void setFrom(Aabb3 other) {
+    min.setFrom(other.min);
+    max.setFrom(other.max);
+  }
+
+  /// Set the min and max to zero.
+  void setZero() {
+    min.setZero();
+    max.setZero();
+  }
+}
diff --git a/packages/flame_3d/lib/src/extensions/color.dart b/packages/flame_3d/lib/src/extensions/color.dart
new file mode 100644
index 00000000000..9d06264fcf5
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/color.dart
@@ -0,0 +1,12 @@
+import 'dart:typed_data';
+import 'dart:ui';
+
+extension ColorExtension on Color {
+  /// Returns a Float32List that represents the color as a vector.
+  Float32List get storage => Float32List.fromList([
+        opacity,
+        red.toDouble() / 255,
+        green.toDouble() / 255,
+        blue.toDouble() / 255,
+      ]);
+}
diff --git a/packages/flame_3d/lib/src/extensions/matrix4.dart b/packages/flame_3d/lib/src/extensions/matrix4.dart
new file mode 100644
index 00000000000..7060adfe66a
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/matrix4.dart
@@ -0,0 +1,38 @@
+import 'package:flame_3d/game.dart';
+
+export 'package:vector_math/vector_math.dart'
+    show
+        degrees2Radians,
+        setViewMatrix,
+        setPerspectiveMatrix,
+        setOrthographicMatrix;
+
+extension Matrix4Extension on Matrix4 {
+  /// Set the matrix to be a view matrix.
+  void setAsViewMatrix(Vector3 position, Vector3 target, Vector3 up) {
+    setViewMatrix(this, position, target, up);
+  }
+
+  /// Set the matrix to use a projection view.
+  void setAsPerspective(
+    double fovY,
+    double aspectRatio,
+    double zNear,
+    double zFar,
+  ) {
+    final fovYRadians = fovY * degrees2Radians;
+    setPerspectiveMatrix(this, fovYRadians, aspectRatio, zNear, zFar);
+  }
+
+  /// Set the matrix to use a orthographic view.
+  void setAsOrthographic(
+    double nearPlaneWidth,
+    double aspectRatio,
+    double zNear,
+    double zFar,
+  ) {
+    final top = nearPlaneWidth / 2.0;
+    final right = top * aspectRatio;
+    setOrthographicMatrix(this, -right, right, -top, top, zNear, zFar);
+  }
+}
diff --git a/packages/flame_3d/lib/src/extensions/quaternion.dart b/packages/flame_3d/lib/src/extensions/quaternion.dart
new file mode 100644
index 00000000000..14936c12368
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/quaternion.dart
@@ -0,0 +1,81 @@
+import 'dart:math';
+
+import 'package:flame_3d/core.dart';
+
+extension QuaternionExtension on Quaternion {
+  List<double> get storage => [x, y, z, w];
+
+  double dot(Quaternion other) {
+    return x * other.x + y * other.y + z * other.z + w * other.w;
+  }
+
+  Quaternion operator /(double s) {
+    return Quaternion(x / s, y / s, z / s, w / s);
+  }
+
+  Quaternion lerp(Quaternion other, double t) {
+    return QuaternionUtils.lerp(this, other, t);
+  }
+
+  Quaternion slerp(Quaternion other, double t, {double epsilon = 10e-6}) {
+    return QuaternionUtils.slerp(this, other, t, epsilon: epsilon);
+  }
+}
+
+final class QuaternionUtils {
+  QuaternionUtils._();
+
+  static Quaternion slerp(
+    Quaternion q0,
+    Quaternion q1,
+    double t, {
+    double epsilon = 10e-6,
+  }) {
+    final result = _slerp(q0, q1, t, epsilon: epsilon);
+    if (result.storage.any((e) => e.isNaN || e.isInfinite)) {
+      throw Exception(
+        'Quaternion slerp result is invalid: slerp($q0, $q1) = $result',
+      );
+    }
+    return result;
+  }
+
+  /// Some background on the correct shortest-path implementation can be found
+  /// here:
+  /// https://blog.magnum.graphics/backstage/the-unnecessarily-short-ways-to-do-a-quaternion-slerp/
+  static Quaternion _slerp(
+    Quaternion q0,
+    Quaternion q1,
+    double t, {
+    double epsilon = 10e-6,
+  }) {
+    if (isEqual(q0, q1)) {
+      return q0;
+    }
+
+    // clamp the dot product just in case of numerical instability
+    final dot = q0.dot(q1).clamp(-1.0, 1.0);
+    if (1 - dot.abs() < epsilon) {
+      // The quaternions are very close, so the linear interpolation algorithm
+      // will be a good approximation.
+      // This will prevent a NaN from the slerp algorithm.
+      return lerp(q0, q1, t).normalized();
+    }
+
+    final angle = acos(dot.abs());
+
+    final q1Prime = dot >= 0 ? q1 : q1.scaled(-1);
+    final a = sin((1 - t) * angle);
+    final b = sin(t * angle);
+
+    return (q0.scaled(a) + q1Prime.scaled(b)) / sin(angle);
+  }
+
+  static Quaternion lerp(Quaternion q0, Quaternion q1, double t) {
+    return q0 + (q1 - q0).scaled(t);
+  }
+
+  static bool isEqual(Quaternion a, Quaternion b) {
+    return a.x == b.x && a.y == b.y && a.z == b.z && a.w == b.w;
+  }
+}
diff --git a/packages/flame_3d/lib/src/extensions/vector2.dart b/packages/flame_3d/lib/src/extensions/vector2.dart
new file mode 100644
index 00000000000..1b607209c27
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/vector2.dart
@@ -0,0 +1,27 @@
+import 'package:flame_3d/game.dart';
+
+/// Represents an immutable [Vector2].
+typedef ImmutableVector2 = ({double x, double y});
+
+extension Vector2Extension on Vector2 {
+  /// Returns an immutable representation of the vector.
+  ImmutableVector2 get immutable => (x: x, y: y);
+
+  Vector2 lerp(Vector2 other, double t) {
+    return Vector2Utils.lerp(this, other, t);
+  }
+}
+
+final class Vector2Utils {
+  Vector2Utils._();
+
+  static Vector2 lerp(Vector2 a, Vector2 b, double t) {
+    return a + (b - a).scaled(t);
+  }
+}
+
+extension Vector2Math on ImmutableVector2 {
+  List<double> get storage => [x, y];
+
+  Vector2 get mutable => Vector2(x, y);
+}
diff --git a/packages/flame_3d/lib/src/extensions/vector3.dart b/packages/flame_3d/lib/src/extensions/vector3.dart
new file mode 100644
index 00000000000..e3a01f73336
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/vector3.dart
@@ -0,0 +1,36 @@
+import 'package:flame_3d/game.dart';
+
+/// Represents an immutable [Vector3].
+typedef ImmutableVector3 = ({double x, double y, double z});
+
+extension Vector3Extension on Vector3 {
+  /// Returns an immutable representation of the vector.
+  ImmutableVector3 get immutable => (x: x, y: y, z: z);
+
+  Vector3 lerp(Vector3 other, double t) {
+    return Vector3Utils.lerp(this, other, t);
+  }
+}
+
+class Vector3Utils {
+  Vector3Utils._();
+
+  static Vector3 lerp(Vector3 a, Vector3 b, double t) {
+    return a + (b - a).scaled(t);
+  }
+}
+
+extension Vector3Math on ImmutableVector3 {
+  List<double> get storage => [x, y, z];
+
+  ImmutableVector3 operator -(Object v) {
+    if (v is ImmutableVector3) {
+      return (x: x - v.x, y: y - v.y, z: z - v.z);
+    } else if (v is Vector3) {
+      return (x: x - v.x, y: y - v.y, z: z - v.z);
+    }
+    throw UnsupportedError('${v.runtimeType}');
+  }
+
+  Vector3 get mutable => Vector3(x, y, z);
+}
diff --git a/packages/flame_3d/lib/src/extensions/vector4.dart b/packages/flame_3d/lib/src/extensions/vector4.dart
new file mode 100644
index 00000000000..4eecda45160
--- /dev/null
+++ b/packages/flame_3d/lib/src/extensions/vector4.dart
@@ -0,0 +1,27 @@
+import 'package:flame_3d/game.dart';
+
+/// Represents an immutable [Vector3].
+typedef ImmutableVector4 = ({double x, double y, double z, double w});
+
+extension Vector4Extension on Vector4 {
+  /// Returns an immutable representation of the vector.
+  ImmutableVector4 get immutable => (x: x, y: y, z: z, w: w);
+
+  Vector4 lerp(Vector4 other, double t) {
+    return Vector4Utils.lerp(this, other, t);
+  }
+}
+
+class Vector4Utils {
+  Vector4Utils._();
+
+  static Vector4 lerp(Vector4 a, Vector4 b, double t) {
+    return a + (b - a).scaled(t);
+  }
+}
+
+extension Vector4Math on ImmutableVector4 {
+  List<double> get storage => [x, y, z, w];
+
+  Vector4 get mutable => Vector4(x, y, z, w);
+}
diff --git a/packages/flame_3d/lib/src/game/flame_game_3d.dart b/packages/flame_3d/lib/src/game/flame_game_3d.dart
new file mode 100644
index 00000000000..ec3fa7d8ec9
--- /dev/null
+++ b/packages/flame_3d/lib/src/game/flame_game_3d.dart
@@ -0,0 +1,18 @@
+import 'dart:ui';
+
+import 'package:flame/game.dart';
+import 'package:flame_3d/camera.dart';
+
+class FlameGame3D<W extends World3D> extends FlameGame<W> {
+  FlameGame3D({
+    super.children,
+    W? world,
+    CameraComponent3D? camera,
+  }) : super(
+          world: world ?? World3D(clearColor: const Color(0xFFFFFFFF)) as W,
+          camera: camera ?? CameraComponent3D(),
+        );
+
+  @override
+  CameraComponent3D get camera => super.camera as CameraComponent3D;
+}
diff --git a/packages/flame_3d/lib/src/game/notifying_quaternion.dart b/packages/flame_3d/lib/src/game/notifying_quaternion.dart
new file mode 100644
index 00000000000..e1cbf37dbd2
--- /dev/null
+++ b/packages/flame_3d/lib/src/game/notifying_quaternion.dart
@@ -0,0 +1,173 @@
+import 'dart:math';
+
+import 'package:flame_3d/game.dart';
+import 'package:flutter/foundation.dart';
+
+/// {@template notifying_quaternion}
+/// Extension of the standard [Quaternion] class, implementing the
+/// [ChangeNotifier] functionality. This allows any interested party to be
+/// notified when the value of this quaternion changes.
+///
+/// This class can be used as a regular [Quaternion] class. However, if you do
+/// subscribe to notifications, don't forget to eventually unsubscribe in
+/// order to avoid resource leaks.
+///
+/// Direct modification of this quaternion's [storage] is not allowed.
+/// {@endtemplate}
+class NotifyingQuaternion extends Quaternion with ChangeNotifier {
+  /// {@macro notifying_quaternion}
+  ///
+  /// Constructs a quaternion using the raw values [x], [y], [z], and [w].
+  factory NotifyingQuaternion(double x, double y, double z, double w) =>
+      NotifyingQuaternion._()..setValues(x, y, z, w);
+  NotifyingQuaternion._() : super.fromFloat32List(Float32List(4));
+
+  /// {@macro notifying_quaternion}
+  ///
+  /// Constructs a quaternion from a rotation matrix [rotationMatrix].
+  factory NotifyingQuaternion.fromRotation(Matrix3 rotationMatrix) =>
+      NotifyingQuaternion._()..setFromRotation(rotationMatrix);
+
+  /// {@macro notifying_quaternion}
+  ///
+  /// Constructs a quaternion from a rotation of [angle] around [axis].
+  factory NotifyingQuaternion.axisAngle(Vector3 axis, double angle) =>
+      NotifyingQuaternion._()..setAxisAngle(axis, angle);
+
+  /// {@macro notifying_quaternion}
+  ///
+  /// Constructs a quaternion as a copy of [other].
+  factory NotifyingQuaternion.copy(Quaternion other) =>
+      NotifyingQuaternion._()..setFrom(other);
+
+  /// {@macro notifying_quaternion}
+  ///
+  /// Constructs a quaternion from time derivative of [q] with angular
+  /// velocity [omega].
+  factory NotifyingQuaternion.dq(Quaternion q, Vector3 omega) =>
+      NotifyingQuaternion._()..setDQ(q, omega);
+
+  /// {@macro notifying_quaternion}
+  ///
+  /// Constructs a quaternion from [yaw], [pitch] and [roll].
+  factory NotifyingQuaternion.euler(double yaw, double pitch, double roll) =>
+      NotifyingQuaternion._()..setEuler(yaw, pitch, roll);
+
+  @override
+  void setValues(double x, double y, double z, double w) {
+    super.setValues(x, y, z, w);
+    notifyListeners();
+  }
+
+  @override
+  void setAxisAngle(Vector3 axis, double radians) {
+    super.setAxisAngle(axis, radians);
+    notifyListeners();
+  }
+
+  @override
+  void setDQ(Quaternion q, Vector3 omega) {
+    super.setDQ(q, omega);
+    notifyListeners();
+  }
+
+  @override
+  void setEuler(double yaw, double pitch, double roll) {
+    super.setEuler(yaw, pitch, roll);
+    notifyListeners();
+  }
+
+  @override
+  void setFromRotation(Matrix3 rotationMatrix) {
+    super.setFromRotation(rotationMatrix);
+    notifyListeners();
+  }
+
+  @override
+  void setFromTwoVectors(Vector3 a, Vector3 b) {
+    super.setFromTwoVectors(a, b);
+    notifyListeners();
+  }
+
+  @override
+  void setRandom(Random rn) {
+    super.setRandom(rn);
+    notifyListeners();
+  }
+
+  @override
+  void setFrom(Quaternion source) {
+    super.setFrom(source);
+    notifyListeners();
+  }
+
+  @override
+  void operator []=(int i, double arg) {
+    super[i] = arg;
+    notifyListeners();
+  }
+
+  @override
+  double normalize() {
+    final l = super.normalize();
+    notifyListeners();
+    return l;
+  }
+
+  @override
+  void add(Quaternion arg) {
+    super.add(arg);
+    notifyListeners();
+  }
+
+  @override
+  void sub(Quaternion arg) {
+    super.sub(arg);
+    notifyListeners();
+  }
+
+  @override
+  void scale(double scale) {
+    super.scale(scale);
+    notifyListeners();
+  }
+
+  @override
+  set x(double x) {
+    super.x = x;
+    notifyListeners();
+  }
+
+  @override
+  set y(double y) {
+    super.y = y;
+    notifyListeners();
+  }
+
+  @override
+  set z(double z) {
+    super.z = z;
+    notifyListeners();
+  }
+
+  @override
+  set w(double w) {
+    super.w = w;
+    notifyListeners();
+  }
+
+  @override
+  void conjugate() {
+    super.conjugate();
+    notifyListeners();
+  }
+
+  @override
+  void inverse() {
+    super.inverse();
+    notifyListeners();
+  }
+
+  @override
+  Float32List get storage => super.storage.asUnmodifiableView();
+}
diff --git a/packages/flame_3d/lib/src/game/notifying_vector3.dart b/packages/flame_3d/lib/src/game/notifying_vector3.dart
new file mode 100644
index 00000000000..369500dbd00
--- /dev/null
+++ b/packages/flame_3d/lib/src/game/notifying_vector3.dart
@@ -0,0 +1,209 @@
+import 'package:flame_3d/game.dart';
+import 'package:flutter/foundation.dart';
+
+/// {@template notifying_vector_3}
+/// Extension of the standard [Vector3] class, implementing the [ChangeNotifier]
+/// functionality. This allows any interested party to be notified when the
+/// value of this vector changes.
+///
+/// This class can be used as a regular [Vector3] class. However, if you do
+/// subscribe to notifications, don't forget to eventually unsubscribe in
+/// order to avoid resource leaks.
+///
+/// Direct modification of this vector's [storage] is not allowed.
+/// {@endtemplate}
+class NotifyingVector3 extends Vector3 with ChangeNotifier {
+  /// {@macro notifying_vector_3}
+  ///
+  /// Constructs a vector using the raw values [x], [y], and [z].
+  factory NotifyingVector3(double x, double y, double z) =>
+      NotifyingVector3.zero()..setValues(x, y, z);
+
+  /// {@macro notifying_vector_3}
+  ///
+  /// Create an empty vector.
+  NotifyingVector3.zero() : super.zero();
+
+  /// {@macro notifying_vector_3}
+  ///
+  /// Create an vector whose values are all [v].
+  factory NotifyingVector3.all(double v) => NotifyingVector3.zero()..splat(v);
+
+  /// {@macro notifying_vector_3}
+  ///
+  /// Create a copy of the [other] vector.
+  factory NotifyingVector3.copy(Vector3 other) =>
+      NotifyingVector3.zero()..setFrom(other);
+
+  @override
+  void setValues(double x, double y, double z) {
+    super.setValues(x, y, z);
+    notifyListeners();
+  }
+
+  @override
+  void setFrom(Vector3 other) {
+    super.setFrom(other);
+    notifyListeners();
+  }
+
+  @override
+  void setZero() {
+    super.setZero();
+    notifyListeners();
+  }
+
+  @override
+  void splat(double arg) {
+    super.splat(arg);
+    notifyListeners();
+  }
+
+  @override
+  void operator []=(int i, double v) {
+    super[i] = v;
+    notifyListeners();
+  }
+
+  @override
+  set length(double l) {
+    super.length = l;
+    notifyListeners();
+  }
+
+  @override
+  double normalize() {
+    final l = super.normalize();
+    notifyListeners();
+    return l;
+  }
+
+  @override
+  void postmultiply(Matrix3 arg) {
+    super.postmultiply(arg);
+    notifyListeners();
+  }
+
+  @override
+  void add(Vector3 arg) {
+    super.add(arg);
+    notifyListeners();
+  }
+
+  @override
+  void addScaled(Vector3 arg, double factor) {
+    super.addScaled(arg, factor);
+    notifyListeners();
+  }
+
+  @override
+  void sub(Vector3 arg) {
+    super.sub(arg);
+    notifyListeners();
+  }
+
+  @override
+  void multiply(Vector3 arg) {
+    super.multiply(arg);
+    notifyListeners();
+  }
+
+  @override
+  void divide(Vector3 arg) {
+    super.divide(arg);
+    notifyListeners();
+  }
+
+  @override
+  void scale(double arg) {
+    super.scale(arg);
+    notifyListeners();
+  }
+
+  @override
+  void negate() {
+    super.negate();
+    notifyListeners();
+  }
+
+  @override
+  void absolute() {
+    super.absolute();
+    notifyListeners();
+  }
+
+  @override
+  void clamp(Vector3 min, Vector3 max) {
+    super.clamp(min, max);
+    notifyListeners();
+  }
+
+  @override
+  void clampScalar(double min, double max) {
+    super.clampScalar(min, max);
+    notifyListeners();
+  }
+
+  @override
+  void floor() {
+    super.floor();
+    notifyListeners();
+  }
+
+  @override
+  void ceil() {
+    super.ceil();
+    notifyListeners();
+  }
+
+  @override
+  void round() {
+    super.round();
+    notifyListeners();
+  }
+
+  @override
+  void roundToZero() {
+    super.roundToZero();
+    notifyListeners();
+  }
+
+  @override
+  void copyFromArray(List<double> array, [int offset = 0]) {
+    super.copyFromArray(array, offset);
+    notifyListeners();
+  }
+
+  @override
+  set xy(Vector2 arg) {
+    super.xy = arg;
+    notifyListeners();
+  }
+
+  @override
+  set yx(Vector2 arg) {
+    super.yx = arg;
+    notifyListeners();
+  }
+
+  @override
+  set x(double x) {
+    super.x = x;
+    notifyListeners();
+  }
+
+  @override
+  set y(double y) {
+    super.y = y;
+    notifyListeners();
+  }
+
+  @override
+  set z(double z) {
+    super.z = z;
+    notifyListeners();
+  }
+
+  @override
+  Float32List get storage => super.storage.asUnmodifiableView();
+}
diff --git a/packages/flame_3d/lib/src/game/transform_3d.dart b/packages/flame_3d/lib/src/game/transform_3d.dart
new file mode 100644
index 00000000000..6ef672763be
--- /dev/null
+++ b/packages/flame_3d/lib/src/game/transform_3d.dart
@@ -0,0 +1,147 @@
+import 'package:flame_3d/game.dart';
+import 'package:flutter/foundation.dart' show ChangeNotifier;
+
+/// {@template transform_3d}
+/// This class describes a generic 3D transform, which is a combination of
+/// translations, rotations and scaling. These transforms are combined into a
+/// single matrix, that can be either applied to a graphical device like the
+/// canvas, composed with another transform, or used directly to convert
+/// coordinates.
+///
+/// The transform can be visualized as 2 reference frames: a "global" and
+/// a "local". At first, these two reference frames coincide. Then, the
+/// following sequence of transforms is applied:
+///   - translation to point [position];
+///   - rotate using the [rotation];
+///   - scaling in X, Y and Z directions by [scale] factors.
+///
+/// The class is optimized for repeated use: the transform matrix is cached
+/// and then recalculated only when the underlying properties change. Moreover,
+/// recalculation of the transform is postponed until the matrix is actually
+/// requested by the user. Thus, modifying multiple properties at once does
+/// not incur the penalty of unnecessary recalculations.
+///
+/// This class implements the [ChangeNotifier] API, allowing you to subscribe
+/// for notifications whenever the transform matrix changes. In addition, you
+/// can subscribe to get notified when individual components of the transform
+/// change: [position], [scale], and [rotation].
+/// {@endtemplate}
+class Transform3D extends ChangeNotifier {
+  /// {@macro transform_3d}
+  Transform3D()
+      : _recalculate = true,
+        _rotation = NotifyingQuaternion(0, 0, 0, 0),
+        _position = NotifyingVector3.zero(),
+        _scale = NotifyingVector3.all(1),
+        _transformMatrix = Matrix4.zero() {
+    _position.addListener(_markAsModified);
+    _scale.addListener(_markAsModified);
+    _rotation.addListener(_markAsModified);
+  }
+
+  /// {@macro transform_3d}
+  ///
+  /// Create a copy of the [other] transform.
+  factory Transform3D.copy(Transform3D other) => Transform3D()..setFrom(other);
+
+  /// {@macro transform_3d}
+  ///
+  /// Create an instance of [Transform3D] and apply the [matrix] on it.
+  factory Transform3D.fromMatrix4(Matrix4 matrix) {
+    final transform = Transform3D();
+    matrix.decompose(transform.position, transform.rotation, transform.scale);
+    return transform;
+  }
+
+  /// Clone of this.
+  Transform3D clone() => Transform3D.copy(this);
+
+  /// The translation part of the transform. This translation is applied
+  /// relative to the global coordinate space.
+  ///
+  /// The returned vector can be modified by the user, and the changes
+  /// will be propagated back to the transform matrix.
+  NotifyingVector3 get position => _position;
+  set position(Vector3 position) => _position.setFrom(position);
+  final NotifyingVector3 _position;
+
+  /// X coordinate of the translation transform.
+  double get x => _position.x;
+  set x(double x) => _position.x = x;
+
+  /// Y coordinate of the translation transform.
+  double get y => _position.y;
+  set y(double y) => _position.y = y;
+
+  /// Z coordinate of the translation transform.
+  double get z => _position.z;
+  set z(double y) => _position.z = z;
+
+  NotifyingQuaternion get rotation => _rotation;
+  set rotation(Quaternion rotation) => _rotation.setFrom(rotation);
+  final NotifyingQuaternion _rotation;
+
+  /// The scale part of the transform. The default scale factor is (1, 1, 1),
+  /// a scale greater than 1 corresponds to expansion, and less than 1 is
+  /// contraction. A negative scale is also allowed, and it corresponds
+  /// to a mirror reflection around the corresponding axis.
+  /// Scale factors can be different for X, Y and Z directions.
+  ///
+  /// The returned vector can be modified by the user, and the changes
+  /// will be propagated back to the transform matrix.
+  NotifyingVector3 get scale => _scale;
+  set scale(Vector3 scale) => _scale.setFrom(scale);
+  final NotifyingVector3 _scale;
+
+  /// The total transformation matrix for the component. This matrix combines
+  /// translation, rotation and scale transforms into a single entity. The
+  /// matrix is cached and gets recalculated only when necessary.
+  ///
+  /// The returned matrix must not be modified by the user.
+  Matrix4 get transformMatrix {
+    if (_recalculate) {
+      _transformMatrix.setFromTranslationRotationScale(
+        _position,
+        _rotation,
+        _scale,
+      );
+      _recalculate = false;
+    }
+    return _transformMatrix;
+  }
+
+  final Matrix4 _transformMatrix;
+  bool _recalculate;
+
+  /// Set this to the values of the [other] [Transform3D].
+  void setFrom(Transform3D other) {
+    rotation.setFrom(other.rotation);
+    position.setFrom(other.position);
+    scale.setFrom(other.scale);
+  }
+
+  /// Check whether this transform is equal to [other], up to the given
+  /// [tolerance]. Setting tolerance to zero will check for exact equality.
+  /// Transforms are considered equal if their rotation angles are the same
+  /// or differ by a multiple of 2π, and if all other transform parameters:
+  /// translation, scale, and offset are the same.
+  ///
+  /// The [tolerance] parameter is in absolute units, not relative.
+  bool closeTo(Transform3D other, {double tolerance = 1e-10}) {
+    return (position.x - other.position.x).abs() <= tolerance &&
+        (position.y - other.position.y).abs() <= tolerance &&
+        (position.z - other.position.z).abs() <= tolerance &&
+        (rotation.x - other.rotation.x).abs() <= tolerance &&
+        (rotation.y - other.rotation.y).abs() <= tolerance &&
+        (rotation.z - other.rotation.z).abs() <= tolerance &&
+        (rotation.w - other.rotation.w).abs() <= tolerance &&
+        (scale.x - other.scale.x).abs() <= tolerance &&
+        (scale.y - other.scale.y).abs() <= tolerance &&
+        (scale.z - other.scale.z).abs() <= tolerance;
+  }
+
+  void _markAsModified() {
+    _recalculate = true;
+    notifyListeners();
+  }
+}
diff --git a/packages/flame_3d/lib/src/graphics/graphics_device.dart b/packages/flame_3d/lib/src/graphics/graphics_device.dart
new file mode 100644
index 00000000000..83a24cb8f7e
--- /dev/null
+++ b/packages/flame_3d/lib/src/graphics/graphics_device.dart
@@ -0,0 +1,190 @@
+import 'dart:typed_data';
+import 'dart:ui';
+
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flame_3d/src/graphics/joints_info.dart';
+import 'package:flutter_gpu/gpu.dart' as gpu;
+
+enum BlendState {
+  additive,
+  alphaBlend,
+  opaque,
+}
+
+enum DepthStencilState {
+  standard,
+  depthRead,
+  none,
+}
+
+/// {@template graphics_device}
+/// The Graphical Device provides a way for developers to interact with the GPU
+/// by binding different resources to it.
+///
+/// A single render call starts with a call to [begin] and only ends when [end]
+/// is called. Any resource that gets bound to the device in between these two
+/// method calls will be uploaded to the GPU and returns as an [Image] in [end].
+/// {@endtemplate}
+class GraphicsDevice {
+  /// {@macro graphics_device}
+  GraphicsDevice({this.clearValue = const Color(0x00000000)});
+
+  /// The clear value, used to clear out the screen.
+  final Color clearValue;
+
+  late gpu.CommandBuffer _commandBuffer;
+  late gpu.HostBuffer _hostBuffer;
+  late gpu.RenderPass _renderPass;
+  late gpu.RenderTarget _renderTarget;
+
+  Matrix4 get model => _modelMatrix;
+  final Matrix4 _modelMatrix = Matrix4.zero();
+
+  Matrix4 get view => _viewMatrix;
+  final Matrix4 _viewMatrix = Matrix4.zero();
+
+  Matrix4 get projection => _projectionMatrix;
+  final Matrix4 _projectionMatrix = Matrix4.zero();
+
+  Size _previousSize = Size.zero;
+
+  /// Must be set by the rendering pipeline before elements are bound.
+  /// Can be accessed by elements in their bind method.
+  final JointsInfo jointsInfo = JointsInfo();
+
+  /// Must be set by the rendering pipeline before elements are bound.
+  /// Can be accessed by elements in their bind method.
+  final LightingInfo lightingInfo = LightingInfo();
+
+  /// Begin a new rendering batch.
+  ///
+  /// After [begin] is called the graphics device can be used to bind resources
+  /// like [Mesh]s, [Material]s and [Texture]s.
+  ///
+  /// Once you have executed all your bindings you can submit the batch to the
+  /// GPU with [end].
+  void begin(
+    Size size, {
+    // TODO(wolfenrain): unused at the moment
+    BlendState blendState = BlendState.alphaBlend,
+    // TODO(wolfenrain): used incorrectly
+    DepthStencilState depthStencilState = DepthStencilState.depthRead,
+  }) {
+    _commandBuffer = gpu.gpuContext.createCommandBuffer();
+    _hostBuffer = gpu.gpuContext.createHostBuffer();
+    _renderPass = _commandBuffer.createRenderPass(_getRenderTarget(size))
+      ..setColorBlendEnable(true)
+      ..setColorBlendEquation(
+        gpu.ColorBlendEquation(
+          sourceAlphaBlendFactor: blendState == BlendState.alphaBlend
+              ? gpu.BlendFactor.oneMinusSourceAlpha
+              : gpu.BlendFactor.one,
+        ),
+      )
+      ..setDepthWriteEnable(depthStencilState == DepthStencilState.depthRead)
+      ..setDepthCompareOperation(
+        // TODO(wolfenrain): this is not correctly implemented AT all.
+        switch (depthStencilState) {
+          DepthStencilState.none => gpu.CompareFunction.never,
+          DepthStencilState.standard => gpu.CompareFunction.always,
+          DepthStencilState.depthRead => gpu.CompareFunction.less,
+        },
+      );
+  }
+
+  /// Submit the rendering batch and it's the commands to the GPU and return
+  /// the result.
+  Image end() {
+    _commandBuffer.submit();
+    return _renderTarget.colorAttachments[0].texture.asImage();
+  }
+
+  void clearBindings() {
+    _renderPass.clearBindings();
+  }
+
+  /// Bind a [mesh].
+  void bindMesh(Mesh mesh) {
+    _renderPass.clearBindings();
+    mesh.bind(this);
+    _renderPass.draw();
+  }
+
+  /// Bind a [surface].
+  void bindSurface(Surface surface) {
+    _renderPass.clearBindings();
+    if (surface.material != null) {
+      bindMaterial(surface.material!);
+    }
+
+    _renderPass.bindVertexBuffer(
+      gpu.BufferView(
+        surface.resource!,
+        offsetInBytes: 0,
+        lengthInBytes: surface.verticesBytes,
+      ),
+      surface.vertexCount,
+    );
+
+    _renderPass.bindIndexBuffer(
+      gpu.BufferView(
+        surface.resource!,
+        offsetInBytes: surface.verticesBytes,
+        lengthInBytes: surface.indicesBytes,
+      ),
+      gpu.IndexType.int16,
+      surface.indexCount,
+    );
+
+    _renderPass.draw();
+  }
+
+  /// Bind a [material] and set up the buffer correctly.
+  void bindMaterial(Material material) {
+    _renderPass.bindPipeline(material.resource);
+
+    material.bind(this);
+    material.vertexShader.bind(this);
+    material.fragmentShader.bind(this);
+  }
+
+  /// Bind a uniform [slot] to the [buffer].
+  void bindUniform(gpu.UniformSlot slot, ByteBuffer buffer) {
+    _renderPass.bindUniform(slot, _hostBuffer.emplace(buffer.asByteData()));
+  }
+
+  /// Bind a uniform [slot] to the [texture].
+  void bindTexture(gpu.UniformSlot slot, Texture texture) {
+    _renderPass.bindTexture(slot, texture.resource);
+  }
+
+  gpu.RenderTarget _getRenderTarget(Size size) {
+    if (_previousSize != size) {
+      _previousSize = size;
+
+      final colorTexture = gpu.gpuContext.createTexture(
+        gpu.StorageMode.devicePrivate,
+        size.width.toInt(),
+        size.height.toInt(),
+      );
+
+      final depthTexture = gpu.gpuContext.createTexture(
+        gpu.StorageMode.deviceTransient,
+        size.width.toInt(),
+        size.height.toInt(),
+        format: gpu.gpuContext.defaultDepthStencilFormat,
+      );
+
+      _renderTarget = gpu.RenderTarget.singleColor(
+        gpu.ColorAttachment(texture: colorTexture!, clearValue: clearValue),
+        depthStencilAttachment: gpu.DepthStencilAttachment(
+          texture: depthTexture!,
+          depthClearValue: 1.0,
+        ),
+      );
+    }
+
+    return _renderTarget;
+  }
+}
diff --git a/packages/flame_3d/lib/src/graphics/joints_info.dart b/packages/flame_3d/lib/src/graphics/joints_info.dart
new file mode 100644
index 00000000000..c21204b211c
--- /dev/null
+++ b/packages/flame_3d/lib/src/graphics/joints_info.dart
@@ -0,0 +1,13 @@
+import 'package:flame_3d/core.dart';
+
+class JointsInfo {
+  /// Joints per surface idx
+  Map<int, List<Matrix4>> jointTransformsPerSurface = {};
+
+  /// Joints for the current surface
+  List<Matrix4> jointTransforms = [];
+
+  void setSurface(int surfaceIdx) {
+    jointTransforms = jointTransformsPerSurface[surfaceIdx] ?? [];
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/light.dart b/packages/flame_3d/lib/src/resources/light.dart
new file mode 100644
index 00000000000..150a240e8c4
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/light.dart
@@ -0,0 +1,5 @@
+export 'light/ambient_light.dart';
+export 'light/light.dart';
+export 'light/light_source.dart';
+export 'light/lighting_info.dart';
+export 'light/point_light.dart';
diff --git a/packages/flame_3d/lib/src/resources/light/ambient_light.dart b/packages/flame_3d/lib/src/resources/light/ambient_light.dart
new file mode 100644
index 00000000000..5ef07ba93d3
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/light/ambient_light.dart
@@ -0,0 +1,15 @@
+import 'dart:ui' show Color;
+
+import 'package:flame_3d/resources.dart';
+
+class AmbientLight extends LightSource {
+  AmbientLight({
+    super.color = const Color(0xFFFFFFFF),
+    super.intensity = 0.2,
+  });
+
+  void apply(Shader shader) {
+    shader.setColor('AmbientLight.color', color);
+    shader.setFloat('AmbientLight.intensity', intensity);
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/light/light.dart b/packages/flame_3d/lib/src/resources/light/light.dart
new file mode 100644
index 00000000000..e688caefcff
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/light/light.dart
@@ -0,0 +1,27 @@
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template light}
+/// A [Resource] that represents a light source that is positioned in the scene
+/// and changes how other objects are rendered.
+///
+/// This class isn't a true resource, it does not upload it self to the GPU.
+/// Instead, it is used to modify how other resources are uploaded.
+///
+/// {@endtemplate}
+class Light extends Resource<void> {
+  final Transform3D transform;
+  final LightSource source;
+
+  /// {@macro light}
+  Light({
+    required this.transform,
+    required this.source,
+  }) : super(null);
+
+  void apply(int index, Shader shader) {
+    shader.setVector3('Light$index.position', transform.position);
+    shader.setColor('Light$index.color', source.color);
+    shader.setFloat('Light$index.intensity', source.intensity);
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/light/light_source.dart b/packages/flame_3d/lib/src/resources/light/light_source.dart
new file mode 100644
index 00000000000..7b7992f924a
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/light/light_source.dart
@@ -0,0 +1,16 @@
+import 'dart:ui' show Color;
+
+import 'package:flame_3d/resources.dart';
+
+/// Describes the properties of a light source.
+/// There are three types of light sources: point, directional, and spot.
+/// Currently only [PointLight] is implemented.
+abstract class LightSource {
+  final Color color;
+  final double intensity;
+
+  LightSource({
+    required this.color,
+    required this.intensity,
+  });
+}
diff --git a/packages/flame_3d/lib/src/resources/light/lighting_info.dart b/packages/flame_3d/lib/src/resources/light/lighting_info.dart
new file mode 100644
index 00000000000..f46cf77c3e3
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/light/lighting_info.dart
@@ -0,0 +1,48 @@
+import 'package:flame_3d/resources.dart';
+
+class LightingInfo {
+  Iterable<Light> lights = [];
+
+  void apply(Shader shader) {
+    _applyAmbientLight(shader);
+    _applyPointLights(shader);
+  }
+
+  void _applyAmbientLight(Shader shader) {
+    final ambient = _extractAmbientLight(lights);
+    ambient.apply(shader);
+  }
+
+  void _applyPointLights(Shader shader) {
+    final pointLights = lights.where((e) => e.source is PointLight);
+    final numLights = pointLights.length;
+    if (numLights > 3) {
+      // temporary, until we support dynamic arrays
+      throw Exception('At most 3 point lights are allowed');
+    }
+
+    shader.setUint('LightsInfo.numLights', numLights);
+    for (final (idx, light) in pointLights.indexed) {
+      light.apply(idx, shader);
+    }
+  }
+
+  AmbientLight _extractAmbientLight(Iterable<Light> lights) {
+    final ambient = lights.where((e) => e.source is AmbientLight);
+    if (ambient.isEmpty) {
+      return AmbientLight();
+    }
+    if (ambient.length > 1) {
+      throw Exception('At most one ambient light is allowed');
+    }
+    return ambient.first.source as AmbientLight;
+  }
+
+  static List<UniformSlot> shaderSlots = [
+    UniformSlot.value('AmbientLight', {'color', 'intensity'}),
+    UniformSlot.value('LightsInfo', {'numLights'}),
+    UniformSlot.value('Light0', {'position', 'color', 'intensity'}),
+    UniformSlot.value('Light1', {'position', 'color', 'intensity'}),
+    UniformSlot.value('Light2', {'position', 'color', 'intensity'}),
+  ];
+}
diff --git a/packages/flame_3d/lib/src/resources/light/point_light.dart b/packages/flame_3d/lib/src/resources/light/point_light.dart
new file mode 100644
index 00000000000..7e60bcfe3f6
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/light/point_light.dart
@@ -0,0 +1,9 @@
+import 'package:flame_3d/resources.dart';
+
+/// A point light that emits light in all directions equally.
+class PointLight extends LightSource {
+  PointLight({
+    required super.color,
+    required super.intensity,
+  });
+}
diff --git a/packages/flame_3d/lib/src/resources/material.dart b/packages/flame_3d/lib/src/resources/material.dart
new file mode 100644
index 00000000000..eefe422c3ef
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/material.dart
@@ -0,0 +1,2 @@
+export 'material/material.dart';
+export 'material/spatial_material.dart';
diff --git a/packages/flame_3d/lib/src/resources/material/material.dart b/packages/flame_3d/lib/src/resources/material/material.dart
new file mode 100644
index 00000000000..753838efee7
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/material/material.dart
@@ -0,0 +1,53 @@
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flutter_gpu/gpu.dart' as gpu;
+
+/// {@template material}
+/// Base material [Resource], it holds the shader library that should be used
+/// for the texture.
+/// {@endtemplate}
+abstract class Material extends Resource<gpu.RenderPipeline> {
+  /// {@macro material}
+  Material({
+    required Shader vertexShader,
+    required Shader fragmentShader,
+  })  : _vertexShader = vertexShader,
+        _fragmentShader = fragmentShader,
+        super(
+          gpu.gpuContext.createRenderPipeline(
+            vertexShader.compile().resource,
+            fragmentShader.compile().resource,
+          ),
+        );
+
+  @override
+  gpu.RenderPipeline get resource {
+    var resource = super.resource;
+    if (_recreateResource) {
+      resource = super.resource = gpu.gpuContext.createRenderPipeline(
+        _vertexShader.compile().resource,
+        _fragmentShader.compile().resource,
+      );
+      _recreateResource = false;
+    }
+    return resource;
+  }
+
+  bool _recreateResource = false;
+
+  Shader get vertexShader => _vertexShader;
+  Shader _vertexShader;
+  set vertexShader(Shader shader) {
+    _vertexShader = shader;
+    _recreateResource = true;
+  }
+
+  Shader get fragmentShader => _fragmentShader;
+  Shader _fragmentShader;
+  set fragmentShader(Shader shader) {
+    _fragmentShader = shader;
+    _recreateResource = true;
+  }
+
+  void bind(GraphicsDevice device) {}
+}
diff --git a/packages/flame_3d/lib/src/resources/material/spatial_material.dart b/packages/flame_3d/lib/src/resources/material/spatial_material.dart
new file mode 100644
index 00000000000..eb3b088dfda
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/material/spatial_material.dart
@@ -0,0 +1,111 @@
+import 'dart:ui';
+
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+
+class SpatialMaterial extends Material {
+  SpatialMaterial({
+    Texture? albedoTexture,
+    Color albedoColor = const Color(0xFFFFFFFF),
+    this.metallic = 0.8,
+    this.roughness = 0.6,
+  })  : albedoTexture = albedoTexture ?? Texture.standard,
+        super(
+          vertexShader: Shader(
+            name: 'TextureVertex',
+            slots: [
+              UniformSlot.value('VertexInfo', {
+                'model',
+                'view',
+                'projection',
+              }),
+              UniformSlot.value(
+                'JointMatrices',
+                List.generate(_maxJoints, (idx) => 'joint$idx').toSet(),
+              ),
+            ],
+          ),
+          fragmentShader: Shader(
+            name: 'TextureFragment',
+            slots: [
+              UniformSlot.sampler('albedoTexture'),
+              UniformSlot.value('Material', {
+                'albedoColor',
+                'metallic',
+                'roughness',
+              }),
+              ...LightingInfo.shaderSlots,
+              UniformSlot.value('Camera', {'position'}),
+            ],
+          ),
+        ) {
+    this.albedoColor = albedoColor;
+  }
+
+  /// The material's base color.
+  Color get albedoColor => _albedoColor;
+  set albedoColor(Color color) {
+    _albedoColor = color;
+    _albedoCache.copyFromArray(color.storage);
+  }
+
+  late Color _albedoColor;
+  final Vector3 _albedoCache = Vector3.zero();
+
+  /// The texture that will be multiplied by [albedoColor].
+  Texture albedoTexture;
+
+  double metallic;
+
+  double roughness;
+
+  @override
+  void bind(GraphicsDevice device) {
+    _bindVertexInfo(device);
+    _bindJointMatrices(device);
+    _bindMaterial(device);
+    _bindCamera(device);
+  }
+
+  void _bindVertexInfo(GraphicsDevice device) {
+    vertexShader
+      ..setMatrix4('VertexInfo.model', device.model)
+      ..setMatrix4('VertexInfo.view', device.view)
+      ..setMatrix4('VertexInfo.projection', device.projection);
+  }
+
+  void _bindJointMatrices(GraphicsDevice device) {
+    final jointTransforms = device.jointsInfo.jointTransforms;
+    if (jointTransforms.length > _maxJoints) {
+      throw Exception(
+        'At most $_maxJoints joints per surface are supported;'
+        ' found ${jointTransforms.length}',
+      );
+    }
+    for (final (idx, transform) in jointTransforms.indexed) {
+      vertexShader.setMatrix4('JointMatrices.joint$idx', transform);
+    }
+  }
+
+  void _bindMaterial(GraphicsDevice device) {
+    _applyLights(device);
+    fragmentShader
+      ..setTexture('albedoTexture', albedoTexture)
+      ..setVector3('Material.albedoColor', _albedoCache)
+      ..setFloat('Material.metallic', metallic)
+      ..setFloat('Material.roughness', roughness);
+  }
+
+  void _bindCamera(GraphicsDevice device) {
+    final invertedView = Matrix4.inverted(device.view);
+    final cameraPosition = invertedView.transform3(Vector3.zero());
+    fragmentShader.setVector3('Camera.position', cameraPosition);
+  }
+
+  void _applyLights(GraphicsDevice device) {
+    device.lightingInfo.apply(fragmentShader);
+  }
+
+  static const _maxJoints = 16;
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh.dart b/packages/flame_3d/lib/src/resources/mesh.dart
new file mode 100644
index 00000000000..532abc9de59
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh.dart
@@ -0,0 +1,7 @@
+export 'mesh/cuboid_mesh.dart';
+export 'mesh/cylinder_mesh.dart';
+export 'mesh/mesh.dart';
+export 'mesh/plane_mesh.dart';
+export 'mesh/sphere_mesh.dart';
+export 'mesh/surface.dart';
+export 'mesh/vertex.dart';
diff --git a/packages/flame_3d/lib/src/resources/mesh/cuboid_mesh.dart b/packages/flame_3d/lib/src/resources/mesh/cuboid_mesh.dart
new file mode 100644
index 00000000000..d43a320f9b9
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/cuboid_mesh.dart
@@ -0,0 +1,179 @@
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template cuboid_mesh}
+/// Represents a Cuboid's geometry with a single surface.
+/// {@endtemplate}
+class CuboidMesh extends Mesh {
+  /// {@macro cuboid_mesh}
+  CuboidMesh({
+    required Vector3 size,
+    Material? material,
+    bool useFaceNormals = true,
+  }) {
+    final Vector3(:x, :y, :z) = size / 2;
+
+    Vertex vertex({
+      required Vector3 position,
+      required Vector2 texCoord,
+      required Vector3 normal,
+    }) {
+      return Vertex(
+        position: position,
+        texCoord: texCoord,
+        normal: useFaceNormals ? normal : null,
+      );
+    }
+
+    final vertices = [
+      // Face 1 (front)
+      vertex(
+        position: Vector3(-x, -y, -z),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(0, 0, -1),
+      ),
+      vertex(
+        position: Vector3(x, -y, -z),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(0, 0, -1),
+      ),
+      vertex(
+        position: Vector3(x, y, -z),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(0, 0, -1),
+      ),
+      vertex(
+        position: Vector3(-x, y, -z),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(0, 0, -1),
+      ),
+
+      // Face 2 (back)
+      vertex(
+        position: Vector3(-x, -y, z),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(0, 0, 1),
+      ),
+      vertex(
+        position: Vector3(x, -y, z),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(0, 0, 1),
+      ),
+      vertex(
+        position: Vector3(x, y, z),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(0, 0, 1),
+      ),
+      vertex(
+        position: Vector3(-x, y, z),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(0, 0, 1),
+      ),
+
+      // Face 3 (left)
+      vertex(
+        position: Vector3(-x, -y, z),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(-1, 0, 0),
+      ),
+      vertex(
+        position: Vector3(-x, -y, -z),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(-1, 0, 0),
+      ),
+      vertex(
+        position: Vector3(-x, y, -z),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(-1, 0, 0),
+      ),
+      vertex(
+        position: Vector3(-x, y, z),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(-1, 0, 0),
+      ),
+
+      // Face 4 (right)
+      vertex(
+        position: Vector3(x, -y, -z),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(1, 0, 0),
+      ),
+      vertex(
+        position: Vector3(x, -y, z),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(1, 0, 0),
+      ),
+      vertex(
+        position: Vector3(x, y, z),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(1, 0, 0),
+      ),
+      vertex(
+        position: Vector3(x, y, -z),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(1, 0, 0),
+      ),
+
+      // Face 5 (top)
+      vertex(
+        position: Vector3(-x, y, -z),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(0, 1, 0),
+      ),
+      vertex(
+        position: Vector3(x, y, -z),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(0, 1, 0),
+      ),
+      vertex(
+        position: Vector3(x, y, z),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(0, 1, 0),
+      ),
+      vertex(
+        position: Vector3(-x, y, z),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(0, 1, 0),
+      ),
+
+      // Face 6 (bottom)
+      vertex(
+        position: Vector3(-x, -y, z),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(0, -1, 0),
+      ),
+      vertex(
+        position: Vector3(x, -y, z),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(0, -1, 0),
+      ),
+      vertex(
+        position: Vector3(x, -y, -z),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(0, -1, 0),
+      ),
+      vertex(
+        position: Vector3(-x, -y, -z),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(0, -1, 0),
+      ),
+    ];
+
+    final indices = [
+      0, 1, 2, 2, 3, 0, // Face 1
+      4, 5, 6, 6, 7, 4, // Face 2
+      8, 9, 10, 10, 11, 8, // Face 3
+      12, 13, 14, 14, 15, 12, // Face 4
+      16, 17, 18, 18, 19, 16, // Face 5
+      20, 21, 22, 22, 23, 20, // Face 6
+    ];
+
+    addSurface(
+      Surface(
+        vertices: vertices,
+        indices: indices,
+        material: material,
+      ),
+    );
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh/cylinder_mesh.dart b/packages/flame_3d/lib/src/resources/mesh/cylinder_mesh.dart
new file mode 100644
index 00000000000..7ca8e1c826f
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/cylinder_mesh.dart
@@ -0,0 +1,94 @@
+import 'dart:math' as math;
+
+import 'package:flame/geometry.dart';
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+class CylinderMesh extends Mesh {
+  CylinderMesh({
+    required double radius,
+    required double height,
+    int segments = 16,
+    Material? material,
+  }) {
+    final vertices = <Vertex>[];
+    final halfHeight = height / 2.0;
+
+    // top circle
+    for (var i = 0; i <= segments; i++) {
+      final theta = i * tau / segments;
+      final x = radius * math.cos(theta);
+      final y = halfHeight;
+      final z = radius * math.sin(theta);
+
+      final u = (1 + math.cos(theta)) * 0.5;
+      final v = (1 + math.sin(theta)) * 0.5;
+
+      vertices.add(
+        Vertex(position: Vector3(x, y, z), texCoord: Vector2(u, v)),
+      );
+    }
+
+    // top center
+    vertices.add(
+      Vertex(position: Vector3(0, halfHeight, 0), texCoord: Vector2(0.5, 0.5)),
+    );
+
+    // bottom circle
+    for (var i = 0; i <= segments; i++) {
+      final theta = i * tau / segments;
+      final x = radius * math.cos(theta);
+      final y = -halfHeight;
+      final z = radius * math.sin(theta);
+
+      final u = (1 + math.cos(theta)) * 0.5;
+      final v = (1 + math.sin(theta)) * 0.5;
+
+      vertices.add(
+        Vertex(position: Vector3(x, y, z), texCoord: Vector2(u, v)),
+      );
+    }
+
+    // bottom center
+    vertices.add(
+      Vertex(position: Vector3(0, -halfHeight, 0), texCoord: Vector2(0.5, 0.5)),
+    );
+
+    final indices = <int>[];
+
+    // top circle indices
+    for (var i = 0; i < segments; i++) {
+      indices.add(i);
+      indices.add(i + 1);
+      indices.add(segments + 1); // center index
+    }
+
+    // bottom circle indices
+    for (var i = 0; i < segments; i++) {
+      indices.add(segments + 1 + i);
+      indices.add(segments + 1 + i + 1);
+      indices.add(segments * 2 + 2); // center index
+    }
+
+    // side indices
+    for (var i = 0; i < segments; i++) {
+      final topIndex = i;
+      final bottomIndex = i + segments + 1;
+      indices.add(topIndex);
+      indices.add(bottomIndex);
+      indices.add(topIndex + 1);
+
+      indices.add(bottomIndex);
+      indices.add(bottomIndex + 1);
+      indices.add(topIndex + 1);
+    }
+
+    addSurface(
+      Surface(
+        vertices: vertices,
+        indices: indices,
+        material: material,
+      ),
+    );
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh/mesh.dart b/packages/flame_3d/lib/src/resources/mesh/mesh.dart
new file mode 100644
index 00000000000..c2fa8b42b13
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/mesh.dart
@@ -0,0 +1,88 @@
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template mesh}
+/// A [Resource] that represents a geometric shape that is divided up in one or
+/// more [Surface]s.
+///
+/// This class isn't a true resource, it does not upload it self to the GPU.
+/// Instead it uploads [Surface]s, it acts as a proxy.
+/// {@endtemplate}
+class Mesh extends Resource<void> {
+  /// {@macro mesh}
+  Mesh()
+      : _surfaces = [],
+        super(null);
+
+  final List<Surface> _surfaces;
+  Aabb3? _aabb;
+
+  /// The AABB of the mesh.
+  ///
+  /// This is the sum of all the AABB's of the surfaces it contains.
+  Aabb3 get aabb => _aabb ??= _recomputeAabb3();
+
+  int get vertexCount => _surfaces.fold(0, (p, e) => p + e.vertexCount);
+
+  void bind(GraphicsDevice device) {
+    for (final (idx, surface) in _surfaces.indexed) {
+      device.jointsInfo.setSurface(idx);
+      device.bindSurface(surface);
+    }
+  }
+
+  /// The total surface count of the mesh.
+  int get surfaceCount => _surfaces.length;
+
+  /// An unmodifiable iterable over the list of the surfaces.
+  ///
+  /// Note: if you modify the geometry of any [Surface] within this list,
+  /// you will need to call [updateBounds] to update the mesh's bounds.
+  Iterable<Surface> get surfaces => _surfaces;
+
+  /// Add a new [surface] to this mesh.
+  /// Return the index of the newly added surface.
+  /// Surfaces are always added to the end of the list.
+  int addSurface(Surface surface) {
+    _surfaces.add(surface);
+    updateBounds();
+    return _surfaces.length - 1;
+  }
+
+  /// Replace the surface at [index] with [surface].
+  void updateSurface(int index, Surface surface) {
+    _surfaces[index] = surface;
+    updateBounds();
+  }
+
+  /// Remove the surface at [index].
+  void removeSurface(int index) {
+    _surfaces.removeAt(index);
+    updateBounds();
+  }
+
+  /// Update the surfaces of the mesh, making sure to recompute the bounds
+  /// after.
+  void updateSurfaces(void Function(List<Surface> surfaces) update) {
+    update(_surfaces);
+    updateBounds();
+  }
+
+  /// Must be called when the mesh has been modified.
+  void updateBounds() {
+    _aabb = null;
+  }
+
+  Aabb3 _recomputeAabb3() {
+    var aabb = Aabb3();
+    for (var i = 0; i < _surfaces.length; i++) {
+      if (i == 0) {
+        aabb = _surfaces[i].aabb;
+      } else {
+        aabb.hull(_surfaces[i].aabb);
+      }
+    }
+    return aabb;
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh/plane_mesh.dart b/packages/flame_3d/lib/src/resources/mesh/plane_mesh.dart
new file mode 100644
index 00000000000..faea9893c1c
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/plane_mesh.dart
@@ -0,0 +1,45 @@
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template plane_mesh}
+/// Represents a 2D Plane's geometry with a single surface.
+/// {@endtemplate}
+class PlaneMesh extends Mesh {
+  /// {@macro plane_mesh}
+  PlaneMesh({
+    required Vector2 size,
+    Material? material,
+  }) {
+    final Vector2(:x, :y) = size / 2;
+
+    final vertices = [
+      Vertex(
+        position: Vector3(-x, 0, -y),
+        texCoord: Vector2(0, 0),
+        normal: Vector3(0, 1, 0),
+      ),
+      Vertex(
+        position: Vector3(x, 0, -y),
+        texCoord: Vector2(1, 0),
+        normal: Vector3(0, 1, 0),
+      ),
+      Vertex(
+        position: Vector3(x, 0, y),
+        texCoord: Vector2(1, 1),
+        normal: Vector3(0, 1, 0),
+      ),
+      Vertex(
+        position: Vector3(-x, 0, y),
+        texCoord: Vector2(0, 1),
+        normal: Vector3(0, 1, 0),
+      ),
+    ];
+    addSurface(
+      Surface(
+        vertices: vertices,
+        indices: [0, 1, 2, 2, 3, 0],
+        material: material,
+      ),
+    );
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh/sphere_mesh.dart b/packages/flame_3d/lib/src/resources/mesh/sphere_mesh.dart
new file mode 100644
index 00000000000..5063c939388
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/sphere_mesh.dart
@@ -0,0 +1,59 @@
+import 'dart:math' as math;
+
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template sphere_mesh}
+/// Represents a Sphere's geometry with a single surface.
+/// {@endtemplate}
+class SphereMesh extends Mesh {
+  /// {@macro sphere_mesh}
+  SphereMesh({
+    required double radius,
+    int segments = 64,
+    Material? material,
+  }) {
+    final vertices = <Vertex>[];
+    for (var i = 0; i <= segments; i++) {
+      final theta = i * (2 * math.pi) / segments;
+      for (var j = 0; j <= segments; j++) {
+        final phi = j * math.pi / segments;
+
+        final x = radius * math.sin(phi) * math.cos(theta);
+        final y = radius * math.cos(phi);
+        final z = radius * math.sin(phi) * math.sin(theta);
+
+        final u = theta / (2 * math.pi);
+        final v = phi / math.pi;
+
+        vertices.add(
+          Vertex(position: Vector3(x, y, z), texCoord: Vector2(u, v)),
+        );
+      }
+    }
+
+    final indices = <int>[];
+    for (var i = 0; i < segments; i++) {
+      for (var j = 0; j < segments; j++) {
+        final first = i * (segments + 1) + j;
+        final second = first + segments + 1;
+
+        indices.add(first);
+        indices.add(second);
+        indices.add(first + 1);
+
+        indices.add(second);
+        indices.add(second + 1);
+        indices.add(first + 1);
+      }
+    }
+
+    addSurface(
+      Surface(
+        vertices: vertices,
+        indices: indices,
+        material: material,
+      ),
+    );
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh/surface.dart b/packages/flame_3d/lib/src/resources/mesh/surface.dart
new file mode 100644
index 00000000000..b561768b47a
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/surface.dart
@@ -0,0 +1,128 @@
+import 'dart:math' as math;
+import 'dart:typed_data';
+
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flutter_gpu/gpu.dart' as gpu;
+
+enum PrimitiveType {
+  triangles,
+}
+
+/// {@template surface}
+/// Base surface [Resource], it describes a single surface to be rendered.
+/// {@endtemplate}
+class Surface extends Resource<gpu.DeviceBuffer?> {
+  /// {@macro surface}
+  Surface({
+    required List<Vertex> vertices,
+    required List<int> indices,
+    this.material,
+    this.jointMap,
+    /**
+     * If `true`, the normals will be calculated if they are not provided.
+     */
+    bool calculateNormals = true,
+  }) : super(null) {
+    final normalizedVertices = _normalize(
+      vertices: vertices,
+      indices: indices,
+      calculateNormals: calculateNormals,
+    );
+    // `TODO`(bdero): This should have an attribute map instead and be fully SoA
+    // but vertex attributes in Impeller aren't flexible enough yet.
+    // See also https://github.com/flutter/flutter/issues/116168.
+    _vertices = Float32List.fromList(
+      normalizedVertices.fold([], (p, v) => p..addAll(v.storage)),
+    ).buffer;
+    _vertexCount = normalizedVertices.length;
+
+    _indices = Uint16List.fromList(indices).buffer;
+    _indexCount = indices.length;
+
+    _calculateAabb(normalizedVertices);
+  }
+
+  Material? material;
+  Map<int, int>? jointMap;
+
+  Aabb3 get aabb => _aabb;
+  late Aabb3 _aabb;
+
+  int get verticesBytes => _vertices.lengthInBytes;
+  late ByteBuffer _vertices;
+
+  int get vertexCount => _vertexCount;
+  late int _vertexCount;
+
+  int get indicesBytes => _indices.lengthInBytes;
+  late ByteBuffer _indices;
+
+  int get indexCount => _indexCount;
+  late int _indexCount;
+
+  @override
+  gpu.DeviceBuffer? get resource {
+    var resource = super.resource;
+    final sizeInBytes = _vertices.lengthInBytes + _indices.lengthInBytes;
+    if (resource?.sizeInBytes != sizeInBytes) {
+      // Store the device buffer in the resource parent.
+      resource = super.resource = gpu.gpuContext.createDeviceBuffer(
+        gpu.StorageMode.hostVisible,
+        sizeInBytes,
+      );
+
+      resource
+        ?..overwrite(_vertices.asByteData())
+        ..overwrite(
+          _indices.asByteData(),
+          destinationOffsetInBytes: _vertices.lengthInBytes,
+        );
+    }
+    return resource;
+  }
+
+  void _calculateAabb(List<Vertex> vertices) {
+    var minX = double.infinity;
+    var minY = double.infinity;
+    var minZ = double.infinity;
+    var maxX = double.negativeInfinity;
+    var maxY = double.negativeInfinity;
+    var maxZ = double.negativeInfinity;
+
+    for (final vertex in vertices) {
+      minX = math.min(minX, vertex.position.x);
+      minY = math.min(minY, vertex.position.y);
+      minZ = math.min(minZ, vertex.position.z);
+      maxX = math.max(maxX, vertex.position.x);
+      maxY = math.max(maxY, vertex.position.y);
+      maxZ = math.max(maxZ, vertex.position.z);
+    }
+
+    _aabb = Aabb3.minMax(
+      Vector3(minX, minY, minZ),
+      Vector3(maxX, maxY, maxZ),
+    );
+  }
+
+  static List<Vertex> _normalize({
+    required List<Vertex> vertices,
+    required List<int> indices,
+    required bool calculateNormals,
+  }) {
+    final recalculate =
+        calculateNormals && vertices.any((e) => e.normal == null);
+    if (!recalculate) {
+      return vertices;
+    }
+
+    final normals = Vertex.calculateVertexNormals(
+      vertices.map((e) => e.position.mutable).toList(),
+      indices,
+    );
+    return [
+      for (final (i, v) in vertices.indexed)
+        v.copyWith(normal: v.normal?.mutable ?? normals[i]),
+    ];
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/mesh/vertex.dart b/packages/flame_3d/lib/src/resources/mesh/vertex.dart
new file mode 100644
index 00000000000..a11e8801fda
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/mesh/vertex.dart
@@ -0,0 +1,124 @@
+import 'dart:typed_data';
+import 'dart:ui' show Color;
+
+import 'package:flame_3d/game.dart';
+import 'package:meta/meta.dart';
+
+/// {@template vertex}
+/// Represents a vertex in 3D space.
+///
+/// A vertex consists out of space coordinates, UV/texture coordinates and a
+/// color.
+/// {@endtemplate}
+@immutable
+class Vertex {
+  /// {@macro vertex}
+  Vertex({
+    required Vector3 position,
+    required Vector2 texCoord,
+    this.color = const Color(0xFFFFFFFF),
+    Vector3? normal,
+    Vector4? joints,
+    Vector4? weights,
+  })  : position = position.immutable,
+        texCoord = texCoord.immutable,
+        normal = normal?.immutable,
+        joints = joints?.immutable,
+        weights = weights?.immutable,
+        _storage = Float32List.fromList([
+          ...position.storage, // 1, 2, 3
+          ...texCoord.storage, // 4, 5
+          ...color.storage, // 6, 7, 8, 9
+          ...(normal ?? Vector3.zero()).storage, // 10, 11, 12
+          ...(joints ?? Vector4.zero()).storage, // 13, 14, 15, 16
+          ...(weights ?? Vector4.zero()).storage, // 17, 18, 19, 20
+        ]);
+
+  Float32List get storage => _storage;
+  final Float32List _storage;
+
+  /// The position of the vertex in 3D space.
+  final ImmutableVector3 position;
+
+  /// The UV coordinates of the texture to map.
+  final ImmutableVector2 texCoord;
+
+  /// The normal vector of the vertex.
+  final ImmutableVector3? normal;
+
+  /// The joints of the vertex.
+  final ImmutableVector4? joints;
+
+  /// The weights of the vertex.
+  final ImmutableVector4? weights;
+
+  /// The color on the vertex.
+  final Color color;
+
+  @override
+  bool operator ==(Object other) =>
+      other is Vertex &&
+      position == other.position &&
+      texCoord == other.texCoord &&
+      normal == other.normal &&
+      color == other.color &&
+      joints == other.joints &&
+      weights == other.weights;
+
+  @override
+  int get hashCode => Object.hashAll([
+        position,
+        texCoord,
+        normal,
+        color,
+        joints,
+        weights,
+      ]);
+
+  Vertex copyWith({
+    Vector3? position,
+    Vector2? texCoord,
+    Vector3? normal,
+    Color? color,
+    Vector4? joints,
+    Vector4? weights,
+  }) {
+    // TODO(wolfenrain): optimize this.
+    return Vertex(
+      position: position ?? this.position.mutable,
+      texCoord: texCoord ?? this.texCoord.mutable,
+      normal: normal ?? this.normal?.mutable,
+      color: color ?? this.color,
+      joints: joints ?? this.joints?.mutable,
+      weights: weights ?? this.weights?.mutable,
+    );
+  }
+
+  static List<Vector3> calculateVertexNormals(
+    List<Vector3> vertices,
+    List<int> indices,
+  ) {
+    final normals = List.filled(vertices.length, Vector3.zero());
+    for (var i = 0; i < indices.length; i += 3) {
+      final i0 = indices[i];
+      final i1 = indices[i + 1];
+      final i2 = indices[i + 2];
+
+      final v0 = vertices[i0];
+      final v1 = vertices[i1];
+      final v2 = vertices[i2];
+
+      final edge1 = v1 - v0;
+      final edge2 = v2 - v0;
+      final faceNormal = edge1.cross(edge2)..normalize();
+
+      normals[i0] += faceNormal;
+      normals[i1] += faceNormal;
+      normals[i2] += faceNormal;
+    }
+    for (final normal in normals) {
+      normal.normalize();
+    }
+    return normals;
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/resource.dart b/packages/flame_3d/lib/src/resources/resource.dart
new file mode 100644
index 00000000000..b36e6f9e744
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/resource.dart
@@ -0,0 +1,19 @@
+import 'package:meta/meta.dart';
+
+// TODO(wolfenrain): in the long run it would be nice of we can make it
+// automatically refer to same type of objects to prevent memory leaks
+
+/// {@template resource}
+/// A Resource is the base class for any resource typed classes. The primary
+/// use case is to be a data container.
+/// {@endtemplate}
+class Resource<R> {
+  /// {@macro resource}
+  Resource(this._resource);
+
+  /// The resource data.
+  R get resource => _resource;
+  @protected
+  set resource(R resource) => _resource = resource;
+  R _resource;
+}
diff --git a/packages/flame_3d/lib/src/resources/shader.dart b/packages/flame_3d/lib/src/resources/shader.dart
new file mode 100644
index 00000000000..13852292920
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader.dart
@@ -0,0 +1,6 @@
+export 'shader/shader.dart';
+export 'shader/uniform_array.dart';
+export 'shader/uniform_instance.dart';
+export 'shader/uniform_sampler.dart';
+export 'shader/uniform_slot.dart';
+export 'shader/uniform_value.dart';
diff --git a/packages/flame_3d/lib/src/resources/shader/shader.dart b/packages/flame_3d/lib/src/resources/shader/shader.dart
new file mode 100644
index 00000000000..a7e1bd5f4fa
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader/shader.dart
@@ -0,0 +1,145 @@
+import 'dart:typed_data';
+import 'dart:ui';
+
+import 'package:flame_3d/game.dart';
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flutter_gpu/gpu.dart' as gpu;
+
+/// {@template shader}
+///
+/// {@endtemplate}
+class ShaderResource extends Resource<gpu.Shader> {
+  final Shader shader;
+
+  /// {@macro shader}
+  ShaderResource(
+    super.resource, {
+    required String name,
+    List<UniformSlot> slots = const [],
+  }) : shader = Shader(name: name, slots: slots) {
+    for (final slot in slots) {
+      slot.resource = resource.getUniformSlot(slot.name);
+    }
+  }
+
+  factory ShaderResource.create({
+    required String name,
+    required List<UniformSlot> slots,
+  }) {
+    final shader = _library[name];
+    if (shader == null) {
+      throw StateError('Shader "$name" not found in library');
+    }
+    return ShaderResource(shader, name: name, slots: slots);
+  }
+
+  static final _library = gpu.ShaderLibrary.fromAsset(
+    'packages/flame_3d/assets/shaders/spatial_material.shaderbundle',
+  )!;
+}
+
+class Shader {
+  final String name;
+  final List<UniformSlot> slots;
+  final Map<String, UniformInstance> instances = {};
+
+  Shader({
+    required this.name,
+    required this.slots,
+  });
+
+  /// Set a [Texture] at the given [key] on the buffer.
+  void setTexture(String key, Texture texture) => _setTypedValue(key, texture);
+
+  /// Set a [Vector2] at the given [key] on the buffer.
+  void setVector2(String key, Vector2 vector) => _setValue(key, vector.storage);
+
+  /// Set a [Vector3] at the given [key] on the buffer.
+  void setVector3(String key, Vector3 vector) => _setValue(key, vector.storage);
+
+  /// Set a [Vector4] at the given [key] on the buffer.
+  void setVector4(String key, Vector4 vector) => _setValue(key, vector.storage);
+
+  /// Set an [int] (encoded as uint) at the given [key] on the buffer.
+  void setUint(String key, int value) {
+    _setValue(key, _encodeUint32(value, Endian.little));
+  }
+
+  /// Set a [double] at the given [key] on the buffer.
+  void setFloat(String key, double value) {
+    _setValue(key, _encodeFloat32(value));
+  }
+
+  /// Set a [Matrix2] at the given [key] on the buffer.
+  void setMatrix2(String key, Matrix2 matrix) => _setValue(key, matrix.storage);
+
+  /// Set a [Matrix3] at the given [key] on the buffer.
+  void setMatrix3(String key, Matrix3 matrix) => _setValue(key, matrix.storage);
+
+  /// Set a [Matrix4] at the given [key] on the buffer.
+  void setMatrix4(String key, Matrix4 matrix) => _setValue(key, matrix.storage);
+
+  void setColor(String key, Color color) => _setValue(key, color.storage);
+
+  void bind(GraphicsDevice device) {
+    for (final slot in slots) {
+      instances[slot.name]?.bind(device);
+    }
+  }
+
+  /// Set the [data] to the [UniformSlot] identified by [key].
+  void _setValue(String key, Float32List data) {
+    _setTypedValue(key, data.buffer);
+  }
+
+  List<String?> parseKey(String key) {
+    // examples: albedoTexture, Light[2].position, or Foo.bar
+    final regex = RegExp(r'^(\w+)(?:\[(\d+)\])?(?:\.(\w+))?$');
+    return regex.firstMatch(key)?.groups([1, 2, 3]) ?? [];
+  }
+
+  /// Get the slot for the [key], it only calculates it once for every unique
+  /// [key].
+  void _setTypedValue<K, T>(String key, T value) {
+    final groups = parseKey(key);
+
+    final object = groups[0]; // e.g. Light, albedoTexture
+    final idx = _maybeParseInt(groups[1]); // e.g. 2 (optional)
+    final field = groups[2]; // e.g. position (optional)
+
+    if (object == null) {
+      throw StateError('Uniform "$key" is missing an object');
+    }
+
+    final instance = instances.putIfAbsent(object, () {
+      final slot = slots.firstWhere(
+        (e) => e.name == object,
+        orElse: () => throw StateError('Uniform "$object" is unmapped'),
+      );
+      return slot.create();
+    }) as UniformInstance<K, T>;
+
+    final k = instance.makeKey(idx, field);
+    instance.set(k, value);
+  }
+
+  static Float32List _encodeUint32(int value, Endian endian) {
+    return (ByteData(16)..setUint32(0, value, endian)).buffer.asFloat32List();
+  }
+
+  static Float32List _encodeFloat32(double value) {
+    return Float32List.fromList([value]);
+  }
+
+  static int? _maybeParseInt(String? value) {
+    if (value == null) {
+      return null;
+    }
+    return int.parse(value);
+  }
+
+  ShaderResource compile() {
+    return ShaderResource.create(name: name, slots: slots);
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/shader/uniform_array.dart b/packages/flame_3d/lib/src/resources/shader/uniform_array.dart
new file mode 100644
index 00000000000..e65779ba64c
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader/uniform_array.dart
@@ -0,0 +1,89 @@
+import 'dart:collection';
+import 'dart:typed_data';
+
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+
+typedef UniformArrayKey = ({
+  int idx,
+  String field,
+});
+
+/// {@template uniform_value}
+/// Instance of a uniform array. Represented by a [ByteBuffer].
+/// {@endtemplate}
+class UniformArray extends UniformInstance<UniformArrayKey, ByteBuffer> {
+  /// {@macro uniform_value}
+  UniformArray(super.slot);
+
+  final List<Map<int, ({int hash, List<double> data})>> _storage = [];
+
+  @override
+  ByteBuffer? get resource {
+    if (super.resource == null) {
+      final data = <double>[];
+      for (final element in _storage) {
+        var previousIndex = -1;
+        for (final entry in element.entries) {
+          if (previousIndex + 1 != entry.key) {
+            final field = slot.fields.indexed
+                .firstWhere((e) => e.$1 == previousIndex + 1);
+            throw StateError(
+              'Uniform ${slot.name}.${field.$2} was not set',
+            );
+          }
+          previousIndex = entry.key;
+          data.addAll(entry.value.data);
+        }
+      }
+      super.resource = Float32List.fromList(data).buffer;
+    }
+
+    return super.resource;
+  }
+
+  Map<int, ({int hash, List<double> data})> _get(int idx) {
+    while (idx >= _storage.length) {
+      _storage.add(HashMap());
+    }
+    return _storage[idx];
+  }
+
+  List<double>? get(int idx, String key) => _get(idx)[slot.indexOf(key)]?.data;
+
+  @override
+  void set(UniformArrayKey key, ByteBuffer buffer) {
+    final storage = _get(key.idx);
+    final index = slot.indexOf(key.field);
+
+    // Ensure that we are only setting new data if the hash has changed.
+    final data = buffer.asFloat32List();
+    final hash = Object.hashAll(data);
+    if (storage[index]?.hash == hash) {
+      return;
+    }
+
+    // Store the storage at the given slot index.
+    storage[index] = (data: data, hash: hash);
+
+    // Clear the cache.
+    super.resource = null;
+  }
+
+  @override
+  UniformArrayKey makeKey(int? idx, String? field) {
+    if (idx == null) {
+      throw StateError('idx is required for ${slot.name}');
+    }
+    if (field == null) {
+      throw StateError('field is required for ${slot.name}');
+    }
+
+    return (idx: idx, field: field);
+  }
+
+  @override
+  void bind(GraphicsDevice device) {
+    device.bindUniform(slot.resource!, resource!);
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/shader/uniform_instance.dart b/packages/flame_3d/lib/src/resources/shader/uniform_instance.dart
new file mode 100644
index 00000000000..22f18b6f013
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader/uniform_instance.dart
@@ -0,0 +1,20 @@
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template uniform_instance}
+/// An instance of a [UniformSlot] that can cache the [resource] that will be
+/// bound to a [Shader].
+/// {@endtemplate}
+abstract class UniformInstance<K, T> extends Resource<T?> {
+  /// {@macro uniform_instance}
+  UniformInstance(this.slot) : super(null);
+
+  /// The slot this instance belongs too.
+  final UniformSlot slot;
+
+  void bind(GraphicsDevice device);
+
+  void set(K key, T value);
+
+  K makeKey(int? idx, String? field);
+}
diff --git a/packages/flame_3d/lib/src/resources/shader/uniform_sampler.dart b/packages/flame_3d/lib/src/resources/shader/uniform_sampler.dart
new file mode 100644
index 00000000000..b2f168558df
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader/uniform_sampler.dart
@@ -0,0 +1,23 @@
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+
+/// {@template uniform_sampler}
+/// Instance of a uniform sampler. Represented by a [Texture].
+/// {@endtemplate}
+class UniformSampler extends UniformInstance<void, Texture> {
+  /// {@macro uniform_sampler}
+  UniformSampler(super.slot);
+
+  @override
+  void bind(GraphicsDevice device) {
+    device.bindTexture(slot.resource!, resource!);
+  }
+
+  @override
+  void set(void key, Texture value) {
+    resource = value;
+  }
+
+  @override
+  void makeKey(int? idx, String? field) {}
+}
diff --git a/packages/flame_3d/lib/src/resources/shader/uniform_slot.dart b/packages/flame_3d/lib/src/resources/shader/uniform_slot.dart
new file mode 100644
index 00000000000..fa53a1b4f80
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader/uniform_slot.dart
@@ -0,0 +1,54 @@
+import 'package:flame_3d/resources.dart';
+import 'package:flutter_gpu/gpu.dart' as gpu;
+
+/// {@template uniform_slot}
+/// Class that maps a uniform slot in such a way that it is easier to do memory
+/// allocation.
+///
+/// This allows the [Shader] to create [UniformInstance]s that bind themselves
+/// to the shader without the shader needing to the inner workings.
+/// {@endtemplate}
+class UniformSlot extends Resource<gpu.UniformSlot?> {
+  UniformSlot._(this.name, this.fields, this._instanceCreator)
+      : _fieldIndices = {for (var (index, key) in fields.indexed) key: index},
+        super(null);
+
+  /// {@macro uniform_slot}
+  ///
+  /// Used for struct uniforms in shaders.
+  ///
+  /// The [fields] should be defined in order as they appear in the struct.
+  UniformSlot.value(String name, Set<String> fields)
+      : this._(name, fields, UniformValue.new);
+
+  /// {@macro uniform_slot}
+  ///
+  /// Used for array uniforms in shaders.
+  ///
+  /// The [fields] should be defined in order as they appear in the struct.
+  UniformSlot.array(String name, Set<String> fields)
+      : this._(name, fields, UniformArray.new);
+
+  /// {@macro uniform_slot}
+  ///
+  /// Used for sampler uniforms in shaders.
+  UniformSlot.sampler(String name) : this._(name, {}, UniformSampler.new);
+
+  /// The uniform slot's name.
+  final String name;
+
+  /// The fields in the uniform and the order in which the memory should be
+  /// allocated.
+  ///
+  /// This is empty if the slot is a sampler.
+  final Set<String> fields;
+
+  /// Cache of the fields mapped to their index.
+  final Map<String, int> _fieldIndices;
+
+  final UniformInstance Function(UniformSlot) _instanceCreator;
+
+  int indexOf(String field) => _fieldIndices[field]!;
+
+  UniformInstance create() => _instanceCreator.call(this);
+}
diff --git a/packages/flame_3d/lib/src/resources/shader/uniform_value.dart b/packages/flame_3d/lib/src/resources/shader/uniform_value.dart
new file mode 100644
index 00000000000..ed2995f6c1f
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/shader/uniform_value.dart
@@ -0,0 +1,85 @@
+import 'dart:collection';
+import 'dart:typed_data';
+
+import 'package:flame_3d/graphics.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:ordered_set/comparing.dart';
+
+/// {@template uniform_value}
+/// Instance of a uniform value. Represented by a [ByteBuffer].
+///
+/// The `[]` operator can be used to set the raw data of a field. If the data is
+/// different from the last set it will recalculated the [resource].
+/// {@endtemplate}
+class UniformValue extends UniformInstance<String, ByteBuffer> {
+  /// {@macro uniform_value}
+  UniformValue(super.slot);
+
+  final Map<int, ({int hash, Float32List data})> _storage = HashMap();
+
+  @override
+  ByteBuffer? get resource {
+    if (super.resource == null) {
+      var previousIndex = -1;
+
+      final entries = _storage.entries.toList()
+        ..sort(Comparing.on((c) => c.key));
+      final data = entries.fold<List<double>>([], (p, e) {
+        if (previousIndex + 1 != e.key) {
+          final field =
+              slot.fields.indexed.firstWhere((e) => e.$1 == previousIndex + 1);
+          throw StateError('Uniform ${slot.name}.${field.$2} was not set');
+        }
+        previousIndex = e.key;
+        return p..addAll(e.value.data);
+      });
+
+      super.resource = Float32List.fromList(data).buffer;
+    }
+
+    return super.resource;
+  }
+
+  Float32List? operator [](String key) => _storage[slot.indexOf(key)]?.data;
+
+  void operator []=(String key, Float32List data) {
+    final index = slot.indexOf(key);
+
+    // Ensure that we are only setting new data if the hash has changed.
+    final hash = Object.hashAll(data);
+    if (_storage[index]?.hash == hash) {
+      return;
+    }
+
+    // Store the storage at the given slot index.
+    _storage[index] = (data: data, hash: hash);
+
+    // Clear the cache.
+    super.resource = null;
+  }
+
+  @override
+  String makeKey(int? idx, String? field) {
+    if (idx != null) {
+      throw StateError('idx is not supported for ${slot.name}');
+    }
+    if (field == null) {
+      throw StateError('field is required for ${slot.name}');
+    }
+
+    return field;
+  }
+
+  @override
+  void bind(GraphicsDevice device) {
+    device.bindUniform(slot.resource!, resource!);
+  }
+
+  @override
+  void set(String key, ByteBuffer value) {
+    if (!slot.fields.contains(key)) {
+      throw StateError('Field "$key" is unmapped for "${slot.name}"');
+    }
+    this[key] = value.asFloat32List();
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/texture.dart b/packages/flame_3d/lib/src/resources/texture.dart
new file mode 100644
index 00000000000..aad730afa8c
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/texture.dart
@@ -0,0 +1,3 @@
+export 'texture/color_texture.dart';
+export 'texture/image_texture.dart';
+export 'texture/texture.dart';
diff --git a/packages/flame_3d/lib/src/resources/texture/color_texture.dart b/packages/flame_3d/lib/src/resources/texture/color_texture.dart
new file mode 100644
index 00000000000..2ef6a490e7e
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/texture/color_texture.dart
@@ -0,0 +1,20 @@
+import 'dart:typed_data';
+import 'dart:ui';
+
+import 'package:flame_3d/resources.dart';
+
+/// {@template color_texture}
+/// A texture that holds a single color. By default it creates a 1x1 texture.
+/// {@endtemplate}
+class ColorTexture extends Texture {
+  /// {@macro color_texture}
+  ColorTexture(Color color, {int width = 1, int height = 1})
+      : super(
+          Uint32List.fromList(
+            List.filled(width * height, color.value),
+          ).buffer.asByteData(),
+          width: width,
+          height: height,
+          format: PixelFormat.bgra8888,
+        );
+}
diff --git a/packages/flame_3d/lib/src/resources/texture/image_texture.dart b/packages/flame_3d/lib/src/resources/texture/image_texture.dart
new file mode 100644
index 00000000000..4f395577ff5
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/texture/image_texture.dart
@@ -0,0 +1,17 @@
+import 'dart:ui';
+
+import 'package:flame_3d/resources.dart';
+
+/// {@template image_texture}
+/// A texture that holds an image as it's render-able texture.
+/// {@endtemplate}
+class ImageTexture extends Texture {
+  /// {@macro image_texture}
+  ImageTexture(super.source, {required super.width, required super.height});
+
+  /// Create a [ImageTexture] from the given [image].
+  static Future<ImageTexture> create(Image image) async {
+    final Image(:toByteData, :width, :height) = image;
+    return ImageTexture((await toByteData())!, width: width, height: height);
+  }
+}
diff --git a/packages/flame_3d/lib/src/resources/texture/texture.dart b/packages/flame_3d/lib/src/resources/texture/texture.dart
new file mode 100644
index 00000000000..8f4c840fea6
--- /dev/null
+++ b/packages/flame_3d/lib/src/resources/texture/texture.dart
@@ -0,0 +1,42 @@
+import 'dart:typed_data';
+import 'dart:ui';
+
+import 'package:flame_3d/resources.dart';
+import 'package:flutter_gpu/gpu.dart' as gpu;
+
+/// {@template texture}
+/// Base texture [Resource], represents an image/texture on the GPU.
+/// {@endtemplate}
+class Texture extends Resource<gpu.Texture> {
+  /// {@macro texture}
+  Texture(
+    ByteData sourceData, {
+    required int width,
+    required int height,
+    PixelFormat format = PixelFormat.rgba8888,
+  }) : super(
+          gpu.gpuContext.createTexture(
+            gpu.StorageMode.hostVisible,
+            width,
+            height,
+            format: switch (format) {
+              PixelFormat.rgba8888 => gpu.PixelFormat.r8g8b8a8UNormInt,
+              PixelFormat.bgra8888 => gpu.PixelFormat.b8g8r8a8UNormInt,
+              PixelFormat.rgbaFloat32 => gpu.PixelFormat.r32g32b32a32Float,
+            },
+          )!
+            ..overwrite(sourceData),
+        );
+
+  int get width => resource.width;
+
+  int get height => resource.height;
+
+  Image toImage() => resource.asImage();
+
+  /// A transparent single pixel texture.
+  static final empty = ColorTexture(const Color(0x00000000));
+
+  /// A white single pixel texture.
+  static final standard = ColorTexture(const Color(0xFFFFFFFF));
+}
diff --git a/packages/flame_3d/pubspec.yaml b/packages/flame_3d/pubspec.yaml
new file mode 100644
index 00000000000..b0d10c7d56e
--- /dev/null
+++ b/packages/flame_3d/pubspec.yaml
@@ -0,0 +1,32 @@
+name: flame_3d
+description: Experimental 3D support for the Flame Engine
+version: 0.1.0-dev.3
+homepage: https://github.com/flame-engine/flame/tree/main/packages/flame_3d
+funding:
+  - https://opencollective.com/blue-fire
+  - https://github.com/sponsors/bluefireteam
+  - https://patreon.com/bluefireoss
+
+environment:
+  sdk: ">=3.4.0 <4.0.0"
+  flutter: ">=3.24.0"
+
+dependencies:
+  flame: ^1.16.0
+  flutter:
+    sdk: flutter
+  flutter_gpu:
+    sdk: flutter
+  meta: ^1.12.0
+  ordered_set: ^6.0.1
+  vector_math: ^2.1.4
+
+dev_dependencies:
+  flame_lint: ^1.2.0
+  flame_test: ^1.15.3
+  flutter_test:
+    sdk: flutter
+
+flutter:
+  assets:
+    - assets/shaders/
diff --git a/packages/flame_3d/shaders/spatial_material.frag b/packages/flame_3d/shaders/spatial_material.frag
new file mode 100644
index 00000000000..511f94a8f0e
--- /dev/null
+++ b/packages/flame_3d/shaders/spatial_material.frag
@@ -0,0 +1,183 @@
+#version 460 core
+
+// implementation based on https://learnopengl.com/PBR/Lighting
+
+// #define NUM_LIGHTS 8
+#define PI 3.14159265359
+#define EPSILON 0.0001
+
+in vec2 fragTexCoord;
+in vec4 fragColor;
+in vec3 fragPosition;
+smooth in vec3 fragNormal;
+
+out vec4 outColor;
+
+uniform sampler2D albedoTexture;  // Albedo texture
+
+// material info
+
+uniform Material {
+  vec3 albedoColor;
+  float metallic;
+  float roughness;
+} material;
+
+// light info
+
+uniform AmbientLight {
+  vec3 color;
+  float intensity;
+} ambientLight;
+
+uniform LightsInfo {
+  uint numLights;
+} lightsInfo;
+
+// uniform Light {
+//   vec3 position;
+//   vec3 color;
+//   float intensity;
+// } lights[NUM_LIGHTS];
+
+uniform Light0 {
+  vec3 position;
+  vec3 color;
+  float intensity;
+} light0;
+
+uniform Light1 {
+  vec3 position;
+  vec3 color;
+  float intensity;
+} light1;
+
+uniform Light2 {
+  vec3 position;
+  vec3 color;
+  float intensity;
+} light2;
+
+// camera info
+
+uniform Camera {
+  vec3 position;
+} camera;
+
+vec3 fresnelSchlick(float cosTheta, vec3 f0) {
+  return f0 + (1.0 - f0) * pow(clamp(1.0 - cosTheta, 0.0, 1.0), 5.0);
+}
+
+float distributionGGX(vec3 normal, vec3 halfwayDir, float roughness) {
+  float a = roughness * roughness;
+  float a2 = a * a;
+  float num = a2;
+
+  float NdotH = max(dot(normal, halfwayDir), 0.0);
+  float NdotH2 = NdotH * NdotH;
+  float b = (NdotH2 * (a2 - 1.0) + 1.0);
+  float denom = PI * b * b;
+
+  return num / denom;
+}
+
+float geometrySchlickGGX(float NdotV, float roughness) {
+  float r = (roughness + 1.0);
+  float k = (r * r) / 8.0;
+
+  float num = NdotV;
+  float denom = NdotV * (1.0 - k) + k;
+
+  return num / denom;
+}
+
+float geometrySmith(vec3 normal, vec3 viewDir, vec3 lightDir, float roughness) {
+  float NdotV = max(dot(normal, viewDir), 0.0);
+  float NdotL = max(dot(normal, lightDir), 0.0);
+  float ggx2 = geometrySchlickGGX(NdotV, roughness);
+  float ggx1 = geometrySchlickGGX(NdotL, roughness);
+
+  return ggx1 * ggx2;
+}
+
+vec3 processLight(
+  vec3 lightPos,
+  vec3 lightColor,
+  float lightIntensity,
+  vec3 baseColor,
+  vec3 normal,
+  vec3 viewDir,
+  vec3 diffuse
+) {
+  vec3 lightDirVec = lightPos - fragPosition;
+  vec3 lightDir = normalize(lightDirVec);
+  float distance = length(lightDirVec) + EPSILON;
+  vec3 halfwayDir = normalize(viewDir + lightDir);
+
+  float attenuation = lightIntensity / (distance * distance);
+  vec3 radiance = lightColor * attenuation;
+
+  // cook-torrance brdf
+  float ndf = distributionGGX(normal, halfwayDir, material.roughness);
+  float g = geometrySmith(normal, viewDir, lightDir, material.roughness);
+  vec3 f = fresnelSchlick(max(dot(halfwayDir, viewDir), 0.0), diffuse);
+
+  vec3 kS = f; // reflection/specular fraction
+  vec3 kD = (vec3(1.0) - kS) * (1.0 - material.metallic); // refraction/diffuse fraction
+
+  vec3 numerator = ndf * g * f;
+  float denominator = 4.0 * max(dot(normal, viewDir), 0.0) * max(dot(normal, lightDir), 0.0) + EPSILON;
+  vec3 specular = numerator / denominator;
+
+  // add to outgoing radiance Lo
+  float NdotL = max(dot(normal, lightDir), 0.0);
+  return (kD * baseColor / PI + specular) * radiance * NdotL;
+}
+
+void main() {
+  vec3 normal = normalize(fragNormal);
+  vec3 viewDir = normalize(camera.position - fragPosition);
+
+  vec3 baseColor = material.albedoColor;
+  baseColor *= texture(albedoTexture, fragTexCoord).rgb;
+
+  vec3 baseAmbient = vec3(0.03) * baseColor * ambientLight.color * ambientLight.intensity;
+  vec3 ao = vec3(1.0); // white - no ambient occlusion for now
+  vec3 ambient = baseAmbient * baseColor * ao;
+
+  vec3 f0 = vec3(0.04);
+  vec3 diffuse = mix(f0, baseColor, material.metallic);
+
+  vec3 lo = vec3(0.0);
+
+  if (lightsInfo.numLights > 0) {
+    vec3 light0Pos = light0.position;
+    vec3 light0Color = light0.color;
+    float light0Intensity = light0.intensity;
+
+    lo += processLight(light0Pos, light0Color, light0Intensity, baseColor, normal, viewDir, diffuse);
+  }
+
+  if (lightsInfo.numLights > 1) {
+    vec3 light1Pos = light1.position;
+    vec3 light1Color = light1.color;
+    float light1Intensity = light1.intensity;
+
+    lo += processLight(light1Pos, light1Color, light1Intensity, baseColor, normal, viewDir, diffuse);
+  }
+
+  if (lightsInfo.numLights > 2) {
+    vec3 light2Pos = light2.position;
+    vec3 light2Color = light2.color;
+    float light2Intensity = light2.intensity;
+
+    lo += processLight(light2Pos, light2Color, light2Intensity, baseColor, normal, viewDir, diffuse);
+  }
+
+  vec3 color = ambient + lo;
+
+  color = color / (color + vec3(1.0));
+  color = pow(color, vec3(1.0 / 2.2));
+
+  outColor = vec4(color, 1.0);
+}
\ No newline at end of file
diff --git a/packages/flame_3d/shaders/spatial_material.vert b/packages/flame_3d/shaders/spatial_material.vert
new file mode 100644
index 00000000000..f7dfc0b4966
--- /dev/null
+++ b/packages/flame_3d/shaders/spatial_material.vert
@@ -0,0 +1,108 @@
+#version 460 core
+
+in vec3 vertexPosition;
+in vec2 vertexTexCoord;
+in vec4 vertexColor;
+in vec3 vertexNormal;
+in vec4 vertexJoints;
+in vec4 vertexWeights;
+
+out vec2 fragTexCoord;
+out vec4 fragColor;
+out vec3 fragPosition;
+out vec3 fragNormal;
+
+uniform VertexInfo {
+  mat4 model;
+  mat4 view;
+  mat4 projection;
+} vertex_info;
+
+uniform JointMatrices {
+  mat4 joint0;
+  mat4 joint1;
+  mat4 joint2;
+  mat4 joint3;
+  mat4 joint4;
+  mat4 joint5;
+  mat4 joint6;
+  mat4 joint7;
+  mat4 joint8;
+  mat4 joint9;
+  mat4 joint10;
+  mat4 joint11;
+  mat4 joint12;
+  mat4 joint13;
+  mat4 joint14;
+  mat4 joint15;
+} joints;
+
+mat4 jointMat(float jointIndex) {
+  if (jointIndex == 0.0) {
+    return joints.joint0;
+  } else if (jointIndex == 1.0) {
+    return joints.joint1;
+  } else if (jointIndex == 2.0) {
+    return joints.joint2;
+  } else if (jointIndex == 3.0) {
+    return joints.joint3;
+  } else if (jointIndex == 4.0) {
+    return joints.joint4;
+  } else if (jointIndex == 5.0) {
+    return joints.joint5;
+  } else if (jointIndex == 6.0) {
+    return joints.joint6;
+  } else if (jointIndex == 7.0) {
+    return joints.joint7;
+  } else if (jointIndex == 8.0) {
+    return joints.joint8;
+  } else if (jointIndex == 9.0) {
+    return joints.joint9;
+  } else if (jointIndex == 10.0) {
+    return joints.joint10;
+  } else if (jointIndex == 11.0) {
+    return joints.joint11;
+  } else if (jointIndex == 12.0) {
+    return joints.joint12;
+  } else if (jointIndex == 13.0) {
+    return joints.joint13;
+  } else if (jointIndex == 14.0) {
+    return joints.joint14;
+  } else if (jointIndex == 15.0) {
+    return joints.joint15;
+  } else {
+    return mat4(0.0);
+  }
+}
+
+mat4 computeSkinMatrix() {
+  if (vertexWeights.x == 0.0 && vertexWeights.y == 0.0 && vertexWeights.z == 0.0 && vertexWeights.w == 0.0) {
+    // no weights, skip skinning
+    return mat4(1.0);
+  }
+
+  return vertexWeights.x * jointMat(vertexJoints.x) +
+    vertexWeights.y * jointMat(vertexJoints.y) +
+    vertexWeights.z * jointMat(vertexJoints.z) +
+    vertexWeights.w * jointMat(vertexJoints.w);
+}
+
+void main() {
+  mat4 skinMatrix = computeSkinMatrix();
+  vec3 position = (skinMatrix * vec4(vertexPosition, 1.0)).xyz;
+  vec3 normal = normalize((skinMatrix * vec4(vertexNormal, 0.0)).xyz);
+
+  // Calculate the modelview projection matrix
+  mat4 modelViewProjection = vertex_info.projection * vertex_info.view * vertex_info.model;
+
+  // Transform the vertex position
+  gl_Position = modelViewProjection * vec4(position, 1.0);
+
+  // Pass the interpolated values to the fragment shader
+  fragTexCoord = vertexTexCoord;
+  fragColor = vertexColor;
+
+  // Calculate the world-space position and normal
+  fragPosition = vec3(vertex_info.model * vec4(position, 1.0));
+  fragNormal = mat3(transpose(inverse(vertex_info.model))) * normal;
+}
diff --git a/packages/flame_3d/test/quaternion_extensions_test.dart b/packages/flame_3d/test/quaternion_extensions_test.dart
new file mode 100644
index 00000000000..359dc60d78a
--- /dev/null
+++ b/packages/flame_3d/test/quaternion_extensions_test.dart
@@ -0,0 +1,62 @@
+import 'package:flame_3d/game.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+void main() {
+  group('Quaternion extensions', () {
+    test('can lerp', () {
+      final a = Quaternion(1, 2, 3, 4);
+      final b = Quaternion(3, 4, 5, 6);
+
+      final result = a.lerp(b, 0.5);
+      expect(result.x, 2);
+      expect(result.y, 3);
+      expect(result.z, 4);
+      expect(result.w, 5);
+    });
+
+    test('can slerp', () {
+      const angle1 = 1.2;
+      const angle2 = 0.7;
+      const angle3 = angle2 + _epsilon * 10;
+
+      final axis = Vector3(1, 0, 0);
+
+      final quaternion1 = Quaternion.axisAngle(axis, angle1);
+      final quaternion2 = Quaternion.axisAngle(axis, angle2);
+      final quaternion3 = Quaternion.axisAngle(axis, angle3);
+
+      final slerp1 = QuaternionUtils.slerp(quaternion1, quaternion2, 0.5);
+      expect(
+        angle1 - 0.5 * (angle1 - angle2),
+        closeTo(slerp1.radians, _epsilon),
+      );
+
+      final slerp2 = QuaternionUtils.slerp(quaternion2, quaternion3, 0.75);
+      expect(
+        angle2 + 0.75 * (angle3 - angle2),
+        closeTo(slerp2.radians, _epsilon),
+      );
+
+      final slerp3 = QuaternionUtils.slerp(quaternion2, quaternion2, 0.5);
+      expect(angle2, closeTo(slerp3.radians, _epsilon));
+    });
+
+    test('slerp edge cases', () {
+      const angle1 = 1.2;
+      const angle2 = angle1 + _epsilon;
+
+      final axis = Vector3(1, 0, 0);
+
+      final quaternion1 = Quaternion.axisAngle(axis, angle1);
+      final quaternion2 = Quaternion.axisAngle(axis, angle2);
+
+      final slerp1 = QuaternionUtils.slerp(quaternion1, quaternion2, 0);
+      expect(angle1, closeTo(slerp1.radians, _epsilon));
+
+      final slerp2 = QuaternionUtils.slerp(quaternion1, quaternion2, 1);
+      expect(angle2, closeTo(slerp2.radians, _epsilon));
+    });
+  });
+}
+
+const _epsilon = 10e-6;
diff --git a/packages/flame_3d/test/resources/shader/uniform_binding_test.dart b/packages/flame_3d/test/resources/shader/uniform_binding_test.dart
new file mode 100644
index 00000000000..f628a34df6e
--- /dev/null
+++ b/packages/flame_3d/test/resources/shader/uniform_binding_test.dart
@@ -0,0 +1,113 @@
+import 'dart:typed_data';
+
+import 'package:flame_3d/core.dart';
+import 'package:flame_3d/resources.dart';
+import 'package:flame_3d/src/resources/shader.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+void main() {
+  group('uniform bindings', () {
+    test('can bind a vec3 a slot', () {
+      final slot = UniformSlot.value('Vertex', {'position'});
+      final shader = _createShader([slot]);
+
+      shader.setVector3('Vertex.position', Vector3(7, 8, 9));
+
+      final bytes = shader.instances['Vertex']!.resource as ByteBuffer;
+      final result = Vector3.fromBuffer(bytes, 0);
+      expect(result, Vector3(7, 8, 9));
+    });
+
+    test('can bind multiple vector slots', () {
+      final slot = UniformSlot.value('AmbientLight', {'color', 'position'});
+      final shader = _createShader([slot]);
+
+      shader.setVector3('AmbientLight.position', Vector3(7, 8, 9));
+      shader.setVector4('AmbientLight.color', Vector4(4, 3, 2, 1));
+
+      final bytes = shader.instances['AmbientLight']!.resource as ByteBuffer;
+
+      final color = Vector4.fromBuffer(bytes, 0);
+      expect(color, Vector4(4, 3, 2, 1));
+
+      final position = Vector3.fromBuffer(bytes, color.storage.lengthInBytes);
+      expect(position, Vector3(7, 8, 9));
+    });
+
+    test('can bind a mat4 a slot', () {
+      final slot = UniformSlot.value('Vertex', {'camera'});
+      final shader = _createShader([slot]);
+
+      shader.setMatrix4('Vertex.camera', Matrix4.identity());
+
+      final bytes = shader.instances['Vertex']!.resource as ByteBuffer;
+      final result = Matrix4.fromBuffer(bytes, 0);
+      expect(result, Matrix4.identity());
+    });
+
+    test('can bind a vec3 to an array slot', () {
+      final slot = UniformSlot.array('Light', {'position'});
+      final shader = _createShader([slot]);
+
+      shader.setVector3('Light[0].position', Vector3(7, 8, 9));
+
+      final bytes = shader.instances['Light']!.resource as ByteBuffer;
+      final result = Vector3.fromBuffer(bytes, 0);
+
+      expect(result, Vector3(7, 8, 9));
+    });
+
+    test('can bind multiple slots', () {
+      final slots = [
+        UniformSlot.value('Vertex', {'position'}),
+        UniformSlot.value('Material', {'color', 'metallic'}),
+        UniformSlot.array('Light', {'position', 'color'}),
+      ];
+      final shader = _createShader(slots);
+
+      shader.setVector3('Vertex.position', Vector3(1, 2, 3));
+      shader.setVector4('Material.color', Vector4(4, 3, 2, 1));
+      shader.setFloat('Material.metallic', 0.5);
+      shader.setVector3('Light[0].position', Vector3(11, 12, 13));
+      shader.setVector4('Light[0].color', Vector4(14, 15, 16, 17));
+      shader.setVector3('Light[1].position', Vector3(-1, -2, -3));
+      shader.setVector4('Light[1].color', Vector4(-11, -12, -13, -14));
+
+      final vertex = shader.instances['Vertex']!.resource as ByteBuffer;
+      final vertexResult = Vector3.fromBuffer(vertex, 0);
+      expect(vertexResult, Vector3(1, 2, 3));
+
+      final material = shader.instances['Material']!.resource as ByteBuffer;
+      final color = Vector4.fromBuffer(material, 0);
+      expect(color, Vector4(4, 3, 2, 1));
+      final metallic = Float32List.view(material, color.storage.lengthInBytes);
+      expect(metallic[0], 0.5);
+
+      final light = shader.instances['Light']!.resource as ByteBuffer;
+
+      var cursor = 0;
+
+      final light0Position = Vector3.fromBuffer(light, cursor);
+      expect(light0Position, Vector3(11, 12, 13));
+      cursor += light0Position.storage.lengthInBytes;
+
+      final light0Color = Vector4.fromBuffer(light, cursor);
+      expect(light0Color, Vector4(14, 15, 16, 17));
+      cursor += light0Color.storage.lengthInBytes;
+
+      final light1Position = Vector3.fromBuffer(light, cursor);
+      expect(light1Position, Vector3(-1, -2, -3));
+      cursor += light1Position.storage.lengthInBytes;
+
+      final light1Color = Vector4.fromBuffer(light, cursor);
+      expect(light1Color, Vector4(-11, -12, -13, -14));
+    });
+  });
+}
+
+Shader _createShader(List<UniformSlot> slots) {
+  return Shader(
+    name: '-test-',
+    slots: slots,
+  );
+}
diff --git a/packages/flame_3d/test/vector2_extensions_test.dart b/packages/flame_3d/test/vector2_extensions_test.dart
new file mode 100644
index 00000000000..5e7b592d958
--- /dev/null
+++ b/packages/flame_3d/test/vector2_extensions_test.dart
@@ -0,0 +1,28 @@
+import 'package:flame_3d/core.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+void main() {
+  group('Vector2 extensions', () {
+    test('can convert back and forth to mutable', () {
+      final src = Vector2(1, 2);
+
+      final immutable = src.immutable;
+      expect(immutable.x, 1);
+      expect(immutable.y, 2);
+      expect(immutable.storage, [1, 2]);
+
+      final mutable = immutable.mutable;
+      expect(mutable.x, 1);
+      expect(mutable.y, 2);
+    });
+
+    test('can lerp', () {
+      final a = Vector2(1, 2);
+      final b = Vector2(3, 4);
+
+      final result = a.lerp(b, 0.5);
+      expect(result.x, 2);
+      expect(result.y, 3);
+    });
+  });
+}
diff --git a/packages/flame_3d/test/vector3_extensions_test.dart b/packages/flame_3d/test/vector3_extensions_test.dart
new file mode 100644
index 00000000000..2a4753c2ee7
--- /dev/null
+++ b/packages/flame_3d/test/vector3_extensions_test.dart
@@ -0,0 +1,39 @@
+import 'package:flame_3d/game.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+void main() {
+  group('Vector3 extensions', () {
+    test('can convert back and forth to mutable', () {
+      final src = Vector3(1, 2, 3);
+
+      final immutable = src.immutable;
+      expect(immutable.x, 1);
+      expect(immutable.y, 2);
+      expect(immutable.z, 3);
+      expect(immutable.storage, [1, 2, 3]);
+
+      final mutable = immutable.mutable;
+      expect(mutable.x, 1);
+      expect(mutable.y, 2);
+      expect(mutable.z, 3);
+    });
+
+    test('can subtract immutable vector3', () {
+      final a = Vector3(0, 10, 0).immutable;
+      final b = Vector3(1, 2, 3);
+
+      expect((a - b).storage, [-1, 8, -3]);
+      expect((a - b.immutable).storage, [-1, 8, -3]);
+    });
+
+    test('can lerp', () {
+      final a = Vector3(1, 2, 3);
+      final b = Vector3(3, 4, 5);
+
+      final result = a.lerp(b, 0.5);
+      expect(result.x, 2);
+      expect(result.y, 3);
+      expect(result.z, 4);
+    });
+  });
+}
diff --git a/packages/flame_3d/test/vector4_extensions_test.dart b/packages/flame_3d/test/vector4_extensions_test.dart
new file mode 100644
index 00000000000..64ec92d3165
--- /dev/null
+++ b/packages/flame_3d/test/vector4_extensions_test.dart
@@ -0,0 +1,34 @@
+import 'package:flame_3d/game.dart';
+import 'package:flutter_test/flutter_test.dart';
+
+void main() {
+  group('Vector4 extensions', () {
+    test('can convert back and forth to mutable', () {
+      final src = Vector4(1, 2, 3, 4);
+
+      final immutable = src.immutable;
+      expect(immutable.x, 1);
+      expect(immutable.y, 2);
+      expect(immutable.z, 3);
+      expect(immutable.w, 4);
+      expect(immutable.storage, [1, 2, 3, 4]);
+
+      final mutable = immutable.mutable;
+      expect(mutable.x, 1);
+      expect(mutable.y, 2);
+      expect(mutable.z, 3);
+      expect(mutable.w, 4);
+    });
+
+    test('can lerp', () {
+      final a = Vector4(1, 2, 3, 4);
+      final b = Vector4(3, 4, 5, 6);
+
+      final result = a.lerp(b, 0.5);
+      expect(result.x, 2);
+      expect(result.y, 3);
+      expect(result.z, 4);
+      expect(result.w, 5);
+    });
+  });
+}
